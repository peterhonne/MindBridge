<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MindBridge AI - Therapeutic Platform</title>
    <link rel="icon" href="favicon.png" type="image/png" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .app-container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 1200px;
            height: 90vh;
            display: none; /* Hide by default until authentication is verified */
            grid-template-columns: 300px 1fr;
            overflow: hidden;
            position: relative;
        }

        .sidebar {
            background: linear-gradient(180deg, #4a90e2 0%, #357abd 100%);
            color: white;
            padding: 30px;
            display: flex;
            flex-direction: column;
            gap: 25px;
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            padding: 20px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .agent-status {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .agent-role {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .role-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #4ade80;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .agent-description {
            font-size: 14px;
            opacity: 0.9;
            line-height: 1.4;
        }

        .session-info {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
        }

        .session-info h3 {
            margin-bottom: 15px;
            font-size: 16px;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .crisis-monitor {
            background: rgba(34, 197, 94, 0.2);
            border: 2px solid #22c55e;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
        }

        .crisis-monitor.alert {
            background: rgba(239, 68, 68, 0.2);
            border-color: #ef4444;
            animation: alertPulse 1s infinite;
        }

        @keyframes alertPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .crisis-status {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .main-content {
            display: flex;
            flex-direction: column;
            background: #fafafa;
            border-bottom-right-radius: 20px;
            overflow: hidden;
        }

        .header {
            background: white;
            padding: 20px 30px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        .connection-status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: #22c55e;
        }

        .connection-status.disconnected {
            color: #ef4444;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #22c55e;
            animation: pulse 2s infinite;
        }

        .status-dot.disconnected {
            background: #ef4444;
        }

        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }

        .messages {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-height: 0;
        }

        .message {
            display: flex;
            animation: messageSlide 0.3s ease-out;
            margin-bottom: 2px;
            justify-content: flex-start;
        }
        
        .message + .message {
            margin-top: 2px;
        }
        
        .message.user + .message.user .message-content {
            border-radius: 18px;
            border-bottom-right-radius: 8px;
        }
        
        .message.agent + .message.agent .message-content {
            border-radius: 18px;
            border-bottom-left-radius: 8px;
        }
        
        .message.user:first-child .message-content,
        .message.user:not(.user) + .message.user .message-content,
        .timestamp-header + .message.user .message-content {
            border-top-right-radius: 18px;
        }
        
        .message.agent:first-child .message-content,
        .message.agent:not(.agent) + .message.agent .message-content,
        .timestamp-header + .message.agent .message-content {
            border-top-left-radius: 18px;
        }
        
        .message.user:last-child .message-content,
        .message.user + .message:not(.user) .message-content {
            border-bottom-right-radius: 8px;
        }
        
        .message.agent:last-child .message-content,
        .message.agent + .message:not(.agent) .message-content {
            border-bottom-left-radius: 8px;
        }
        
        .timestamp-header {
            text-align: center;
            color: #8E8E93;
            font-size: 13px;
            font-weight: 400;
            margin: 20px 0 15px 0;
            pointer-events: none;
            user-select: none;
        }

        @keyframes messageSlide {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.user {
            justify-content: flex-end;
        }


        .message-content {
            max-width: 70%;
            padding: 12px 18px;
            border-radius: 25px;
            line-height: 1.4;
            position: relative;
            font-size: 16px;
            word-wrap: break-word;
            overflow-wrap: break-word;
            overflow: hidden;
        }

        /* Fix markdown content overflow */
        .message-content ul, .message-content ol {
            margin: 0;
            padding-left: 20px;
            max-width: 100%;
            overflow-wrap: break-word;
        }

        .message-content li {
            margin: 4px 0;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .message-content p {
            margin: 0 0 8px 0;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .message-content p:last-child {
            margin-bottom: 0;
        }

        .message-content strong, .message-content em {
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .message.user .message-content {
            background: #007AFF;
            color: white;
            border-bottom-right-radius: 8px;
        }

        .message.agent .message-content {
            background: #E5E5EA;
            color: #000000;
            border-bottom-left-radius: 8px;
        }



        .typing-indicator {
            display: none;
            align-items: center;
            gap: 15px;
            padding: 20px 30px;
        }

        .typing-indicator.active {
            display: flex;
        }

        .typing-dots {
            display: flex;
            gap: 4px;
        }

        .typing-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #9ca3af;
            animation: typing 1.4s infinite;
        }

        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
                opacity: 0.4;
            }
            30% {
                transform: translateY(-10px);
                opacity: 1;
            }
        }

        .input-container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-top: 1px solid rgba(255, 255, 255, 0.3);
            padding: 15px;
            display: flex;
            align-items: flex-end;
            gap: 12px;
            flex-shrink: 0;
            border-bottom-right-radius: 20px;
            min-height: 64px;
        }

        .input-wrapper {
            flex: 1;
            display: flex;
            align-items: flex-end;
            gap: 12px;
            min-height: 44px;
        }

        .text-input-container {
            flex: 1;
            background: #F2F2F7;
            border-radius: 20px;
            padding: 8px 16px;
            min-height: 36px;
            display: flex;
            align-items: center;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .text-input-container:focus-within {
            background: #FFFFFF;
            border-color: #007AFF;
            box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.1);
        }

        .message-input {
            width: 100%;
            border: none;
            outline: none;
            background: transparent;
            font-size: 16px;
            line-height: 20px;
            resize: none;
            min-height: 20px;
            max-height: 120px;
            overflow-y: auto;
            font-family: inherit;
            color: #000;
        }

        .message-input::placeholder {
            color: #8E8E93;
        }

        .send-button {
            width: 32px;
            height: 32px;
            border: none;
            background: #007AFF;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            flex-shrink: 0;
            margin-bottom: 6px;
            opacity: 0.5;
            transform: scale(0.8);
        }

        .send-button.active {
            opacity: 1;
            transform: scale(1);
            background: #007AFF;
        }

        .send-button.active:hover {
            background: #0056CC;
            transform: scale(1.05);
        }

        .send-button svg {
            width: 16px;
            height: 16px;
            fill: white;
            transform: translateX(1px);
        }

        /* Custom scrollbar for textarea */
        .message-input::-webkit-scrollbar {
            width: 4px;
        }

        .message-input::-webkit-scrollbar-track {
            background: transparent;
        }

        .message-input::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 2px;
        }

        .message-input::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.3);
        }

        .crisis-alert {
            background: linear-gradient(45deg, #ef4444, #dc2626);
            color: white;
            padding: 15px 20px;
            margin: 10px 30px;
            border-radius: 10px;
            display: none;
            align-items: center;
            gap: 10px;
            animation: slideDown 0.3s ease-out;
        }

        .crisis-alert.active {
            display: flex;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .crisis-icon {
            font-size: 20px;
        }

        @media (max-width: 768px) {
            .app-container {
                grid-template-columns: 1fr;
                height: 100vh;
                border-radius: 0;
            }

            .sidebar {
                display: none;
            }
            
            .messages {
                padding: 15px;
                max-height: calc(100vh - 200px);
            }
            
            .input-container {
                padding: 15px;
            }
        }
        
        @media (max-width: 1024px) and (min-width: 769px) {
            .app-container {
                grid-template-columns: 250px 1fr;
            }
            
            .sidebar {
                padding: 20px 15px;
            }
            
            .messages {
                padding: 20px;
            }
        }

        /* Loading screen styles */
        .auth-loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            color: white;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 18px;
            font-weight: 500;
            margin-bottom: 10px;
        }

        .loading-subtext {
            font-size: 14px;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <!-- Loading screen shown by default -->
    <div class="auth-loading" id="authLoading">
        <div class="loading-spinner"></div>
        <div class="loading-text">MindBridge AI</div>
        <div class="loading-subtext">Initializing secure connection...</div>
    </div>

    <div class="app-container">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="logo">🧠 MindBridge AI</div>

            <div class="agent-status">
                <div class="agent-role">
                    <span class="role-indicator"></span>
                    <span id="currentRole">CBT Therapist</span>
                </div>
                <div class="agent-description" id="roleDescription">
                    Helping you restructure negative thought patterns using evidence-based cognitive behavioral techniques.
                </div>
            </div>

            <div class="session-info">
                <h3>Session Info</h3>
                <div class="info-item">
                    <span>Duration:</span>
                    <span id="sessionTime">00:00</span>
                </div>
                <div class="info-item">
                    <span>Messages:</span>
                    <span id="messageCount">0</span>
                </div>
                <div class="info-item">
                    <span>Mood Trend:</span>
                    <span id="moodTrend">📈 Improving</span>
                </div>
            </div>

            <div class="crisis-monitor" id="crisisMonitor">
                <div class="crisis-status">✅ Safe Zone</div>
                <div style="font-size: 12px; opacity: 0.8;">
                    Continuous monitoring active
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <div class="header">
                <div class="user-info">
                    <div class="avatar">JD</div>
                    <div>
                        <div style="font-weight: 600;">Honne</div>
                        <div style="font-size: 14px; color: #6b7280;">Patient ID: #12345</div>
                    </div>
                </div>
                <div style="display: flex; align-items: center; gap: 20px;">
                    <div class="connection-status" id="connectionStatus">
                        <span class="status-dot" id="statusDot"></span>
                        <span id="connectionText">Connecting...</span>
                    </div>
                    <button onclick="keycloakLogout()" style="padding: 8px 16px; background: #ef4444; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px;">
                        Logout
                    </button>
                </div>
            </div>

            <div class="crisis-alert" id="crisisAlert">
                <span class="crisis-icon">🚨</span>
                <div>
                    <strong>Crisis Mode Activated</strong> - Switching to Crisis Counselor mode for immediate support.
                </div>
            </div>

            <div class="chat-container">
                <div class="messages" id="messages">
                </div>

                <div class="typing-indicator" id="typingIndicator">
                    <div style="max-width: 70%; padding: 12px 18px; border-radius: 25px; background: #E5E5EA; position: relative; border-bottom-left-radius: 8px;">
                        <div class="typing-dots">
                            <div class="typing-dot"></div>
                            <div class="typing-dot"></div>
                            <div class="typing-dot"></div>
                        </div>
                    </div>
                </div>

                <div class="input-container">
                    <div class="input-wrapper">
                        <div class="text-input-container">
                            <textarea 
                                class="message-input" 
                                id="messageInput" 
                                rows="1"
                                maxlength="1000"
                                placeholder="Message"
                            ></textarea>
                        </div>

                        <button class="send-button" id="sendButton" title="Send message">
                            <svg viewBox="0 0 24 24">
                                <path d="M2,21L23,12L2,3V10L17,12L2,14V21Z"/>
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- STOMP.js for WebSocket communication -->
    <script src="https://cdn.jsdelivr.net/npm/@stomp/stompjs@7.0.0/bundles/stomp.umd.min.js"></script>
    <script src="https://unpkg.com/marked@9.1.2/marked.min.js"></script>
    <!-- Keycloak JS -->
    <script src="https://cdn.jsdelivr.net/npm/keycloak-js@23.0.0/dist/keycloak.min.js"></script>

    <!-- Authentication Guard -->
    <script>
        // API Configuration - automatically detects environment
        const API_CONFIG = {
            // Auto-detect if running locally or on cloud
            isLocal: window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1',
            
            // Base URLs that change between environments
            get keycloakUrl() {
                return this.isLocal ? 'http://localhost:8080' : 'https://auth.honne.app';
            },
            
            get backendUrl() {
                return this.isLocal ? 'http://localhost:8082' : 'https://mindbridge.honne.app';
            },

            get websocketUrl() {
                const protocol = this.isLocal ? 'ws' : 'wss';
                const host = this.isLocal ? 'localhost:8082' : 'mindbridge.honne.app';
                return `${protocol}://${host}/v1/agent/mindbridge`;
            }
        };

        // Keycloak configuration using dynamic URL
        const KEYCLOAK_CONFIG = {
            url: API_CONFIG.keycloakUrl,
            realm: 'MindBridge',
            clientId: 'MindBridgeClient'
        };
        
        
        let keycloakInstance = null;
        let authMode = 'checking'; // 'checking', 'keycloak'
        let initializationInProgress = false;
        let initializationCompleted = false;
        let keycloakInitAttempted = false;
        
        // Function to reset initialization state (useful for debugging)
        function resetInitializationState() {
            console.log('Resetting initialization state...');
            initializationInProgress = false;
            initializationCompleted = false;
            domContentLoadedHandled = false;
            keycloakInitAttempted = false;
            window.mainAppInitialized = false;
            if (window.sessionInfoInterval) {
                clearInterval(window.sessionInfoInterval);
                window.sessionInfoInterval = null;
            }
        }
        
        // Expose reset function globally for debugging
        window.resetInitializationState = resetInitializationState;
        
        // Handle OAuth callback from Keycloak
        async function handleOAuthCallback() {
            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('code');
            const state = urlParams.get('state');
            const sessionState = urlParams.get('session_state');
            
            if (code) {
                console.log('OAuth callback detected, exchanging code for token...');
                
                try {
                    // Exchange authorization code for tokens
                    const redirectUri = getRedirectUri();
                    const formData = new URLSearchParams();
                    formData.append('grant_type', 'authorization_code');
                    formData.append('client_id', KEYCLOAK_CONFIG.clientId);
                    formData.append('code', code);
                    formData.append('redirect_uri', redirectUri);
                    
                    const response = await fetch(`${KEYCLOAK_CONFIG.url}/realms/${KEYCLOAK_CONFIG.realm}/protocol/openid-connect/token`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        },
                        body: formData.toString(),
                    });
                    
                    if (response.ok) {
                        const tokenResponse = await response.json();
                        
                        // Store tokens
                        localStorage.setItem('token', tokenResponse.access_token);
                        localStorage.setItem('refreshToken', tokenResponse.refresh_token);
                        
                        // Clean URL and show main app
                        window.history.replaceState({}, document.title, window.location.pathname);
                        showMainApp();
                        return true;
                    } else {
                        const error = await response.json();
                        console.error('Token exchange failed:', error);
                        throw new Error(error.error_description || 'Token exchange failed');
                    }
                } catch (error) {
                    console.error('OAuth callback error:', error);
                    // Clear URL parameters and show login
                    window.history.replaceState({}, document.title, window.location.pathname);
                    showLoginFallback();
                    return false;
                }
            }
            
            return false;
        }
        
        // Track if initialization has started
        let domContentLoadedHandled = false;
        
        // Prevent back navigation to authenticated pages after logout
        window.addEventListener('pageshow', function(event) {
            // Check if this is a back/forward navigation
            if (event.persisted) {
                console.log('Page loaded from cache (back/forward navigation detected)');
                // Check if user is actually logged out
                const hasToken = localStorage.getItem('token') || localStorage.getItem('refreshToken');
                if (!hasToken) {
                    console.log('No valid tokens found, redirecting to login');
                    window.location.replace(window.location.origin + window.location.pathname + '?logout=true');
                    return;
                }
            }
        });
        
        // Immediately hide the page and check authentication
        document.addEventListener('DOMContentLoaded', async function() {
            if (domContentLoadedHandled || initializationInProgress || initializationCompleted) {
                console.log('DOMContentLoaded already handled or initialization in progress, skipping...');
                return;
            }
            domContentLoadedHandled = true;
            
            console.log('DOMContentLoaded triggered, starting authentication check...');
            const appContainer = document.querySelector('.app-container');
            if (appContainer) {
                appContainer.style.display = 'none';
            }
            
            // Check URL parameters for OAuth callback
            const urlParams = new URLSearchParams(window.location.search);
            const hasCode = urlParams.has('code');
            const hasLogoutParam = urlParams.has('logout') || window.location.href.includes('logout');
            
            if (hasCode) {
                // Handle OAuth callback
                const callbackHandled = await handleOAuthCallback();
                if (callbackHandled) {
                    return; // OAuth callback handled successfully
                }
            }
            
            if (hasLogoutParam) {
                // Clear any existing tokens after logout redirect
                localStorage.clear();
                sessionStorage.clear();
                console.log('Logout completed, showing login form');
                
                // Clear the logout flag from URL
                window.history.replaceState({}, document.title, window.location.pathname);
                
                // Mark initialization as completed to prevent any auth attempts
                initializationCompleted = true;
                domContentLoadedHandled = true;
                
                // Reset logout progress flag
                window.logoutInProgress = false;
                
                // Show login form
                showLoginFallback();
                return;
            }
            
            
            // Check if we already have tokens
            const existingToken = localStorage.getItem('token');
            const existingRefreshToken = localStorage.getItem('refreshToken');
            
            if (existingToken || existingRefreshToken) {
                console.log('Found existing tokens, validating...');
                // Try to validate token first, or refresh if only refresh token exists
                const isValid = await validateExistingToken(existingToken, existingRefreshToken);
                if (isValid) {
                    return; // Token is valid or was refreshed, main app will be shown
                }
                // If both access and refresh tokens are invalid, continue to Keycloak initialization
            }
            
            console.log('No valid token, initializing Keycloak');
            // Initialize Keycloak with a small delay to prevent race conditions
            setTimeout(() => {
                if (!initializationInProgress && !initializationCompleted) {
                    initKeycloakAuth();
                }
            }, 100);
        });
        
        async function validateExistingToken(token, refreshToken) {
            try {
                // If no access token but have refresh token, try to refresh immediately
                if (!token && refreshToken) {
                    console.log('No access token found, but refresh token exists. Attempting refresh...');
                    try {
                        const newToken = await refreshWithStoredToken(refreshToken);
                        if (newToken) {
                            console.log('✅ Token refreshed successfully on page load');
                            initializationCompleted = true;
                            showMainApp();
                            return true;
                        }
                    } catch (refreshError) {
                        console.log('❌ Refresh failed during page load:', refreshError);
                        // Clear invalid refresh token
                        localStorage.removeItem('token');
                        localStorage.removeItem('refreshToken');
                        initializationCompleted = true;
                        showLoginFallback();
                        return false;
                    }
                }
                
                // If we have an access token, validate it
                if (token) {
                    // Decode JWT to check if it's expired
                    const payload = decodeJWT(token);
                    const now = Math.floor(Date.now() / 1000);
                    
                    console.log('Token validation - Current time:', now, 'Token exp:', payload.exp);
                    
                    if (payload.exp && payload.exp > now) {
                        console.log('✅ Token is valid, showing main app');
                        initializationCompleted = true;
                        showMainApp();
                        return true;
                    } else {
                        console.log('❌ Access token expired, attempting refresh...');
                        
                        // Try to refresh using refresh token
                        if (refreshToken) {
                            try {
                                const newToken = await refreshWithStoredToken(refreshToken);
                                if (newToken) {
                                    console.log('✅ Token refreshed successfully on page load');
                                    initializationCompleted = true;
                                    showMainApp();
                                    return true;
                                }
                            } catch (refreshError) {
                                console.log('❌ Refresh failed during page load:', refreshError);
                            }
                        }
                        
                        // If refresh fails or no refresh token, clear everything
                        console.log('❌ No valid refresh token, clearing and showing login');
                        localStorage.removeItem('token');
                        localStorage.removeItem('refreshToken');
                        initializationCompleted = true;
                        showLoginFallback();
                        return false;
                    }
                }
                
                // If no tokens at all, return false
                console.log('❌ No tokens found');
                return false;
                
            } catch (error) {
                console.log('❌ Invalid token, clearing and showing login:', error);
                localStorage.removeItem('token');
                localStorage.removeItem('refreshToken');
                initializationCompleted = true;
                showLoginFallback();
                return false;
            }
        }

        // Helper function to refresh token using stored refresh token
        async function refreshWithStoredToken(refreshToken) {
            try {
                console.log('Attempting token refresh with stored refresh token...');
                
                const response = await fetch(`${KEYCLOAK_CONFIG.url}/realms/${KEYCLOAK_CONFIG.realm}/protocol/openid-connect/token`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: new URLSearchParams({
                        'grant_type': 'refresh_token',
                        'client_id': KEYCLOAK_CONFIG.clientId,
                        'refresh_token': refreshToken
                    })
                });
                
                if (response.ok) {
                    const tokenData = await response.json();
                    localStorage.setItem('token', tokenData.access_token);
                    localStorage.setItem('refreshToken', tokenData.refresh_token);
                    console.log('✅ Token refreshed successfully');
                    return tokenData.access_token;
                } else {
                    const errorData = await response.json();
                    console.error('❌ Refresh token response error:', errorData);
                    throw new Error('Refresh token request failed: ' + (errorData.error_description || errorData.error));
                }
            } catch (error) {
                console.error('❌ Refresh token exchange failed:', error);
                throw error;
            }
        }
        
        async function initKeycloakAuth() {
            // Prevent multiple concurrent initializations
            if (initializationInProgress || initializationCompleted || keycloakInitAttempted) {
                console.log('Keycloak initialization already in progress, completed, or attempted. Skipping...');
                return;
            }
            
            initializationInProgress = true;
            keycloakInitAttempted = true;
            console.log('Initializing Keycloak authentication...');
            
            // Check if Keycloak library is loaded
            if (typeof Keycloak === 'undefined') {
                console.error('Keycloak library not loaded');
                initializationInProgress = false;
                showKeycloakError();
                return;
            }
            
            // First check if Keycloak server is available
            console.log('About to check Keycloak availability...');
            const isKeycloakAvailable = await checkKeycloakAvailability();
            console.log('Keycloak availability check result:', isKeycloakAvailable);
            
            if (!isKeycloakAvailable) {
                console.error('❌ Keycloak server not available at:', KEYCLOAK_CONFIG.url);
                console.error('Please check:');
                console.error('1. Keycloak server is running');
                console.error('2. Server is accessible at', KEYCLOAK_CONFIG.url);
                console.error('3. No firewall or proxy blocking the connection');
                
                initializationInProgress = false;
                showKeycloakError();
                return;
            }
            
            console.log('✅ Keycloak server is available, proceeding with initialization...');
            
            // Reset keycloak instance
            keycloakInstance = null;
            authMode = 'keycloak';
            
            try {
                console.log('Creating Keycloak instance with config:', KEYCLOAK_CONFIG);
                
                // Validate configuration before creating instance
                if (!KEYCLOAK_CONFIG.url) {
                    throw new Error('Keycloak URL is missing in configuration');
                }
                if (!KEYCLOAK_CONFIG.realm) {
                    throw new Error('Keycloak realm is missing in configuration');
                }
                if (!KEYCLOAK_CONFIG.clientId) {
                    throw new Error('Keycloak clientId is missing in configuration');
                }
                
                console.log('Configuration validation passed, creating instance...');
                keycloakInstance = new Keycloak(KEYCLOAK_CONFIG);
                console.log('Keycloak instance created successfully:', keycloakInstance);
                
                // Clear any existing Keycloak state that might cause nonce issues
                console.log('Clearing any existing Keycloak state...');
                keycloakInstance.clearToken();
                
                // Clear any Keycloak-related localStorage/sessionStorage
                Object.keys(localStorage).forEach(key => {
                    if (key.includes('keycloak') || key.includes('kc-') || key.includes('auth')) {
                        console.log('Removing potentially conflicting storage key:', key);
                        localStorage.removeItem(key);
                    }
                });
                
                Object.keys(sessionStorage).forEach(key => {
                    if (key.includes('keycloak') || key.includes('kc-') || key.includes('auth')) {
                        console.log('Removing potentially conflicting session key:', key);
                        sessionStorage.removeItem(key);
                    }
                });
                
                console.log('Starting Keycloak initialization...');
                
                // Set a timeout for Keycloak initialization
                const initTimeout = setTimeout(() => {
                    console.error('Keycloak initialization timed out after 10 seconds');
                    initializationInProgress = false;
                    showKeycloakError();
                }, 10000);
                
                keycloakInstance.init({
                    onLoad: undefined, // Don't auto-login or check SSO
                    checkLoginIframe: false,
                    silentCheckSsoRedirectUri: undefined, // Disable silent check
                    enableLogging: true,
                    // Remove PKCE to avoid nonce issues
                    // pkceMethod: 'S256',
                    flow: 'standard', // Use standard flow
                    responseMode: 'query', // Use query mode to avoid fragment issues
                    scope: 'openid profile email'
                }).then(function(authenticated) {
                    clearTimeout(initTimeout);
                    console.log('✅ Keycloak init completed successfully!');
                    console.log('Authenticated:', authenticated);
                    console.log('Keycloak authenticated property:', keycloakInstance.authenticated);
                    console.log('Token present:', keycloakInstance.token ? 'YES' : 'NO');
                    console.log('Refresh token present:', keycloakInstance.refreshToken ? 'YES' : 'NO');
                    
                    if (authenticated && keycloakInstance.token) {
                        console.log('✅ User is authenticated with valid token');
                        
                        // Store tokens
                        localStorage.setItem('token', keycloakInstance.token);
                        if (keycloakInstance.refreshToken) {
                            localStorage.setItem('refreshToken', keycloakInstance.refreshToken);
                        }
                        
                        console.log('Showing main application...');
                        initializationInProgress = false;
                        initializationCompleted = true;
                        showMainApp();
                    } else {
                        console.log('ℹ️ User not authenticated, showing login form');
                        initializationInProgress = false;
                        initializationCompleted = true;
                        showLoginFallback();
                    }
                }).catch(function(error) {
                    clearTimeout(initTimeout);
                    console.error('Keycloak init promise rejected:', error);
                    console.error('Raw error object:', error);
                    console.error('Error type:', typeof error);
                    console.error('Error constructor:', error?.constructor?.name);
                    
                    // Try to extract any useful information
                    let errorInfo = 'No error information available';
                    if (error) {
                        if (typeof error === 'string') {
                            errorInfo = error;
                        } else if (error.message) {
                            errorInfo = error.message;
                        } else if (error.toString && typeof error.toString === 'function') {
                            try {
                                errorInfo = error.toString();
                            } catch (e) {
                                errorInfo = 'Error in toString()';
                            }
                        }
                    }
                    
                    console.error('Extracted error info:', errorInfo);
                    
                    // Specific handling for nonce/token issues
                    console.error('🔍 This appears to be a nonce/token validation issue.');
                    console.error('Common causes and solutions:');
                    console.error('1. ❌ Invalid/corrupted browser state - Try clearing browser data');
                    console.error('2. ❌ PKCE nonce validation failed - Disabled PKCE in this attempt');
                    console.error('3. ❌ Keycloak client configuration issue');
                    console.error('4. ❌ Browser security policies blocking token validation');
                    console.error('');
                    console.error('🛠️ Troubleshooting steps:');
                    console.error('1. Clear browser cache and cookies');
                    console.error('2. Check Keycloak client settings for "MindBridgeClient"');
                    console.error('3. Ensure client has "Standard Flow" enabled');
                    console.error('4. Check valid redirect URIs in Keycloak client config');
                    
                    // Check if this might be a CORS or network issue
                    if (errorInfo.includes('NetworkError') || errorInfo.includes('CORS') || errorInfo.includes('Failed to fetch')) {
                        console.error('This appears to be a network/CORS issue. Make sure:');
                        console.error('1. Keycloak server is running on', KEYCLOAK_CONFIG.url);
                        console.error('2. CORS is properly configured in Keycloak');
                        console.error('3. The realm "MindBridge" exists');
                        console.error('4. The client "MindBridgeClient" is configured');
                    }
                    
                    initializationInProgress = false;
                    showKeycloakError();
                });
            } catch (error) {
                console.error('Exception during Keycloak instance creation:', error);
                console.error('Raw exception object:', error);
                console.error('Exception type:', typeof error);
                
                // Check if it's a reference error (Keycloak not defined)
                if (error instanceof ReferenceError) {
                    console.error('ReferenceError detected - Keycloak library may not be loaded properly');
                } else if (error instanceof TypeError) {
                    console.error('TypeError detected - Check Keycloak constructor arguments');
                }
                
                initializationInProgress = false;
                showKeycloakError();
            }
        }
        
        async function checkKeycloakAvailability() {
            try {
                const response = await fetch(`${KEYCLOAK_CONFIG.url}/realms/${KEYCLOAK_CONFIG.realm}/.well-known/openid-configuration`, {
                    method: 'GET',
                    mode: 'cors'
                });
                return response.ok;
            } catch (error) {
                console.log('Keycloak health check failed:', error?.message || 'Unknown error');
                console.log('Full error details:', {
                    name: error?.name,
                    message: error?.message,
                    stack: error?.stack
                });
                return false;
            }
        }
        
        function showMainApp() {
            // Hide loading screen
            const authLoading = document.getElementById('authLoading');
            if (authLoading) {
                authLoading.style.display = 'none';
            }
            
            // Show main app
            const appContainer = document.querySelector('.app-container');
            if (appContainer) {
                appContainer.style.display = 'grid';
            }
            
            // Update user info from Keycloak token

            if (keycloakInstance && keycloakInstance.tokenParsed) {
                updateUserInfoFromKeycloak();
            }
            
            // Initialize layout and components only once
            if (!window.mainAppInitialized) {
                window.mainAppInitialized = true;
                setTimeout(() => {
                    if (typeof initWebSocket === 'function' && !connected) {
                        initWebSocket();
                    }
                    if (typeof updateSessionInfo === 'function') {
                        updateSessionInfo();
                        // Clear any existing interval first
                        if (window.sessionInfoInterval) {
                            clearInterval(window.sessionInfoInterval);
                        }
                        window.sessionInfoInterval = setInterval(updateSessionInfo, 1000);
                    }
                    // Initialize message input handlers
                    if (typeof initializeMessageInput === 'function') {
                        initializeMessageInput();
                    }
                    // Load chat history
                    if (typeof loadChatHistory === 'function') {
                        loadChatHistory();
                    }
                }, 100);
            }
        }
        
        // Layout is now handled by CSS flexbox - no manual adjustments needed
        
        function updateUserInfoFromKeycloak() {
            const userInfo = keycloakInstance.tokenParsed;
            const avatar = document.querySelector('.avatar');
            const userName = document.querySelector('.user-info div:nth-child(2) div:first-child');
            const userId = document.querySelector('.user-info div:nth-child(2) div:last-child');
            
            if (avatar && userName && userId) {
                avatar.textContent = (userInfo.given_name?.[0] || '') + (userInfo.family_name?.[0] || 'U');
                userName.textContent = userInfo.name || userInfo.preferred_username || 'User';
                userId.textContent = `Patient ID: #${userInfo.sub?.slice(-5) || '12345'}`;
            }
        }
        
        function showLoginFallback() {
            // Hide loading screen
            const authLoading = document.getElementById('authLoading');
            if (authLoading) {
                authLoading.style.display = 'none';
            }
            
            const appContainer = document.querySelector('.app-container');
            appContainer.innerHTML = `
                <div style="grid-column: 1 / -1; display: flex; align-items: center; justify-content: center; background: white; border-radius: 20px; padding: 40px;">
                    <div style="width: 100%; max-width: 400px; text-align: center;">
                        <h1 style="color: #4a90e2; margin-bottom: 10px; font-size: 2.5rem;">🧠 MindBridge</h1>
                        
                        
                        <div id="loginError" style="display: none; background: #fee; color: #c33; padding: 10px; border-radius: 5px; margin-bottom: 20px;"></div>
                        
                        <form id="loginForm" style="margin-bottom: 30px;">
                            <input type="text" id="username" placeholder="Username" required 
                                   style="width: 100%; padding: 15px; margin-bottom: 15px; border: 2px solid #e5e7eb; border-radius: 10px; font-size: 16px; box-sizing: border-box;" />
                            <input type="password" id="password" placeholder="Password" required 
                                   style="width: 100%; padding: 15px; margin-bottom: 20px; border: 2px solid #e5e7eb; border-radius: 10px; font-size: 16px; box-sizing: border-box;" />
                            <button type="submit" id="loginBtn" 
                                    style="width: 100%; padding: 15px; background: linear-gradient(45deg, #4a90e2, #357abd); color: white; border: none; border-radius: 10px; font-size: 16px; font-weight: 600; cursor: pointer; margin-bottom: 20px;">
                                Sign In
                            </button>
                        </form>
                        
                        <div style="border-top: 1px solid #e5e7eb; padding-top: 20px; margin-bottom: 20px;">
                            <p style="color: #666; margin-bottom: 15px; font-size: 14px;">OR</p>
                        </div>
                        
                        <button onclick="loginWithGoogle()" 
                                style="width: 100%; padding: 12px; background: #4285f4; color: white; border: none; border-radius: 10px; font-size: 14px; cursor: pointer; margin-bottom: 10px; display: flex; align-items: center; justify-content: center; gap: 10px; font-weight: 500;">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none">
                                <path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" fill="white"/>
                                <path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" fill="white"/>
                                <path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" fill="white"/>
                                <path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" fill="white"/>
                            </svg>
                            Continue with Google
                        </button>
                        
                        <button onclick="loginWithGitHub()" 
                                style="width: 100%; padding: 12px; background: #24292e; color: white; border: none; border-radius: 10px; font-size: 14px; cursor: pointer; margin-bottom: 20px; display: flex; align-items: center; justify-content: center; gap: 10px; font-weight: 500;">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599-.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492 .997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                            </svg>
                            Continue with GitHub
                        </button>

                    </div>
                </div>
            `;
            appContainer.style.display = 'flex';
            appContainer.style.alignItems = 'center';
            appContainer.style.justifyContent = 'center';
            
            
            // Add login handlers
            document.getElementById('loginForm').addEventListener('submit', handleDirectLogin);
        }
        
        async function handleDirectLogin(e) {
            e.preventDefault();
            
            const username = document.getElementById('username').value;
            const password = document.getElementById('password').value;
            const loginBtn = document.getElementById('loginBtn');
            const loginError = document.getElementById('loginError');
            
            loginBtn.textContent = 'Signing in...';
            loginBtn.disabled = true;
            loginError.style.display = 'none';
            
            try {
                // Keycloak direct login using Resource Owner Password Credentials Grant
                const formData = new URLSearchParams();
                formData.append('grant_type', 'password');
                formData.append('client_id', KEYCLOAK_CONFIG.clientId);
                formData.append('username', username);
                formData.append('password', password);
                
                const response = await fetch(`${KEYCLOAK_CONFIG.url}/realms/${KEYCLOAK_CONFIG.realm}/protocol/openid-connect/token`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: formData.toString(),
                });
                
                if (response.ok) {
                    const tokenResponse = await response.json();
                    
                    localStorage.setItem('token', tokenResponse.access_token);
                    localStorage.setItem('refreshToken', tokenResponse.refresh_token);
                    
                    location.reload();
                } else {
                    const error = await response.json();
                    throw new Error(error.error_description || error.error || 'Login failed');
                }
            } catch (error) {
                loginError.textContent = error.message || 'Login failed';
                loginError.style.display = 'block';
                loginBtn.textContent = 'Sign In';
                loginBtn.disabled = false;
            }
        }
        
        function showKeycloakError() {
            // Hide loading screen
            const authLoading = document.getElementById('authLoading');
            if (authLoading) {
                authLoading.style.display = 'none';
            }
            
            const appContainer = document.querySelector('.app-container');
            appContainer.innerHTML = `
                <div style="grid-column: 1 / -1; display: flex; align-items: center; justify-content: center; background: white; border-radius: 20px; padding: 40px;">
                    <div style="width: 100%; max-width: 400px; text-align: center;">
                        <h1 style="color: #ef4444; margin-bottom: 10px; font-size: 2.5rem;">🚫 Authentication Error</h1>
                        <p style="color: #666; margin-bottom: 30px; font-size: 1.1rem;">Cannot connect to Keycloak server</p>
                        
                        <div style="background: #fee; color: #c33; padding: 15px; border-radius: 5px; margin-bottom: 20px; text-align: left;">
                            <strong>Keycloak server not found:</strong><br>
                            ${KEYCLOAK_CONFIG.url}<br><br>
                            Please ensure:
                            <ul style="margin: 10px 0; padding-left: 20px;">
                                <li>Keycloak is running</li>
                                <li>Realm '${KEYCLOAK_CONFIG.realm}' exists</li>
                                <li>Client '${KEYCLOAK_CONFIG.clientId}' is configured</li>
                            </ul>
                        </div>
                        
                        
                        <button onclick="location.reload()" 
                                style="width: 100%; padding: 12px; background: #fff3cd; color: #856404; border: 2px solid #ffeaa7; border-radius: 10px; font-size: 14px; cursor: pointer;">
                            🔄 Retry Connection
                        </button>
                    </div>
                </div>
            `;
            appContainer.style.display = 'flex';
        }
        
        
        function getRedirectUri() {
            // Handle different environments (IDE server, local server, etc.)
            const currentUrl = window.location.href;
            if (currentUrl.includes('localhost:63342')) {
                // IntelliJ/WebStorm IDE server - use the actual file URL
                return currentUrl.split('?')[0]; // Remove query parameters
            }
            // For other local servers or direct file access
            return window.location.origin + window.location.pathname;
        }
        
        function loginWithGoogle() {
            const redirectUri = getRedirectUri();
            const googleLoginUrl = `${KEYCLOAK_CONFIG.url}/realms/${KEYCLOAK_CONFIG.realm}/protocol/openid-connect/auth?client_id=${KEYCLOAK_CONFIG.clientId}&redirect_uri=${encodeURIComponent(redirectUri)}&response_type=code&scope=openid email profile&kc_idp_hint=google`;
            console.log('Google login redirect URI:', redirectUri);
            window.location.href = googleLoginUrl;
        }
        
        function loginWithGitHub() {
            const redirectUri = getRedirectUri();
            const githubLoginUrl = `${KEYCLOAK_CONFIG.url}/realms/${KEYCLOAK_CONFIG.realm}/protocol/openid-connect/auth?client_id=${KEYCLOAK_CONFIG.clientId}&redirect_uri=${encodeURIComponent(redirectUri)}&response_type=code&scope=openid email profile&kc_idp_hint=github`;
            console.log('GitHub login redirect URI:', redirectUri);
            window.location.href = githubLoginUrl;
        }
        
        function decodeJWT(token) {
            try {
                const base64Url = token.split('.')[1];
                const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
                const jsonPayload = decodeURIComponent(
                    atob(base64)
                        .split('')
                        .map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))
                        .join('')
                );
                return JSON.parse(jsonPayload);
            } catch (error) {
                console.error('Failed to decode JWT:', error);
                return {};
            }
        }
        
        // Global logout function for the logout button
        async function keycloakLogout() {
            console.log('🚪 Starting logout process...');
            
            // Prevent multiple logout attempts
            if (window.logoutInProgress) {
                console.log('Logout already in progress, skipping...');
                return;
            }
            window.logoutInProgress = true;
            
            // 1. Disconnect WebSocket if connected
            if (typeof stompClient !== 'undefined' && stompClient && stompClient.connected) {
                console.log('📡 Disconnecting WebSocket...');
                try {
                    stompClient.deactivate();
                    console.log('✅ WebSocket disconnected successfully');
                } catch (error) {
                    console.warn('⚠️ Error disconnecting WebSocket:', error);
                }
            }
            
            // 2. Get current token and refresh token before clearing storage
            const currentToken = keycloakInstance?.token || localStorage.getItem('token');
            const currentRefreshToken = keycloakInstance?.refreshToken || localStorage.getItem('refreshToken');
            
            // 3. Handle Keycloak server logout to actually end the session
            if (currentToken) {
                console.log('🔐 Ending Keycloak session on server...');
                
                try {
                    // First, call the logout endpoint to end the server session
                    const logoutEndpoint = `${KEYCLOAK_CONFIG.url}/realms/${KEYCLOAK_CONFIG.realm}/protocol/openid-connect/logout`;
                    
                    const formData = new URLSearchParams();
                    formData.append('client_id', KEYCLOAK_CONFIG.clientId);
                    if (currentRefreshToken) {
                        formData.append('refresh_token', currentRefreshToken);
                    }
                    
                    const response = await fetch(logoutEndpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'Authorization': `Bearer ${currentToken}`
                        },
                        body: formData.toString()
                    });
                    
                    if (response.ok) {
                        console.log('✅ Successfully ended Keycloak session');
                    } else {
                        console.warn('⚠️ Keycloak logout returned status:', response.status);
                    }
                    
                } catch (fetchError) {
                    console.warn('⚠️ Error calling Keycloak logout endpoint:', fetchError);
                }
            }
            
            // 4. Clear all local data
            console.log('🧹 Clearing all local data...');
            localStorage.clear();
            sessionStorage.clear();
            
            // 5. Clear Keycloak instance if it exists
            if (keycloakInstance) {
                try {
                    if (keycloakInstance.clearToken) {
                        keycloakInstance.clearToken();
                    }
                    keycloakInstance.authenticated = false;
                    keycloakInstance.token = null;
                    keycloakInstance.refreshToken = null;
                } catch (error) {
                    console.warn('Error clearing Keycloak instance:', error);
                }
            }
            
            // 6. Reset application state
            if (typeof currentUser !== 'undefined') {
                currentUser = null;
            }
            resetInitializationState();
            
            // 7. Navigate to clean URL with logout flag and clear history
            console.log('💻 Redirecting to clean logout URL...');
            const cleanUrl = window.location.origin + window.location.pathname + '?logout=true';
            
            // Clear browser history to prevent back navigation to authenticated pages
            // This replaces the current history entry rather than adding a new one
            window.history.replaceState(null, null, cleanUrl);
            
            // Force page reload to show login page
            window.location.reload();
        }
    </script>

    <script>
        // WebSocket connection (authentication variables are in the first script block)
        let stompClient = null;
        let connected = false;
        let connectionAttempts = 0;
        const maxRetries = 5;
        
        // Session tracking
        let sessionStartTime = Date.now();
        let messageCount = 0;
        let currentRole = 'CBT Therapist';
        let crisisMode = false;
        let lastMessageTime = null; // Track last message timestamp for gap detection

        // Agent roles and responses
        const agentRoles = {
            'CBT Therapist': {
                description: 'Helping you restructure negative thought patterns using evidence-based cognitive behavioral techniques.'
            },
            'Mindfulness Coach': {
                description: 'Guiding you through mindfulness practices and helping you stay present in the moment.'
            },
            'Crisis Counselor': {
                description: 'Providing immediate support and safety planning during crisis situations.'
            }
        };

        // Crisis detection keywords
        const crisisKeywords = ['hurt myself', 'end it all', 'suicide', 'kill myself', 'want to die', 'hopeless', 'can\'t go on'];
        
        // Timestamp utilities - optimized for performance
        const TIME_GAP_THRESHOLD = 5 * 60 * 1000; // 5 minutes in milliseconds
        const DAY_MS = 24 * 60 * 60 * 1000; // 1 day in milliseconds
        
        // Cache for formatted timestamps to avoid repeated calculations
        const timestampCache = new Map();
        
        function formatTimestampHeader(timestamp) {
            // Use cache for performance
            const cacheKey = Math.floor(timestamp / 60000); // Cache by minute
            if (timestampCache.has(cacheKey)) {
                return timestampCache.get(cacheKey);
            }
            
            const now = new Date();
            const messageDate = new Date(timestamp);
            const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const yesterdayStart = new Date(todayStart.getTime() - DAY_MS);
            const weekAgo = new Date(todayStart.getTime() - 7 * DAY_MS);
            
            let formatted;
            
            if (messageDate >= todayStart) {
                // Today - just time
                formatted = messageDate.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
            } else if (messageDate >= yesterdayStart) {
                // Yesterday
                formatted = 'Yesterday ' + messageDate.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
            } else if (messageDate >= weekAgo) {
                // This week - day name + time
                formatted = messageDate.toLocaleDateString([], { weekday: 'long' }) + ' ' + 
                           messageDate.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
            } else {
                // Older - date + time
                formatted = messageDate.toLocaleDateString([], { month: 'short', day: 'numeric' }) + ', ' +
                           messageDate.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
            }
            
            // Cache result
            timestampCache.set(cacheKey, formatted);
            
            // Limit cache size for memory efficiency
            if (timestampCache.size > 1000) {
                const firstKey = timestampCache.keys().next().value;
                timestampCache.delete(firstKey);
            }
            
            return formatted;
        }
        
        function shouldShowTimestamp(currentTime, previousTime) {
            if (!previousTime) return true; // First message
            
            const timeDiff = currentTime - previousTime;
            if (timeDiff >= TIME_GAP_THRESHOLD) return true; // 5+ minute gap
            
            // Check if date changed (more precise than simple day comparison)
            const currentDate = new Date(currentTime);
            const previousDate = new Date(previousTime);
            
            return (currentDate.getDate() !== previousDate.getDate() || 
                    currentDate.getMonth() !== previousDate.getMonth() || 
                    currentDate.getFullYear() !== previousDate.getFullYear());
        }
        
        function createTimestampHeader(timestamp) {
            const headerDiv = document.createElement('div');
            headerDiv.className = 'timestamp-header';
            headerDiv.textContent = formatTimestampHeader(timestamp);
            return headerDiv;
        }

        // Note: Keycloak authentication is handled in the first script block above

        // Initialize WebSocket connection with STOMP
        function initWebSocket() {
            try {
                stompClient = new StompJs.Client({
                    brokerURL: API_CONFIG.websocketUrl,
                    connectHeaders: getAuthHeaders(),
                    debug: function (str) {
                        console.log('STOMP: ' + str);
                    },
                    reconnectDelay: 5000,
                    heartbeatIncoming: 4000,
                    heartbeatOutgoing: 4000,
                });
                stompClient.onConnect = function (frame) {
                    console.log('STOMP Connected: ' + frame);
                    connected = true;
                    updateConnectionStatus(true);
                    connectionAttempts = 0;
                    
                    // Subscribe to user-specific queue
                    stompClient.subscribe('/user/queue/chat', function (message) {
                        console.log("Raw WebSocket message received:", message.body);
                        try {
                            const chatMessage = JSON.parse(message.body);
                            console.log("Parsed WebSocket message:", chatMessage);
                            handleWebSocketMessage(chatMessage);
                        } catch (error) {
                            console.error('Error parsing WebSocket message:', error);
                            console.error('Raw message body:', message.body);
                            // Try to handle as plain text
                            handleWebSocketMessage({ content: message.body, type: 'chat' });
                        }
                    });
                };

                stompClient.onStompError = function (frame) {
                    console.error('STOMP error: ' + frame.headers['message']);
                    console.error('Details: ' + frame.body);
                    connected = false;
                    updateConnectionStatus(false);
                };

                stompClient.onWebSocketClose = function (event) {
                    console.log('WebSocket connection closed');
                    connected = false;
                    updateConnectionStatus(false);
                    
                    // Attempt to reconnect
                    if (connectionAttempts < maxRetries) {
                        connectionAttempts++;
                        console.log(`Reconnection attempt ${connectionAttempts}/${maxRetries}`);
                        setTimeout(() => {
                            stompClient.activate();
                        }, 2000 * connectionAttempts);
                    }
                };

                stompClient.activate();

            } catch (error) {
                console.error('Failed to create STOMP connection:', error);
                updateConnectionStatus(false);
            }
        }

        // Removed old sync getAuthHeaders - now using async version below

        function updateConnectionStatus(connected) {
            const statusElement = document.getElementById('connectionStatus');
            const dotElement = document.getElementById('statusDot');
            const textElement = document.getElementById('connectionText');
            
            if (connected) {
                statusElement.classList.remove('disconnected');
                dotElement.classList.remove('disconnected');
                textElement.textContent = 'WebSocket Connected';
            } else {
                statusElement.classList.add('disconnected');
                dotElement.classList.add('disconnected');
                textElement.textContent = 'Offline Mode';
            }
        }

        function handleWebSocketMessage(message) {
            console.log('Handling WebSocket message:', message);
            
            // Handle incoming WebSocket messages
            if (message.type === 'chat' || message.content) {
                // Display the message content
                const content = message.content || message.message || JSON.stringify(message);
                const agentRole = message.agentRole || message.agentName || currentRole;
                const messageTime = message.timestamp ? new Date(message.timestamp).getTime() : Date.now();
                addMessage(content, false, agentRole, messageTime);
            } else if (message.type === 'role_switch') {
                switchAgentRole(message.role);
            } else if (message.type === 'crisis_alert') {
                activateCrisisMode();
            } else {
                // Fallback: treat any message as a chat message
                console.log('Unknown message format, treating as chat:', message);
                const content = message.content || message.message || message.text || JSON.stringify(message);
                addMessage(content, false, currentRole, Date.now());
            }
        }

        function sendWebSocketMessage(content) {
            if (stompClient && connected) {
                const message = {
                    content: content,
                    timestamp: new Date(),
                    type: 'user'
                };
                
                stompClient.publish({
                    destination: '/app/agent/conversation',
                    body: JSON.stringify(message)
                });
                return true;
            }
            return false;
        }

        function updateSessionInfo() {
            const elapsed = Date.now() - sessionStartTime;
            const minutes = Math.floor(elapsed / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);
            document.getElementById('sessionTime').textContent =
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

            document.getElementById('messageCount').textContent = messageCount;
        }

        function detectCrisis(message) {
            const lowerMessage = message.toLowerCase();
            return crisisKeywords.some(keyword => lowerMessage.includes(keyword));
        }

        function switchAgentRole(newRole) {
            if (currentRole === newRole) return;

            currentRole = newRole;
            const roleInfo = agentRoles[newRole];

            document.getElementById('currentRole').textContent = newRole;
            document.getElementById('roleDescription').textContent = roleInfo.description;

            // Visual feedback for role switch
            const agentStatus = document.querySelector('.agent-status');
            agentStatus.style.transform = 'scale(1.05)';
            setTimeout(() => {
                agentStatus.style.transform = 'scale(1)';
            }, 200);
        }

        function activateCrisisMode() {
            crisisMode = true;
            switchAgentRole('Crisis Counselor');

            // Show crisis alert
            const crisisAlert = document.getElementById('crisisAlert');
            crisisAlert.classList.add('active');

            // Update crisis monitor
            const crisisMonitor = document.getElementById('crisisMonitor');
            crisisMonitor.classList.add('alert');
            crisisMonitor.innerHTML = `
                <div class="crisis-status">🚨 Crisis Detected</div>
                <div style="font-size: 12px;">Emergency protocols active</div>
            `;

            setTimeout(() => {
                crisisAlert.classList.remove('active');
            }, 5000);
        }

        function formatMarkdown(text) {
            try {
                // Use the marked library for proper markdown parsing
                if (typeof marked !== 'undefined') {
                    // Configure marked for inline parsing
                    marked.setOptions({
                        breaks: true,
                        gfm: true
                    });
                    return marked.parse(text);
                } else {
                    // Fallback to simple formatting if marked isn't available
                    return simpleMarkdownFormat(text);
                }
            } catch (error) {
                console.error('Error formatting markdown:', error);
                return simpleMarkdownFormat(text);
            }
        }

        function simpleMarkdownFormat(text) {
            // Simple fallback formatting
            let formatted = text;
            
            // Convert **bold**
            formatted = formatted.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            
            // Convert *italic*
            formatted = formatted.replace(/\*([^*\n]+?)\*/g, '<em>$1</em>');
            
            // Convert bullet points
            formatted = formatted.replace(/^\* (.+)$/gm, '• $1');
            
            // Convert line breaks
            formatted = formatted.replace(/\n/g, '<br>');
            
            // Wrap in paragraph if needed
            if (!formatted.includes('<p>') && !formatted.includes('<ul>')) {
                formatted = '<p>' + formatted + '</p>';
            }
            
            return formatted;
        }

        function addMessage(content, isUser = false, role = null, messageTime = null) {
            const messagesContainer = document.getElementById('messages');
            if (!messagesContainer) return;
            
            const currentTime = messageTime || Date.now();
            
            // Check if we need to show a timestamp header
            if (shouldShowTimestamp(currentTime, lastMessageTime)) {
                const timestampHeader = createTimestampHeader(currentTime);
                messagesContainer.appendChild(timestampHeader);
            }
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isUser ? 'user' : 'agent'}`;
            messageDiv.setAttribute('data-timestamp', currentTime); // Store for potential future use

            // Format content with markdown support
            const formattedContent = isUser ? content : formatMarkdown(content);

            messageDiv.innerHTML = `
                <div class="message-content">
                    ${formattedContent}
                </div>
            `;

            messagesContainer.appendChild(messageDiv);
            
            // Update last message time for gap detection
            lastMessageTime = currentTime;
            
            // Optimized scroll - use requestAnimationFrame for better performance
            requestAnimationFrame(() => {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            });

            if (isUser) {
                messageCount++;
                if (typeof updateSessionInfo === 'function') {
                    updateSessionInfo();
                }
            }
        }

        function showTypingIndicator() {
            document.getElementById('typingIndicator').classList.add('active');
            const messagesContainer = document.getElementById('messages');
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function hideTypingIndicator() {
            document.getElementById('typingIndicator').classList.remove('active');
        }


        function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();

            if (!message) return;

            // Add user message with current timestamp
            const userMessageTime = Date.now();
            addMessage(message, true, null, userMessageTime);
            
            // Clear input and reset to auto height
            input.value = '';
            input.style.height = 'auto';
            updateSendButton(); // Update send button state
            input.focus(); // Keep focus for next message

            // Try to send via WebSocket first
            const sentViaWS = sendWebSocketMessage(message);

            if (!sentViaWS) {
                // Show connection error message instead of automatic response
                const errorMessage = "Connection unavailable. Please check your internet connection or try again later.";
                addMessage(errorMessage, false, 'System', userMessageTime + 500);
            }
        }

        // Event listeners (initialized when main app is shown)
        function initializeMessageInput() {
            const messageInput = document.getElementById('messageInput');
            const sendButton = document.getElementById('sendButton');
            const textInputContainer = document.querySelector('.text-input-container');
            
            if (!messageInput || !sendButton) {
                console.log('Message input elements not found, retrying...');
                setTimeout(initializeMessageInput, 500);
                return;
            }
            
            // Remove existing listeners to prevent duplicates
            messageInput.removeEventListener('keydown', handleKeyPress);
            messageInput.removeEventListener('input', handleInputChange);
            sendButton.removeEventListener('click', handleSendClick);
            if (textInputContainer) {
                textInputContainer.removeEventListener('click', handleContainerClick);
            }
            
            // Add event listeners
            messageInput.addEventListener('keydown', handleKeyPress);
            messageInput.addEventListener('input', handleInputChange);
            sendButton.addEventListener('click', handleSendClick);
            if (textInputContainer) {
                textInputContainer.addEventListener('click', handleContainerClick);
            }
            
            // Initialize send button state
            updateSendButton();
            
            console.log('iMessage input initialized successfully');
        }
        
        function handleKeyPress(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                if (document.getElementById('sendButton').classList.contains('active')) {
                    sendMessage();
                }
            }
        }
        
        function handleInputChange(e) {
            autoExpand(e.target);
            updateSendButton();
        }
        
        function handleSendClick() {
            const sendButton = document.getElementById('sendButton');
            if (sendButton.classList.contains('active')) {
                sendMessage();
            }
        }
        
        function handleContainerClick() {
            document.getElementById('messageInput').focus();
        }
        
        function autoExpand(textarea) {
            textarea.style.height = 'auto';
            const scrollHeight = textarea.scrollHeight;
            const maxHeight = 120; // max-height in CSS
            
            if (scrollHeight <= maxHeight) {
                textarea.style.height = scrollHeight + 'px';
            } else {
                textarea.style.height = maxHeight + 'px';
            }
        }
        
        function updateSendButton() {
            const messageInput = document.getElementById('messageInput');
            const sendButton = document.getElementById('sendButton');
            const hasText = messageInput.value.trim().length > 0;
            
            if (hasText) {
                sendButton.classList.add('active');
            } else {
                sendButton.classList.remove('active');
            }
        }

        // Legacy logout function (keeping for compatibility)
        function logout() {
            keycloakLogout();
        }

        // Note: DOMContentLoaded listener is already defined in the Keycloak auth section above
        
        // Reactive token refresh: Only refresh when token actually expires
        async function refreshTokenAfterExpiry() {
            console.log('Access token expired, attempting refresh...');
            
            if (keycloakInstance && keycloakInstance.authenticated) {
                try {
                    // Force refresh using Keycloak
                    const refreshed = await keycloakInstance.updateToken(-1); // Force refresh
                    if (refreshed) {
                        localStorage.setItem('token', keycloakInstance.token);
                        if (keycloakInstance.refreshToken) {
                            localStorage.setItem('refreshToken', keycloakInstance.refreshToken);
                        }
                        console.log('✅ Token refreshed successfully after expiry');
                        return keycloakInstance.token;
                    }
                } catch (error) {
                    console.error('❌ Refresh token also expired or invalid:', error);
                    console.log('Forcing re-login...');
                    keycloakLogout();
                    throw new Error('Refresh failed - user needs to re-login');
                }
            } else {
                // Manual refresh token exchange for non-Keycloak flows
                const refreshToken = localStorage.getItem('refreshToken');
                if (refreshToken) {
                    try {
                        const response = await fetch(`${KEYCLOAK_CONFIG.url}/realms/${KEYCLOAK_CONFIG.realm}/protocol/openid-connect/token`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/x-www-form-urlencoded',
                            },
                            body: new URLSearchParams({
                                'grant_type': 'refresh_token',
                                'client_id': KEYCLOAK_CONFIG.clientId,
                                'refresh_token': refreshToken
                            })
                        });
                        
                        if (response.ok) {
                            const tokenData = await response.json();
                            localStorage.setItem('token', tokenData.access_token);
                            localStorage.setItem('refreshToken', tokenData.refresh_token);
                            console.log('✅ Token refreshed successfully using refresh token');
                            return tokenData.access_token;
                        } else {
                            throw new Error('Refresh token request failed');
                        }
                    } catch (error) {
                        console.error('❌ Refresh token exchange failed:', error);
                        localStorage.removeItem('token');
                        localStorage.removeItem('refreshToken');
                        console.log('Forcing re-login...');
                        window.location.reload(); // Force re-authentication
                        throw error;
                    }
                } else {
                    console.log('No refresh token available, forcing re-login...');
                    window.location.reload();
                    throw new Error('No refresh token available');
                }
            }
        }

        // API call wrapper with automatic token refresh on 401
        async function makeAuthenticatedRequest(url, options = {}) {
            const token = keycloakInstance?.token || localStorage.getItem('token');
            
            // Add auth header
            const headers = {
                ...options.headers,
                'Authorization': `Bearer ${token}`
            };
            
            try {
                const response = await fetch(url, { ...options, headers });
                
                // If token expired (401), try to refresh and retry
                if (response.status === 401) {
                    console.log('Received 401 - token expired, attempting refresh...');
                    const newToken = await refreshTokenAfterExpiry();
                    
                    // Retry the original request with new token
                    const retryHeaders = {
                        ...options.headers,
                        'Authorization': `Bearer ${newToken}`
                    };
                    
                    console.log('Retrying original request with new token...');
                    return fetch(url, { ...options, headers: retryHeaders });
                }
                
                return response;
            } catch (error) {
                console.error('Authenticated request failed:', error);
                throw error;
            }
        }

        // Simple auth headers for WebSocket (no auto-refresh needed for initial connection)
        function getAuthHeaders() {
            const headers = {};
            const currentToken = keycloakInstance?.token || localStorage.getItem('token');
            if (currentToken) {
                headers['Authorization'] = `Bearer ${currentToken}`;
                headers['X-Auth-Token'] = currentToken;
            }
            return headers;
        }

        // Chat history API functions
        async function fetchChatHistory() {
            try {
                console.log('Fetching chat history...');
                const response = await makeAuthenticatedRequest(`${API_CONFIG.backendUrl}/v1/agent/chat/history`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                if (response.ok) {
                    const historyData = await response.json();
                    console.log('Chat history fetched successfully:', historyData);
                    return historyData;
                } else {
                    throw new Error(`Failed to fetch chat history: ${response.status} ${response.statusText}`);
                }
            } catch (error) {
                console.error('Error fetching chat history:', error);
                throw error;
            }
        }

        async function loadChatHistory() {
            try {
                const historyData = await fetchChatHistory();
                
                if (historyData && historyData.length > 0) {
                    displayChatHistory(historyData);
                } else {
                    console.log('No chat history found');
                }
            } catch (error) {
                console.error('Failed to load chat history:', error);
                showHistoryError('Failed to load chat history');
            }
        }

        function displayChatHistory(historyData) {
            const messagesContainer = document.getElementById('messages');
            if (!messagesContainer) return;

            // Clear existing messages and reset timestamp tracking
            messagesContainer.innerHTML = '';
            lastMessageTime = null;

            // Sort history by timestamp for proper ordering
            const sortedHistory = historyData.sort((a, b) => 
                new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
            );

            // Use document fragment for better performance when adding many elements
            const fragment = document.createDocumentFragment();

            // Add history messages with smart timestamps
            sortedHistory.forEach(historyMessage => {
                const isUser = historyMessage.type === 'user';
                const content = historyMessage.content;
                const messageTime = new Date(historyMessage.timestamp).getTime();
                
                // Check if we need a timestamp header
                if (shouldShowTimestamp(messageTime, lastMessageTime)) {
                    const timestampHeader = createTimestampHeader(messageTime);
                    fragment.appendChild(timestampHeader);
                }
                
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${isUser ? 'user' : 'agent'}`;
                messageDiv.setAttribute('data-history', 'true');
                messageDiv.setAttribute('data-timestamp', messageTime);

                // Format content with markdown support for agent messages
                const formattedContent = isUser ? content : formatMarkdown(content);

                messageDiv.innerHTML = `
                    <div class="message-content">
                        ${formattedContent}
                    </div>
                `;

                fragment.appendChild(messageDiv);
                lastMessageTime = messageTime;
            });

            // Add all elements at once for better performance
            messagesContainer.appendChild(fragment);

            // Add a divider between history and new messages
            const divider = document.createElement('div');
            divider.className = 'history-divider';
            divider.innerHTML = `
                <div style="text-align: center; padding: 20px; color: #666; font-size: 14px; border-bottom: 1px solid #e5e7eb; margin: 10px 0;">
                    <span style="background: #fafafa; padding: 0 15px;">Previous conversation loaded</span>
                </div>
            `;
            messagesContainer.appendChild(divider);

            // Optimized scroll
            requestAnimationFrame(() => {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            });

            console.log(`Loaded ${historyData.length} messages from chat history`);
        }

        function showHistoryError(errorMessage) {
            const messagesContainer = document.getElementById('messages');
            if (!messagesContainer) return;

            const errorDiv = document.createElement('div');
            errorDiv.className = 'message system';
            errorDiv.innerHTML = `
                <div class="message-content" style="background: #fee; color: #c33; font-size: 12px; opacity: 0.8;">
                    ⚠️ ${errorMessage}
                </div>
            `;

            if (messagesContainer.children.length > 0) {
                messagesContainer.insertBefore(errorDiv, messagesContainer.children[0]);
            } else {
                messagesContainer.appendChild(errorDiv);
            }
        }
    </script>
</body>
</html>