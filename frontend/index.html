<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MindBridge AI - Therapeutic Platform</title>
    <link rel="icon" href="favicon.png" type="image/png" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .app-container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 1200px;
            height: 90vh;
            display: none; /* Hide by default until authentication is verified */
            grid-template-columns: 300px 1fr;
            overflow: hidden;
            position: relative;
        }

        .sidebar {
            background: linear-gradient(180deg, #4a90e2 0%, #357abd 100%);
            color: white;
            padding: 30px;
            display: flex;
            flex-direction: column;
            gap: 25px;
        }

        /* Navigation styles */
        .nav-menu {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 20px 0;
        }

        .nav-item {
            padding: 15px 20px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 16px;
            font-weight: 500;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid transparent;
        }

        .nav-item:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateX(5px);
        }

        .nav-item.active {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .nav-icon {
            font-size: 20px;
            width: 24px;
            text-align: center;
        }

        /* View management */
        .view {
            display: none;
            height: 100%;
            overflow: hidden;
        }

        .view.active {
            display: flex;
            flex-direction: column;
        }

        /* Mood tracking styles */
        .mood-tag {
            background: #f3f4f6;
            color: #374151;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid transparent;
            display: inline-block;
        }

        .mood-tag:hover {
            background: #e5e7eb;
            transform: translateY(-1px);
        }

        .mood-tag.selected {
            background: #dbeafe;
            color: #1d4ed8;
            border-color: #3b82f6;
        }

        /* Mood slider customization */
        #moodSlider {
            -webkit-appearance: none;
            appearance: none;
        }

        #moodSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #4a90e2;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        #moodSlider::-moz-range-thumb {
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #4a90e2;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            padding: 20px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .agent-status {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .agent-role {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .role-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #4ade80;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .agent-description {
            font-size: 14px;
            opacity: 0.9;
            line-height: 1.4;
        }

        .session-info {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
        }

        .session-info h3 {
            margin-bottom: 15px;
            font-size: 16px;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .crisis-monitor {
            background: rgba(34, 197, 94, 0.2);
            border: 2px solid #22c55e;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
        }

        .crisis-monitor.alert {
            background: rgba(239, 68, 68, 0.2);
            border-color: #ef4444;
            animation: alertPulse 1s infinite;
        }

        @keyframes alertPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .crisis-status {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .main-content {
            display: flex;
            flex-direction: column;
            background: #fafafa;
            border-bottom-right-radius: 20px;
            overflow: hidden;
        }

        .header {
            background: white;
            padding: 20px 30px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }


        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }

        .messages {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-height: 0;
        }

        .message {
            display: flex;
            animation: messageSlide 0.3s ease-out;
            margin-bottom: 2px;
            justify-content: flex-start;
        }
        
        .message + .message {
            margin-top: 2px;
        }
        
        .message.user + .message.user .message-content {
            border-radius: 18px;
            border-bottom-right-radius: 8px;
        }
        
        .message.agent + .message.agent .message-content {
            border-radius: 18px;
            border-bottom-left-radius: 8px;
        }
        
        .message.user:first-child .message-content,
        .message.user:not(.user) + .message.user .message-content,
        .timestamp-header + .message.user .message-content {
            border-top-right-radius: 18px;
        }
        
        .message.agent:first-child .message-content,
        .message.agent:not(.agent) + .message.agent .message-content,
        .timestamp-header + .message.agent .message-content {
            border-top-left-radius: 18px;
        }
        
        .message.user:last-child .message-content,
        .message.user + .message:not(.user) .message-content {
            border-bottom-right-radius: 8px;
        }
        
        .message.agent:last-child .message-content,
        .message.agent + .message:not(.agent) .message-content {
            border-bottom-left-radius: 8px;
        }
        
        .timestamp-header {
            text-align: center;
            color: #8E8E93;
            font-size: 13px;
            font-weight: 400;
            margin: 20px 0 15px 0;
            pointer-events: none;
            user-select: none;
        }

        @keyframes messageSlide {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.user {
            justify-content: flex-end;
        }


        .message-content {
            max-width: 70%;
            padding: 12px 18px;
            border-radius: 25px;
            line-height: 1.4;
            position: relative;
            font-size: 16px;
            word-wrap: break-word;
            overflow-wrap: break-word;
            overflow: hidden;
        }

        /* Fix markdown content overflow */
        .message-content ul, .message-content ol {
            margin: 0;
            padding-left: 20px;
            max-width: 100%;
            overflow-wrap: break-word;
        }

        .message-content li {
            margin: 4px 0;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .message-content p {
            margin: 0 0 8px 0;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .message-content p:last-child {
            margin-bottom: 0;
        }

        .message-content strong, .message-content em {
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .message.user .message-content {
            background: #007AFF;
            color: white;
            border-bottom-right-radius: 8px;
        }

        .message.agent .message-content {
            background: #E5E5EA;
            color: #000000;
            border-bottom-left-radius: 8px;
        }



        .typing-indicator {
            display: none;
            align-items: center;
            gap: 15px;
            padding: 20px 30px;
        }

        .typing-indicator.active {
            display: flex;
        }

        .typing-dots {
            display: flex;
            gap: 4px;
        }

        .typing-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #9ca3af;
            animation: typing 1.4s infinite;
        }

        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
                opacity: 0.4;
            }
            30% {
                transform: translateY(-10px);
                opacity: 1;
            }
        }

        .input-container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-top: 1px solid rgba(255, 255, 255, 0.3);
            padding: 15px;
            display: flex;
            align-items: flex-end;
            gap: 12px;
            flex-shrink: 0;
            border-bottom-right-radius: 20px;
            min-height: 64px;
        }

        .input-wrapper {
            flex: 1;
            display: flex;
            align-items: flex-end;
            gap: 12px;
            min-height: 44px;
        }

        .text-input-container {
            flex: 1;
            background: #F2F2F7;
            border-radius: 20px;
            padding: 8px 16px;
            min-height: 36px;
            display: flex;
            align-items: center;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .text-input-container:focus-within {
            background: #FFFFFF;
            border-color: #007AFF;
            box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.1);
        }

        .message-input {
            width: 100%;
            border: none;
            outline: none;
            background: transparent;
            font-size: 16px;
            line-height: 20px;
            resize: none;
            min-height: 20px;
            max-height: 120px;
            overflow-y: auto;
            font-family: inherit;
            color: #000;
        }

        .message-input::placeholder {
            color: #8E8E93;
        }

        .send-button {
            width: 32px;
            height: 32px;
            border: none;
            background: #007AFF;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            flex-shrink: 0;
            margin-bottom: 6px;
            opacity: 0.5;
            transform: scale(0.8);
        }

        .send-button.active {
            opacity: 1;
            transform: scale(1);
            background: #007AFF;
        }

        .send-button.active:hover {
            background: #0056CC;
            transform: scale(1.05);
        }

        .send-button svg {
            width: 16px;
            height: 16px;
            fill: white;
            transform: translateX(1px);
        }

        /* Custom scrollbar for textarea */
        .message-input::-webkit-scrollbar {
            width: 4px;
        }

        .message-input::-webkit-scrollbar-track {
            background: transparent;
        }

        .message-input::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 2px;
        }

        .message-input::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.3);
        }

        .crisis-alert {
            background: linear-gradient(45deg, #ef4444, #dc2626);
            color: white;
            padding: 15px 20px;
            margin: 10px 30px;
            border-radius: 10px;
            display: none;
            align-items: center;
            gap: 10px;
            animation: slideDown 0.3s ease-out;
        }

        .crisis-alert.active {
            display: flex;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .crisis-icon {
            font-size: 20px;
        }

        @media (max-width: 768px) {
            .app-container {
                grid-template-columns: 1fr;
                height: 100vh;
                border-radius: 0;
            }

            .sidebar {
                display: none;
            }
            
            .messages {
                padding: 15px;
                max-height: calc(100vh - 200px);
            }
            
            .input-container {
                padding: 15px;
            }
        }
        
        @media (max-width: 1024px) and (min-width: 769px) {
            .app-container {
                grid-template-columns: 250px 1fr;
            }
            
            .sidebar {
                padding: 20px 15px;
            }
            
            .messages {
                padding: 20px;
            }
        }

        /* Loading screen styles */
        .auth-loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            color: white;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 18px;
            font-weight: 500;
            margin-bottom: 10px;
        }

        .loading-subtext {
            font-size: 14px;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <!-- Loading screen shown by default -->
    <div class="auth-loading" id="authLoading">
        <div class="loading-spinner"></div>
        <div class="loading-text">MindBridge AI</div>
        <div class="loading-subtext">Initializing secure connection...</div>
    </div>

    <div class="app-container">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="logo">🧠 MindBridge AI</div>

            <!-- Navigation Menu -->
            <nav class="nav-menu">
                <div class="nav-item active" data-view="dashboard">
                    <span class="nav-icon">📊</span>
                    <span>Dashboard</span>
                </div>
                <div class="nav-item" data-view="mood">
                    <span class="nav-icon">😊</span>
                    <span>Mood Tracking</span>
                </div>
                <div class="nav-item" data-view="journal">
                    <span class="nav-icon">📝</span>
                    <span>Journal Entry</span>
                </div>
                <div class="nav-item" data-view="chat">
                    <span class="nav-icon">💬</span>
                    <span>Companion</span>
                </div>
            </nav>

        </div>

        <!-- Main Content -->
        <div class="main-content">
            <!-- Common Header -->
            <div class="header">
                <div class="user-info">
                    <div class="avatar" id="userAvatar">JD</div>
                    <div>
                        <div style="font-weight: 600;" id="userName">Loading...</div>
                        <div style="font-size: 14px; color: #6b7280;" id="userInfo">Loading user info...</div>
                    </div>
                </div>
                <div style="display: flex; align-items: center; gap: 20px;">
                    <button onclick="keycloakLogout()" style="padding: 8px 16px; background: #ef4444; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px;">
                        Logout
                    </button>
                </div>
            </div>

            <!-- Dashboard View -->
            <div id="dashboard-view" class="view active">
                <div style="padding: 30px; overflow-y: auto; flex: 1;">
                    <div style="max-width: 1200px; margin: 0 auto;">
                        <h1 style="color: #333; margin-bottom: 30px; font-size: 2rem;">Welcome back, <span id="dashboardUserName">User</span>!</h1>
                        
                        <!-- Quick Stats -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px;">
                            <div style="background: white; border-radius: 15px; padding: 20px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);">
                                <h3 style="color: #4a90e2; margin-bottom: 10px;">Today's Mood</h3>
                                <div style="font-size: 2.5rem; color: #333;" id="recentMoodScore">-</div>
                                <div style="color: #666; font-size: 14px;" id="recentMoodDate">No entries yet</div>
                            </div>
                            <div style="background: white; border-radius: 15px; padding: 20px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);">
                                <h3 style="color: #4a90e2; margin-bottom: 10px;">7-Day Average</h3>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <div style="font-size: 2.5rem; color: #333;" id="weeklyMoodAvg">-</div>
                                    <div style="font-size: 1.5rem;" id="moodTrendIcon">📊</div>
                                </div>
                                <div style="color: #666; font-size: 14px;" id="moodTrendText">Calculating...</div>
                            </div>
                            <div style="background: white; border-radius: 15px; padding: 20px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);">
                                <h3 style="color: #4a90e2; margin-bottom: 10px;">Journal Entries</h3>
                                <div style="font-size: 2.5rem; color: #333;" id="journalCount">-</div>
                                <div style="color: #666; font-size: 14px;">Total entries</div>
                            </div>
                            <div style="background: white; border-radius: 15px; padding: 20px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);">
                                <h3 style="color: #4a90e2; margin-bottom: 10px;">Streak</h3>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <div style="font-size: 2.5rem; color: #333;" id="streakCount">-</div>
                                    <div style="font-size: 1.5rem;">🔥</div>
                                </div>
                                <div style="color: #666; font-size: 14px;" id="streakText">Days active</div>
                            </div>
                        </div>

                        <!-- Mood Trend Chart -->
                        <div style="background: white; border-radius: 15px; padding: 30px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); margin-bottom: 30px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                                <h2 style="color: #333; margin: 0;">7-Day Mood Trend</h2>
                                <div style="display: flex; gap: 15px; font-size: 14px; color: #666;">
                                    <div style="display: flex; align-items: center; gap: 5px;">
                                        <div style="width: 12px; height: 12px; background: #4a90e2; border-radius: 50%;"></div>
                                        <span>Mood Score</span>
                                    </div>
                                </div>
                            </div>
                            <div id="moodChart" style="height: 200px; position: relative; background: #f9fafb; border-radius: 10px; padding: 20px;">
                                <div style="display: flex; justify-content: center; align-items: center; height: 100%; color: #666;">
                                    Loading mood trend...
                                </div>
                            </div>
                        </div>

                        <!-- Insights Panel -->
                        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 15px; padding: 30px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); margin-bottom: 30px; color: white;">
                            <h2 style="color: white; margin: 0 0 15px 0;">🧠 Your Wellness Insights</h2>
                            <div id="dailyInsight" style="font-size: 16px; line-height: 1.6; opacity: 0.9; margin-bottom: 15px;">
                                Analyzing your mood patterns...
                            </div>
                            <div id="additionalInsights" style="font-size: 14px; line-height: 1.5; opacity: 0.8;">
                                <!-- Additional insights will appear here -->
                            </div>
                        </div>

                    </div>
                </div>
            </div>

            <!-- Mood Tracking View -->
            <div id="mood-view" class="view">
                <div style="padding: 30px; overflow-y: auto; flex: 1;">
                    <div style="max-width: 800px; margin: 0 auto;">
                        <h1 style="color: #333; margin-bottom: 30px; font-size: 2rem;">Mood Tracking</h1>
                        
                        <!-- Mood Entry Form -->
                        <div style="background: white; border-radius: 15px; padding: 30px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); margin-bottom: 30px;">
                            <h2 style="color: #4a90e2; margin-bottom: 20px;">How are you feeling today?</h2>
                            
                            <form id="moodEntryForm">
                                <!-- Mood Slider -->
                                <div style="margin-bottom: 25px;">
                                    <label style="display: block; margin-bottom: 10px; font-weight: 600;">Mood Score (1-10)</label>
                                    <div style="position: relative; margin: 20px 0;">
                                        <input type="range" id="moodSlider" min="1" max="10" value="5" 
                                               style="width: 100%; height: 8px; background: linear-gradient(to right, #ef4444, #f59e0b, #10b981); border-radius: 5px; outline: none;">
                                        <div style="display: flex; justify-content: space-between; margin-top: 10px; font-size: 12px; color: #666;">
                                            <span>1 - Very Low</span>
                                            <span>5 - Neutral</span>
                                            <span>10 - Excellent</span>
                                        </div>
                                    </div>
                                    <div style="text-align: center; margin-top: 15px;">
                                        <span style="font-size: 3rem;" id="moodEmoji">😐</span>
                                        <div style="font-size: 1.5rem; font-weight: 600; color: #333;" id="moodScoreDisplay">5</div>
                                    </div>
                                </div>

                                <!-- Mood Tags -->
                                <div style="margin-bottom: 20px;">
                                    <label style="display: block; margin-bottom: 10px; font-weight: 600;">How would you describe your mood?</label>
                                    <div id="moodTags" style="display: flex; flex-wrap: wrap; gap: 10px;">
                                        <span class="mood-tag" data-tag="happy">😊 Happy</span>
                                        <span class="mood-tag" data-tag="anxious">😰 Anxious</span>
                                        <span class="mood-tag" data-tag="sad">😢 Sad</span>
                                        <span class="mood-tag" data-tag="excited">🤩 Excited</span>
                                        <span class="mood-tag" data-tag="tired">😴 Tired</span>
                                        <span class="mood-tag" data-tag="angry">😠 Angry</span>
                                        <span class="mood-tag" data-tag="peaceful">😌 Peaceful</span>
                                        <span class="mood-tag" data-tag="stressed">😤 Stressed</span>
                                        <span class="mood-tag" data-tag="grateful">🙏 Grateful</span>
                                        <span class="mood-tag" data-tag="confused">😕 Confused</span>
                                    </div>
                                </div>

                                <!-- Notes -->
                                <div style="margin-bottom: 20px;">
                                    <label for="moodNotes" style="display: block; margin-bottom: 10px; font-weight: 600;">Notes (optional)</label>
                                    <textarea id="moodNotes" placeholder="What's on your mind? Any specific thoughts or events affecting your mood?"
                                              style="width: 100%; min-height: 80px; padding: 12px; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 14px; resize: vertical; box-sizing: border-box;"></textarea>
                                </div>

                                <button type="submit" id="saveMoodBtn" 
                                        style="width: 100%; padding: 15px; background: linear-gradient(45deg, #4a90e2, #357abd); color: white; border: none; border-radius: 10px; font-size: 16px; font-weight: 600; cursor: pointer;">
                                    Save Mood Entry
                                </button>
                            </form>
                        </div>

                        <!-- Mood History -->
                        <div style="background: white; border-radius: 15px; padding: 30px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); margin-bottom: 30px;">
                            <h3 style="color: #4a90e2; margin-bottom: 20px; font-size: 1.5rem;">Mood History</h3>
                            <div id="moodHistoryContainer">
                                <div style="text-align: center; color: #666; padding: 20px;">Loading mood history...</div>
                            </div>
                        </div>

                    </div>
                </div>
            </div>

            <!-- Journal Entry View -->
            <div id="journal-view" class="view">
                <div style="padding: 30px; overflow-y: auto; flex: 1;">
                    <div style="max-width: 800px; margin: 0 auto;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px;">
                            <h1 style="color: #333; margin: 0; font-size: 2rem;">Journal Entry</h1>
                            <button onclick="showNewJournalForm()" style="padding: 10px 20px; background: linear-gradient(45deg, #4a90e2, #357abd); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer;">
                                + New Entry
                            </button>
                        </div>
                        
                        <!-- Journal Entry Form -->
                        <div id="journalForm" style="background: white; border-radius: 15px; padding: 30px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); margin-bottom: 30px; display: none;">
                            <h2 style="color: #4a90e2; margin-bottom: 20px;" id="journalFormTitle">Create New Journal Entry</h2>
                            
                            <form id="journalEntryForm">
                                <input type="hidden" id="journalEntryCode" value="">
                                
                                <!-- Title -->
                                <div style="margin-bottom: 20px;">
                                    <label for="journalTitle" style="display: block; margin-bottom: 8px; font-weight: 600;">Title</label>
                                    <input type="text" id="journalTitle" placeholder="What's on your mind today?"
                                           style="width: 100%; padding: 12px; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 16px; box-sizing: border-box;">
                                </div>

                                <!-- Content -->
                                <div style="margin-bottom: 20px;">
                                    <label for="journalContent" style="display: block; margin-bottom: 8px; font-weight: 600;">Content</label>
                                    <textarea id="journalContent" placeholder="Write about your thoughts, feelings, experiences..."
                                              style="width: 100%; min-height: 200px; padding: 12px; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 14px; resize: vertical; box-sizing: border-box; font-family: inherit;"></textarea>
                                </div>

                                <!-- Mood Before/After -->
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                                    <div>
                                        <label for="moodBefore" style="display: block; margin-bottom: 8px; font-weight: 600;">Mood Before (1-10)</label>
                                        <input type="number" id="moodBefore" min="1" max="10" placeholder="5"
                                               style="width: 100%; padding: 12px; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 14px; box-sizing: border-box;">
                                    </div>
                                    <div>
                                        <label for="moodAfter" style="display: block; margin-bottom: 8px; font-weight: 600;">Mood After (1-10)</label>
                                        <input type="number" id="moodAfter" min="1" max="10" placeholder="5"
                                               style="width: 100%; padding: 12px; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 14px; box-sizing: border-box;">
                                    </div>
                                </div>

                                <!-- Tags -->
                                <div style="margin-bottom: 25px;">
                                    <label for="journalTags" style="display: block; margin-bottom: 8px; font-weight: 600;">Tags (comma-separated)</label>
                                    <input type="text" id="journalTags" placeholder="reflection, growth, challenges, gratitude"
                                           style="width: 100%; padding: 12px; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 14px; box-sizing: border-box;">
                                </div>

                                <div style="display: flex; gap: 10px;">
                                    <button type="submit" id="saveJournalBtn" 
                                            style="flex: 1; padding: 15px; background: linear-gradient(45deg, #4a90e2, #357abd); color: white; border: none; border-radius: 10px; font-size: 16px; font-weight: 600; cursor: pointer;">
                                        Save Entry
                                    </button>
                                    <button type="button" onclick="hideJournalForm()" 
                                            style="padding: 15px 20px; background: #f3f4f6; color: #374151; border: none; border-radius: 10px; font-size: 16px; cursor: pointer;">
                                        Cancel
                                    </button>
                                </div>
                            </form>
                        </div>

                        <!-- Search -->
                        <div style="background: white; border-radius: 15px; padding: 20px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); margin-bottom: 30px;">
                            <div style="display: flex; gap: 10px;">
                                <input type="text" id="journalSearch" placeholder="Search your journal entries..."
                                       style="flex: 1; padding: 12px; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 14px;">
                                <button onclick="searchJournalEntries()" style="padding: 12px 20px; background: #4a90e2; color: white; border: none; border-radius: 8px; cursor: pointer;">
                                    Search
                                </button>
                                <button onclick="loadJournalEntries()" style="padding: 12px 20px; background: #f3f4f6; color: #374151; border: none; border-radius: 8px; cursor: pointer;">
                                    Clear
                                </button>
                            </div>
                        </div>

                        <!-- Journal History -->
                        <div style="background: white; border-radius: 15px; padding: 30px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); margin-bottom: 30px;">
                            <h3 style="color: #4a90e2; margin-bottom: 20px; font-size: 1.5rem;">Journal History</h3>
                            <div id="journalHistoryContainer">
                                <div style="text-align: center; color: #666; padding: 20px;">Loading journal entries...</div>
                            </div>
                        </div>

                    </div>
                </div>
            </div>

            <!-- Chat View (Companion) -->
            <div id="chat-view" class="view">
                <div class="chat-container">
                    <div class="messages" id="messages">
                    </div>

                    <div class="typing-indicator" id="typingIndicator">
                        <div style="max-width: 70%; padding: 12px 18px; border-radius: 25px; background: #E5E5EA; position: relative; border-bottom-left-radius: 8px;">
                            <div class="typing-dots">
                                <div class="typing-dot"></div>
                                <div class="typing-dot"></div>
                                <div class="typing-dot"></div>
                            </div>
                        </div>
                    </div>

                    <div class="input-container">
                        <div class="input-wrapper">
                            <div class="text-input-container">
                                <textarea 
                                    class="message-input" 
                                    id="messageInput" 
                                    rows="1"
                                    maxlength="1000"
                                    placeholder="Message"
                                ></textarea>
                            </div>

                            <button class="send-button" id="sendButton" title="Send message">
                                <svg viewBox="0 0 24 24">
                                    <path d="M2,21L23,12L2,3V10L17,12L2,14V21Z"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- STOMP.js for WebSocket communication -->
    <script src="https://cdn.jsdelivr.net/npm/@stomp/stompjs@7.0.0/bundles/stomp.umd.min.js"></script>
    <script src="https://unpkg.com/marked@9.1.2/marked.min.js"></script>
    <!-- Keycloak JS -->
    <script src="https://cdn.jsdelivr.net/npm/keycloak-js@23.0.0/dist/keycloak.min.js"></script>

    <!-- Authentication Guard -->
    <script>
        // API Configuration - automatically detects environment
        const API_CONFIG = {
            // Auto-detect if running locally or on cloud
            isLocal: window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1',
            
            // Base URLs that change between environments
            get keycloakUrl() {
                return this.isLocal ? 'http://localhost:8080' : 'https://auth.honne.app';
            },
            
            get backendUrl() {
                return this.isLocal ? 'http://localhost:8082' : 'https://mindbridge.honne.app';
            },

            get websocketUrl() {
                const protocol = this.isLocal ? 'ws' : 'wss';
                const host = this.isLocal ? 'localhost:8082' : 'mindbridge.honne.app';
                return `${protocol}://${host}/v1/agent/mindbridge`;
            }
        };

        // Keycloak configuration using dynamic URL
        const KEYCLOAK_CONFIG = {
            url: API_CONFIG.keycloakUrl,
            realm: 'MindBridge',
            clientId: 'MindBridgeClient'
        };
        
        
        let keycloakInstance = null;
        let authMode = 'checking'; // 'checking', 'keycloak'
        let initializationInProgress = false;
        let initializationCompleted = false;
        let keycloakInitAttempted = false;
        
        // Function to reset initialization state (useful for debugging)
        function resetInitializationState() {
            console.log('Resetting initialization state...');
            initializationInProgress = false;
            initializationCompleted = false;
            domContentLoadedHandled = false;
            keycloakInitAttempted = false;
            window.mainAppInitialized = false;
        }
        
        // Expose reset function globally for debugging
        window.resetInitializationState = resetInitializationState;
        
        // Handle OAuth callback from Keycloak
        async function handleOAuthCallback() {
            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('code');
            const state = urlParams.get('state');
            const sessionState = urlParams.get('session_state');
            
            if (code) {
                console.log('OAuth callback detected, exchanging code for token...');
                
                try {
                    // Exchange authorization code for tokens
                    const redirectUri = getRedirectUri();
                    const formData = new URLSearchParams();
                    formData.append('grant_type', 'authorization_code');
                    formData.append('client_id', KEYCLOAK_CONFIG.clientId);
                    formData.append('code', code);
                    formData.append('redirect_uri', redirectUri);
                    
                    const response = await fetch(`${KEYCLOAK_CONFIG.url}/realms/${KEYCLOAK_CONFIG.realm}/protocol/openid-connect/token`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        },
                        body: formData.toString(),
                    });
                    
                    if (response.ok) {
                        const tokenResponse = await response.json();
                        
                        // Store tokens
                        localStorage.setItem('token', tokenResponse.access_token);
                        localStorage.setItem('refreshToken', tokenResponse.refresh_token);
                        
                        // Clean URL and show main app
                        window.history.replaceState({}, document.title, window.location.pathname);
                        showMainApp();
                        return true;
                    } else {
                        const error = await response.json();
                        console.error('Token exchange failed:', error);
                        throw new Error(error.error_description || 'Token exchange failed');
                    }
                } catch (error) {
                    console.error('OAuth callback error:', error);
                    // Clear URL parameters and show login
                    window.history.replaceState({}, document.title, window.location.pathname);
                    showLoginFallback();
                    return false;
                }
            }
            
            return false;
        }
        
        // Track if initialization has started
        let domContentLoadedHandled = false;
        
        // Prevent back navigation to authenticated pages after logout
        window.addEventListener('pageshow', function(event) {
            // Check if this is a back/forward navigation
            if (event.persisted) {
                console.log('Page loaded from cache (back/forward navigation detected)');
                // Check if user is actually logged out
                const hasToken = localStorage.getItem('token') || localStorage.getItem('refreshToken');
                if (!hasToken) {
                    console.log('No valid tokens found, redirecting to login');
                    window.location.replace(window.location.origin + window.location.pathname + '?logout=true');
                    return;
                }
            }
        });
        
        // Immediately hide the page and check authentication
        document.addEventListener('DOMContentLoaded', async function() {
            if (domContentLoadedHandled || initializationInProgress || initializationCompleted) {
                console.log('DOMContentLoaded already handled or initialization in progress, skipping...');
                return;
            }
            domContentLoadedHandled = true;
            
            console.log('DOMContentLoaded triggered, starting authentication check...');
            const appContainer = document.querySelector('.app-container');
            if (appContainer) {
                appContainer.style.display = 'none';
            }
            
            // Check URL parameters for OAuth callback
            const urlParams = new URLSearchParams(window.location.search);
            const hasCode = urlParams.has('code');
            const hasLogoutParam = urlParams.has('logout') || window.location.href.includes('logout');
            
            if (hasCode) {
                // Handle OAuth callback
                const callbackHandled = await handleOAuthCallback();
                if (callbackHandled) {
                    return; // OAuth callback handled successfully
                }
            }
            
            if (hasLogoutParam) {
                // Clear any existing tokens after logout redirect
                localStorage.clear();
                sessionStorage.clear();
                console.log('Logout completed, showing login form');
                
                // Clear the logout flag from URL
                window.history.replaceState({}, document.title, window.location.pathname);
                
                // Mark initialization as completed to prevent any auth attempts
                initializationCompleted = true;
                domContentLoadedHandled = true;
                
                // Reset logout progress flag
                window.logoutInProgress = false;
                
                // Show login form
                showLoginFallback();
                return;
            }
            
            
            // Check if we already have tokens
            const existingToken = localStorage.getItem('token');
            const existingRefreshToken = localStorage.getItem('refreshToken');
            
            if (existingToken || existingRefreshToken) {
                console.log('Found existing tokens, validating...');
                // Try to validate token first, or refresh if only refresh token exists
                const isValid = await validateExistingToken(existingToken, existingRefreshToken);
                if (isValid) {
                    return; // Token is valid or was refreshed, main app will be shown
                }
                // If both access and refresh tokens are invalid, continue to Keycloak initialization
            }
            
            console.log('No valid token, initializing Keycloak');
            // Initialize Keycloak with a small delay to prevent race conditions
            setTimeout(() => {
                if (!initializationInProgress && !initializationCompleted) {
                    initKeycloakAuth();
                }
            }, 100);
        });
        
        async function validateExistingToken(token, refreshToken) {
            try {
                // If no access token but have refresh token, try to refresh immediately
                if (!token && refreshToken) {
                    console.log('No access token found, but refresh token exists. Attempting refresh...');
                    try {
                        const newToken = await refreshWithStoredToken(refreshToken);
                        if (newToken) {
                            console.log('✅ Token refreshed successfully on page load');
                            initializationCompleted = true;
                            showMainApp();
                            return true;
                        }
                    } catch (refreshError) {
                        console.log('❌ Refresh failed during page load:', refreshError);
                        // Clear invalid refresh token
                        localStorage.removeItem('token');
                        localStorage.removeItem('refreshToken');
                        initializationCompleted = true;
                        showLoginFallback();
                        return false;
                    }
                }
                
                // If we have an access token, validate it
                if (token) {
                    // Decode JWT to check if it's expired
                    const payload = decodeJWT(token);
                    const now = Math.floor(Date.now() / 1000);
                    
                    console.log('Token validation - Current time:', now, 'Token exp:', payload.exp);
                    
                    if (payload.exp && payload.exp > now) {
                        console.log('✅ Token is valid, showing main app');
                        initializationCompleted = true;
                        showMainApp();
                        return true;
                    } else {
                        console.log('❌ Access token expired, attempting refresh...');
                        
                        // Try to refresh using refresh token
                        if (refreshToken) {
                            try {
                                const newToken = await refreshWithStoredToken(refreshToken);
                                if (newToken) {
                                    console.log('✅ Token refreshed successfully on page load');
                                    initializationCompleted = true;
                                    showMainApp();
                                    return true;
                                }
                            } catch (refreshError) {
                                console.log('❌ Refresh failed during page load:', refreshError);
                            }
                        }
                        
                        // If refresh fails or no refresh token, clear everything
                        console.log('❌ No valid refresh token, clearing and showing login');
                        localStorage.removeItem('token');
                        localStorage.removeItem('refreshToken');
                        initializationCompleted = true;
                        showLoginFallback();
                        return false;
                    }
                }
                
                // If no tokens at all, return false
                console.log('❌ No tokens found');
                return false;
                
            } catch (error) {
                console.log('❌ Invalid token, clearing and showing login:', error);
                localStorage.removeItem('token');
                localStorage.removeItem('refreshToken');
                initializationCompleted = true;
                showLoginFallback();
                return false;
            }
        }

        // Helper function to refresh token using stored refresh token
        async function refreshWithStoredToken(refreshToken) {
            try {
                console.log('Attempting token refresh with stored refresh token...');
                
                const response = await fetch(`${KEYCLOAK_CONFIG.url}/realms/${KEYCLOAK_CONFIG.realm}/protocol/openid-connect/token`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: new URLSearchParams({
                        'grant_type': 'refresh_token',
                        'client_id': KEYCLOAK_CONFIG.clientId,
                        'refresh_token': refreshToken
                    })
                });
                
                if (response.ok) {
                    const tokenData = await response.json();
                    localStorage.setItem('token', tokenData.access_token);
                    localStorage.setItem('refreshToken', tokenData.refresh_token);
                    console.log('✅ Token refreshed successfully');
                    return tokenData.access_token;
                } else {
                    const errorData = await response.json();
                    console.error('❌ Refresh token response error:', errorData);
                    throw new Error('Refresh token request failed: ' + (errorData.error_description || errorData.error));
                }
            } catch (error) {
                console.error('❌ Refresh token exchange failed:', error);
                throw error;
            }
        }
        
        async function initKeycloakAuth() {
            // Prevent multiple concurrent initializations
            if (initializationInProgress || initializationCompleted || keycloakInitAttempted) {
                console.log('Keycloak initialization already in progress, completed, or attempted. Skipping...');
                return;
            }
            
            initializationInProgress = true;
            keycloakInitAttempted = true;
            console.log('Initializing Keycloak authentication...');
            
            // Check if Keycloak library is loaded
            if (typeof Keycloak === 'undefined') {
                console.error('Keycloak library not loaded');
                initializationInProgress = false;
                showKeycloakError();
                return;
            }
            
            // First check if Keycloak server is available
            console.log('About to check Keycloak availability...');
            const isKeycloakAvailable = await checkKeycloakAvailability();
            console.log('Keycloak availability check result:', isKeycloakAvailable);
            
            if (!isKeycloakAvailable) {
                console.error('❌ Keycloak server not available at:', KEYCLOAK_CONFIG.url);
                console.error('Please check:');
                console.error('1. Keycloak server is running');
                console.error('2. Server is accessible at', KEYCLOAK_CONFIG.url);
                console.error('3. No firewall or proxy blocking the connection');
                
                initializationInProgress = false;
                showKeycloakError();
                return;
            }
            
            console.log('✅ Keycloak server is available, proceeding with initialization...');
            
            // Reset keycloak instance
            keycloakInstance = null;
            authMode = 'keycloak';
            
            try {
                console.log('Creating Keycloak instance with config:', KEYCLOAK_CONFIG);
                
                // Validate configuration before creating instance
                if (!KEYCLOAK_CONFIG.url) {
                    throw new Error('Keycloak URL is missing in configuration');
                }
                if (!KEYCLOAK_CONFIG.realm) {
                    throw new Error('Keycloak realm is missing in configuration');
                }
                if (!KEYCLOAK_CONFIG.clientId) {
                    throw new Error('Keycloak clientId is missing in configuration');
                }
                
                console.log('Configuration validation passed, creating instance...');
                keycloakInstance = new Keycloak(KEYCLOAK_CONFIG);
                console.log('Keycloak instance created successfully:', keycloakInstance);
                
                // Clear any existing Keycloak state that might cause nonce issues
                console.log('Clearing any existing Keycloak state...');
                keycloakInstance.clearToken();
                
                // Clear any Keycloak-related localStorage/sessionStorage
                Object.keys(localStorage).forEach(key => {
                    if (key.includes('keycloak') || key.includes('kc-') || key.includes('auth')) {
                        console.log('Removing potentially conflicting storage key:', key);
                        localStorage.removeItem(key);
                    }
                });
                
                Object.keys(sessionStorage).forEach(key => {
                    if (key.includes('keycloak') || key.includes('kc-') || key.includes('auth')) {
                        console.log('Removing potentially conflicting session key:', key);
                        sessionStorage.removeItem(key);
                    }
                });
                
                console.log('Starting Keycloak initialization...');
                
                // Set a timeout for Keycloak initialization
                const initTimeout = setTimeout(() => {
                    console.error('Keycloak initialization timed out after 10 seconds');
                    initializationInProgress = false;
                    showKeycloakError();
                }, 10000);
                
                keycloakInstance.init({
                    onLoad: undefined, // Don't auto-login or check SSO
                    checkLoginIframe: false,
                    silentCheckSsoRedirectUri: undefined, // Disable silent check
                    enableLogging: true,
                    // Remove PKCE to avoid nonce issues
                    // pkceMethod: 'S256',
                    flow: 'standard', // Use standard flow
                    responseMode: 'query', // Use query mode to avoid fragment issues
                    scope: 'openid profile email'
                }).then(function(authenticated) {
                    clearTimeout(initTimeout);
                    console.log('✅ Keycloak init completed successfully!');
                    console.log('Authenticated:', authenticated);
                    console.log('Keycloak authenticated property:', keycloakInstance.authenticated);
                    console.log('Token present:', keycloakInstance.token ? 'YES' : 'NO');
                    console.log('Refresh token present:', keycloakInstance.refreshToken ? 'YES' : 'NO');
                    
                    if (authenticated && keycloakInstance.token) {
                        console.log('✅ User is authenticated with valid token');
                        
                        // Store tokens
                        localStorage.setItem('token', keycloakInstance.token);
                        if (keycloakInstance.refreshToken) {
                            localStorage.setItem('refreshToken', keycloakInstance.refreshToken);
                        }
                        
                        console.log('Showing main application...');
                        initializationInProgress = false;
                        initializationCompleted = true;
                        showMainApp();
                    } else {
                        console.log('ℹ️ User not authenticated, showing login form');
                        initializationInProgress = false;
                        initializationCompleted = true;
                        showLoginFallback();
                    }
                }).catch(function(error) {
                    clearTimeout(initTimeout);
                    console.error('Keycloak init promise rejected:', error);
                    console.error('Raw error object:', error);
                    console.error('Error type:', typeof error);
                    console.error('Error constructor:', error?.constructor?.name);
                    
                    // Try to extract any useful information
                    let errorInfo = 'No error information available';
                    if (error) {
                        if (typeof error === 'string') {
                            errorInfo = error;
                        } else if (error.message) {
                            errorInfo = error.message;
                        } else if (error.toString && typeof error.toString === 'function') {
                            try {
                                errorInfo = error.toString();
                            } catch (e) {
                                errorInfo = 'Error in toString()';
                            }
                        }
                    }
                    
                    console.error('Extracted error info:', errorInfo);
                    
                    // Specific handling for nonce/token issues
                    console.error('🔍 This appears to be a nonce/token validation issue.');
                    console.error('Common causes and solutions:');
                    console.error('1. ❌ Invalid/corrupted browser state - Try clearing browser data');
                    console.error('2. ❌ PKCE nonce validation failed - Disabled PKCE in this attempt');
                    console.error('3. ❌ Keycloak client configuration issue');
                    console.error('4. ❌ Browser security policies blocking token validation');
                    console.error('');
                    console.error('🛠️ Troubleshooting steps:');
                    console.error('1. Clear browser cache and cookies');
                    console.error('2. Check Keycloak client settings for "MindBridgeClient"');
                    console.error('3. Ensure client has "Standard Flow" enabled');
                    console.error('4. Check valid redirect URIs in Keycloak client config');
                    
                    // Check if this might be a CORS or network issue
                    if (errorInfo.includes('NetworkError') || errorInfo.includes('CORS') || errorInfo.includes('Failed to fetch')) {
                        console.error('This appears to be a network/CORS issue. Make sure:');
                        console.error('1. Keycloak server is running on', KEYCLOAK_CONFIG.url);
                        console.error('2. CORS is properly configured in Keycloak');
                        console.error('3. The realm "MindBridge" exists');
                        console.error('4. The client "MindBridgeClient" is configured');
                    }
                    
                    initializationInProgress = false;
                    showKeycloakError();
                });
            } catch (error) {
                console.error('Exception during Keycloak instance creation:', error);
                console.error('Raw exception object:', error);
                console.error('Exception type:', typeof error);
                
                // Check if it's a reference error (Keycloak not defined)
                if (error instanceof ReferenceError) {
                    console.error('ReferenceError detected - Keycloak library may not be loaded properly');
                } else if (error instanceof TypeError) {
                    console.error('TypeError detected - Check Keycloak constructor arguments');
                }
                
                initializationInProgress = false;
                showKeycloakError();
            }
        }
        
        async function checkKeycloakAvailability() {
            try {
                const response = await fetch(`${KEYCLOAK_CONFIG.url}/realms/${KEYCLOAK_CONFIG.realm}/.well-known/openid-configuration`, {
                    method: 'GET',
                    mode: 'cors'
                });
                return response.ok;
            } catch (error) {
                console.log('Keycloak health check failed:', error?.message || 'Unknown error');
                console.log('Full error details:', {
                    name: error?.name,
                    message: error?.message,
                    stack: error?.stack
                });
                return false;
            }
        }
        
        function showMainApp() {
            // Hide loading screen
            const authLoading = document.getElementById('authLoading');
            if (authLoading) {
                authLoading.style.display = 'none';
            }
            
            // Show main app
            const appContainer = document.querySelector('.app-container');
            if (appContainer) {
                appContainer.style.display = 'grid';
            }
            
            // Update user info from Keycloak token

            if (keycloakInstance && keycloakInstance.tokenParsed) {
                updateUserInfoFromKeycloak();
            }
            
            // Initialize layout and components only once
            if (!window.mainAppInitialized) {
                window.mainAppInitialized = true;
                setTimeout(() => {
                    // Initialize router first
                    if (typeof initRouter === 'function') {
                        initRouter();
                    }
                    
                    // Load user profile
                    if (typeof initUserProfile === 'function') {
                        initUserProfile();
                    }
                    
                    if (typeof initWebSocket === 'function' && !connected) {
                        initWebSocket();
                    }
                    // Initialize message input handlers
                    if (typeof initializeMessageInput === 'function') {
                        initializeMessageInput();
                    }
                    // Load chat history
                    if (typeof loadChatHistory === 'function') {
                        loadChatHistory();
                    }
                }, 100);
            }
        }
        
        // Layout is now handled by CSS flexbox - no manual adjustments needed
        
        function updateUserInfoFromKeycloak() {
            const userInfo = keycloakInstance.tokenParsed;
            const avatar = document.querySelector('.avatar');
            const userName = document.querySelector('.user-info div:nth-child(2) div:first-child');
            const userId = document.querySelector('.user-info div:nth-child(2) div:last-child');
            
            if (avatar && userName && userId) {
                avatar.textContent = (userInfo.given_name?.[0] || '') + (userInfo.family_name?.[0] || 'U');
                userName.textContent = userInfo.name || userInfo.preferred_username || 'User';
                userId.textContent = `Patient ID: #${userInfo.sub?.slice(-5) || '12345'}`;
            }
        }
        
        function showLoginFallback() {
            // Hide loading screen
            const authLoading = document.getElementById('authLoading');
            if (authLoading) {
                authLoading.style.display = 'none';
            }
            
            const appContainer = document.querySelector('.app-container');
            appContainer.innerHTML = `
                <div style="grid-column: 1 / -1; display: flex; align-items: center; justify-content: center; background: white; border-radius: 20px; padding: 40px;">
                    <div style="width: 100%; max-width: 400px; text-align: center;">
                        <h1 style="color: #4a90e2; margin-bottom: 10px; font-size: 2.5rem;">🧠 MindBridge</h1>
                        
                        
                        <div id="loginError" style="display: none; background: #fee; color: #c33; padding: 10px; border-radius: 5px; margin-bottom: 20px;"></div>
                        
                        <form id="loginForm" style="margin-bottom: 30px;">
                            <input type="text" id="username" placeholder="Username" required 
                                   style="width: 100%; padding: 15px; margin-bottom: 15px; border: 2px solid #e5e7eb; border-radius: 10px; font-size: 16px; box-sizing: border-box;" />
                            <input type="password" id="password" placeholder="Password" required 
                                   style="width: 100%; padding: 15px; margin-bottom: 20px; border: 2px solid #e5e7eb; border-radius: 10px; font-size: 16px; box-sizing: border-box;" />
                            <button type="submit" id="loginBtn" 
                                    style="width: 100%; padding: 15px; background: linear-gradient(45deg, #4a90e2, #357abd); color: white; border: none; border-radius: 10px; font-size: 16px; font-weight: 600; cursor: pointer; margin-bottom: 20px;">
                                Sign In
                            </button>
                        </form>
                        
                        <div style="border-top: 1px solid #e5e7eb; padding-top: 20px; margin-bottom: 20px;">
                            <p style="color: #666; margin-bottom: 15px; font-size: 14px;">OR</p>
                        </div>
                        
                        <button onclick="loginWithGoogle()" 
                                style="width: 100%; padding: 12px; background: #4285f4; color: white; border: none; border-radius: 10px; font-size: 14px; cursor: pointer; margin-bottom: 10px; display: flex; align-items: center; justify-content: center; gap: 10px; font-weight: 500;">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none">
                                <path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" fill="white"/>
                                <path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" fill="white"/>
                                <path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" fill="white"/>
                                <path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" fill="white"/>
                            </svg>
                            Continue with Google
                        </button>
                        
                        <button onclick="loginWithGitHub()" 
                                style="width: 100%; padding: 12px; background: #24292e; color: white; border: none; border-radius: 10px; font-size: 14px; cursor: pointer; margin-bottom: 20px; display: flex; align-items: center; justify-content: center; gap: 10px; font-weight: 500;">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599-.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492 .997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                            </svg>
                            Continue with GitHub
                        </button>

                    </div>
                </div>
            `;
            appContainer.style.display = 'flex';
            appContainer.style.alignItems = 'center';
            appContainer.style.justifyContent = 'center';
            
            
            // Add login handlers
            document.getElementById('loginForm').addEventListener('submit', handleDirectLogin);
        }
        
        async function handleDirectLogin(e) {
            e.preventDefault();
            
            const username = document.getElementById('username').value;
            const password = document.getElementById('password').value;
            const loginBtn = document.getElementById('loginBtn');
            const loginError = document.getElementById('loginError');
            
            loginBtn.textContent = 'Signing in...';
            loginBtn.disabled = true;
            loginError.style.display = 'none';
            
            try {
                // Keycloak direct login using Resource Owner Password Credentials Grant
                const formData = new URLSearchParams();
                formData.append('grant_type', 'password');
                formData.append('client_id', KEYCLOAK_CONFIG.clientId);
                formData.append('username', username);
                formData.append('password', password);
                
                const response = await fetch(`${KEYCLOAK_CONFIG.url}/realms/${KEYCLOAK_CONFIG.realm}/protocol/openid-connect/token`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: formData.toString(),
                });
                
                if (response.ok) {
                    const tokenResponse = await response.json();
                    
                    localStorage.setItem('token', tokenResponse.access_token);
                    localStorage.setItem('refreshToken', tokenResponse.refresh_token);
                    
                    location.reload();
                } else {
                    const error = await response.json();
                    throw new Error(error.error_description || error.error || 'Login failed');
                }
            } catch (error) {
                loginError.textContent = error.message || 'Login failed';
                loginError.style.display = 'block';
                loginBtn.textContent = 'Sign In';
                loginBtn.disabled = false;
            }
        }
        
        function showKeycloakError() {
            // Hide loading screen
            const authLoading = document.getElementById('authLoading');
            if (authLoading) {
                authLoading.style.display = 'none';
            }
            
            const appContainer = document.querySelector('.app-container');
            appContainer.innerHTML = `
                <div style="grid-column: 1 / -1; display: flex; align-items: center; justify-content: center; background: white; border-radius: 20px; padding: 40px;">
                    <div style="width: 100%; max-width: 400px; text-align: center;">
                        <h1 style="color: #ef4444; margin-bottom: 10px; font-size: 2.5rem;">🚫 Authentication Error</h1>
                        <p style="color: #666; margin-bottom: 30px; font-size: 1.1rem;">Cannot connect to Keycloak server</p>
                        
                        <div style="background: #fee; color: #c33; padding: 15px; border-radius: 5px; margin-bottom: 20px; text-align: left;">
                            <strong>Keycloak server not found:</strong><br>
                            ${KEYCLOAK_CONFIG.url}<br><br>
                            Please ensure:
                            <ul style="margin: 10px 0; padding-left: 20px;">
                                <li>Keycloak is running</li>
                                <li>Realm '${KEYCLOAK_CONFIG.realm}' exists</li>
                                <li>Client '${KEYCLOAK_CONFIG.clientId}' is configured</li>
                            </ul>
                        </div>
                        
                        
                        <button onclick="location.reload()" 
                                style="width: 100%; padding: 12px; background: #fff3cd; color: #856404; border: 2px solid #ffeaa7; border-radius: 10px; font-size: 14px; cursor: pointer;">
                            🔄 Retry Connection
                        </button>
                    </div>
                </div>
            `;
            appContainer.style.display = 'flex';
        }
        
        
        function getRedirectUri() {
            // Handle different environments (IDE server, local server, etc.)
            const currentUrl = window.location.href;
            if (currentUrl.includes('localhost:63342')) {
                // IntelliJ/WebStorm IDE server - use the actual file URL
                return currentUrl.split('?')[0]; // Remove query parameters
            }
            // For other local servers or direct file access
            return window.location.origin + window.location.pathname;
        }
        
        function loginWithGoogle() {
            const redirectUri = getRedirectUri();
            const googleLoginUrl = `${KEYCLOAK_CONFIG.url}/realms/${KEYCLOAK_CONFIG.realm}/protocol/openid-connect/auth?client_id=${KEYCLOAK_CONFIG.clientId}&redirect_uri=${encodeURIComponent(redirectUri)}&response_type=code&scope=openid email profile&kc_idp_hint=google`;
            console.log('Google login redirect URI:', redirectUri);
            window.location.href = googleLoginUrl;
        }
        
        function loginWithGitHub() {
            const redirectUri = getRedirectUri();
            const githubLoginUrl = `${KEYCLOAK_CONFIG.url}/realms/${KEYCLOAK_CONFIG.realm}/protocol/openid-connect/auth?client_id=${KEYCLOAK_CONFIG.clientId}&redirect_uri=${encodeURIComponent(redirectUri)}&response_type=code&scope=openid email profile&kc_idp_hint=github`;
            console.log('GitHub login redirect URI:', redirectUri);
            window.location.href = githubLoginUrl;
        }
        
        function decodeJWT(token) {
            try {
                const base64Url = token.split('.')[1];
                const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
                const jsonPayload = decodeURIComponent(
                    atob(base64)
                        .split('')
                        .map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))
                        .join('')
                );
                return JSON.parse(jsonPayload);
            } catch (error) {
                console.error('Failed to decode JWT:', error);
                return {};
            }
        }
        
        // Global logout function for the logout button
        async function keycloakLogout() {
            console.log('🚪 Starting logout process...');
            
            // Prevent multiple logout attempts
            if (window.logoutInProgress) {
                console.log('Logout already in progress, skipping...');
                return;
            }
            window.logoutInProgress = true;
            
            // 1. Disconnect WebSocket if connected
            if (typeof stompClient !== 'undefined' && stompClient && stompClient.connected) {
                console.log('📡 Disconnecting WebSocket...');
                try {
                    stompClient.deactivate();
                    console.log('✅ WebSocket disconnected successfully');
                } catch (error) {
                    console.warn('⚠️ Error disconnecting WebSocket:', error);
                }
            }
            
            // 2. Get current token and refresh token before clearing storage
            const currentToken = keycloakInstance?.token || localStorage.getItem('token');
            const currentRefreshToken = keycloakInstance?.refreshToken || localStorage.getItem('refreshToken');
            
            // 3. Handle Keycloak server logout to actually end the session
            if (currentToken) {
                console.log('🔐 Ending Keycloak session on server...');
                
                try {
                    // First, call the logout endpoint to end the server session
                    const logoutEndpoint = `${KEYCLOAK_CONFIG.url}/realms/${KEYCLOAK_CONFIG.realm}/protocol/openid-connect/logout`;
                    
                    const formData = new URLSearchParams();
                    formData.append('client_id', KEYCLOAK_CONFIG.clientId);
                    if (currentRefreshToken) {
                        formData.append('refresh_token', currentRefreshToken);
                    }
                    
                    const response = await fetch(logoutEndpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'Authorization': `Bearer ${currentToken}`
                        },
                        body: formData.toString()
                    });
                    
                    if (response.ok) {
                        console.log('✅ Successfully ended Keycloak session');
                    } else {
                        console.warn('⚠️ Keycloak logout returned status:', response.status);
                    }
                    
                } catch (fetchError) {
                    console.warn('⚠️ Error calling Keycloak logout endpoint:', fetchError);
                }
            }
            
            // 4. Clear all local data
            console.log('🧹 Clearing all local data...');
            localStorage.clear();
            sessionStorage.clear();
            
            // 5. Clear Keycloak instance if it exists
            if (keycloakInstance) {
                try {
                    if (keycloakInstance.clearToken) {
                        keycloakInstance.clearToken();
                    }
                    keycloakInstance.authenticated = false;
                    keycloakInstance.token = null;
                    keycloakInstance.refreshToken = null;
                } catch (error) {
                    console.warn('Error clearing Keycloak instance:', error);
                }
            }
            
            // 6. Reset application state
            if (typeof currentUser !== 'undefined') {
                currentUser = null;
            }
            resetInitializationState();
            
            // 7. Navigate to clean URL with logout flag and clear history
            console.log('💻 Redirecting to clean logout URL...');
            const cleanUrl = window.location.origin + window.location.pathname + '?logout=true';
            
            // Clear browser history to prevent back navigation to authenticated pages
            // This replaces the current history entry rather than adding a new one
            window.history.replaceState(null, null, cleanUrl);
            
            // Force page reload to show login page
            window.location.reload();
        }
    </script>

    <!-- Router and Navigation System -->
    <script>
        // Router System for View Management
        class AppRouter {
            constructor() {
                this.currentView = 'dashboard';
                this.views = ['dashboard', 'mood', 'journal', 'chat'];
                this.init();
            }

            init() {
                // Handle initial hash or default to dashboard
                this.handleHashChange();
                
                // Listen for hash changes
                window.addEventListener('hashchange', () => this.handleHashChange());
                
                // Add click listeners to navigation items
                this.initNavigation();
            }

            handleHashChange() {
                const hash = window.location.hash.slice(1); // Remove #
                const view = this.views.includes(hash) ? hash : 'dashboard';
                this.navigateToView(view);
            }

            navigateToView(viewName) {
                if (!this.views.includes(viewName)) return;
                
                // Update current view
                this.currentView = viewName;
                
                // Update URL hash
                if (window.location.hash.slice(1) !== viewName) {
                    window.location.hash = viewName;
                }
                
                // Update active navigation item
                this.updateNavigation(viewName);
                
                // Show/hide views
                this.updateViews(viewName);
                
                // Update sidebar components visibility
                this.updateSidebarComponents(viewName);
                
                // Initialize view-specific functionality
                this.initializeViewContent(viewName);
            }

            updateNavigation(activeView) {
                // Remove active class from all nav items
                document.querySelectorAll('.nav-item').forEach(item => {
                    item.classList.remove('active');
                });
                
                // Add active class to current view
                const activeNavItem = document.querySelector(`[data-view="${activeView}"]`);
                if (activeNavItem) {
                    activeNavItem.classList.add('active');
                }
            }

            updateViews(activeView) {
                // Hide all views
                document.querySelectorAll('.view').forEach(view => {
                    view.classList.remove('active');
                });
                
                // Show active view
                const activeViewElement = document.getElementById(`${activeView}-view`);
                if (activeViewElement) {
                    activeViewElement.classList.add('active');
                }
            }

            updateSidebarComponents(activeView) {
                // Future: Add any view-specific sidebar component logic here
            }

            initNavigation() {
                document.querySelectorAll('.nav-item').forEach(item => {
                    // Skip if already has event listener to prevent duplicates
                    if (item.hasNavListener) {
                        return;
                    }
                    
                    const handleClick = (e) => {
                        const viewName = item.getAttribute('data-view');
                        if (viewName) {
                            this.navigateToView(viewName);
                        }
                    };
                    
                    item.addEventListener('click', handleClick);
                    item.hasNavListener = true;
                });
            }

            initializeViewContent(viewName) {
                // Track initialized views to prevent duplicate API calls
                if (!this.initializedViews) {
                    this.initializedViews = new Set();
                }
                
                // Initialize view-specific content and functionality
                switch (viewName) {
                    case 'dashboard':
                        if (typeof initDashboard === 'function' && !this.initializedViews.has('dashboard')) {
                            this.initializedViews.add('dashboard');
                            initDashboard();
                        }
                        break;
                    case 'mood':
                        if (typeof initMoodTracking === 'function' && !this.initializedViews.has('mood')) {
                            this.initializedViews.add('mood');
                            initMoodTracking();
                        }
                        break;
                    case 'journal':
                        if (typeof initJournalEntry === 'function' && !this.initializedViews.has('journal')) {
                            this.initializedViews.add('journal');
                            initJournalEntry();
                        }
                        break;
                    case 'chat':
                        // Re-initialize chat functionality if needed
                        if (typeof initializeMessageInput === 'function') {
                            initializeMessageInput();
                        }
                        // Load chat history when entering chat view
                        if (typeof loadChatHistory === 'function') {
                            loadChatHistory();
                        }
                        break;
                }
            }

            getCurrentView() {
                return this.currentView;
            }
            
            // Method to reset initialized views if needed (e.g., on logout/login)
            resetInitializedViews() {
                this.initializedViews = new Set();
            }
        }

        // Initialize router when DOM is ready
        let appRouter;
        
        // Function to initialize the router (called after authentication)
        function initRouter() {
            if (!appRouter) {
                appRouter = new AppRouter();
                console.log('Router initialized successfully');
            }
        }

        // Make router globally accessible
        window.navigateTo = function(viewName) {
            if (appRouter) {
                appRouter.navigateToView(viewName);
            }
        };
    </script>

    <!-- User Profile and API Client -->
    <script>
        // API Client for User Profile and other endpoints
        class ApiClient {
            constructor() {
                this.baseUrl = API_CONFIG.backendUrl + '/v1/agent';
            }

            async makeRequest(endpoint, options = {}) {
                const url = `${this.baseUrl}${endpoint}`;
                const token = keycloakInstance?.token || localStorage.getItem('token');
                
                const headers = {
                    'Content-Type': 'application/json',
                    ...options.headers
                };
                
                if (token) {
                    headers['Authorization'] = `Bearer ${token}`;
                }
                
                try {
                    const response = await fetch(url, {
                        ...options,
                        headers
                    });
                    
                    // Handle 401 (token expired)
                    if (response.status === 401) {
                        console.log('Token expired, attempting refresh...');
                        const newToken = await this.refreshTokenIfNeeded();
                        if (newToken) {
                            headers['Authorization'] = `Bearer ${newToken}`;
                            return fetch(url, { ...options, headers });
                        } else {
                            throw new Error('Authentication failed');
                        }
                    }
                    
                    return response;
                } catch (error) {
                    console.error('API request failed:', error);
                    throw error;
                }
            }

            async refreshTokenIfNeeded() {
                if (typeof refreshTokenAfterExpiry === 'function') {
                    try {
                        return await refreshTokenAfterExpiry();
                    } catch (error) {
                        console.error('Token refresh failed:', error);
                        return null;
                    }
                }
                return null;
            }

            // User Profile endpoints
            async getUserProfile() {
                const response = await this.makeRequest('/user/profile');
                if (response.ok) {
                    return await response.json();
                } else {
                    throw new Error(`Failed to fetch user profile: ${response.status}`);
                }
            }

            // Mood endpoints
            async getMoodHistory(page = 0, size = 20) {
                const response = await this.makeRequest(`/mood/history?page=${page}&size=${size}`);
                if (response.ok) {
                    return await response.json();
                } else {
                    throw new Error(`Failed to fetch mood history: ${response.status}`);
                }
            }

            async getMoodTrends(startDate, endDate) {
                let url = '/mood/trends';
                const params = new URLSearchParams();
                if (startDate) params.append('startDate', startDate);
                if (endDate) params.append('endDate', endDate);
                if (params.toString()) url += '?' + params.toString();
                
                const response = await this.makeRequest(url);
                if (response.ok) {
                    return await response.json();
                } else {
                    throw new Error(`Failed to fetch mood trends: ${response.status}`);
                }
            }

            async createMoodEntry(moodData) {
                const response = await this.makeRequest('/mood', {
                    method: 'POST',
                    body: JSON.stringify(moodData)
                });
                if (response.ok) {
                    return await response.json();
                } else {
                    throw new Error(`Failed to create mood entry: ${response.status}`);
                }
            }

            // Journal endpoints
            async getJournalEntries(page = 0, size = 20) {
                const response = await this.makeRequest(`/journal?page=${page}&size=${size}`);
                if (response.ok) {
                    return await response.json();
                } else {
                    throw new Error(`Failed to fetch journal entries: ${response.status}`);
                }
            }

            async createJournalEntry(journalData) {
                const response = await this.makeRequest('/journal', {
                    method: 'POST',
                    body: JSON.stringify(journalData)
                });
                if (response.ok) {
                    return await response.json();
                } else {
                    throw new Error(`Failed to create journal entry: ${response.status}`);
                }
            }

            async updateJournalEntry(code, journalData) {
                const response = await this.makeRequest(`/journal/${code}`, {
                    method: 'PUT',
                    body: JSON.stringify(journalData)
                });
                if (response.ok) {
                    return await response.json();
                } else {
                    throw new Error(`Failed to update journal entry: ${response.status}`);
                }
            }

            async deleteJournalEntry(code) {
                const response = await this.makeRequest(`/journal/${code}`, {
                    method: 'DELETE'
                });
                if (!response.ok) {
                    throw new Error(`Failed to delete journal entry: ${response.status}`);
                }
            }

            async searchJournalEntries(query) {
                const response = await this.makeRequest(`/journal/search?query=${encodeURIComponent(query)}`);
                if (response.ok) {
                    return await response.json();
                } else {
                    throw new Error(`Failed to search journal entries: ${response.status}`);
                }
            }
        }

        // Global API client instance
        const apiClient = new ApiClient();

        // User Profile Management
        let userProfile = null;

        async function loadUserProfile() {
            try {
                console.log('Loading user profile...');
                userProfile = await apiClient.getUserProfile();
                updateUserProfileDisplay();
                console.log('User profile loaded successfully:', userProfile);
            } catch (error) {
                console.error('Failed to load user profile:', error);
                // Show fallback if profile loading fails
                updateUserProfileDisplay({
                    username: 'User',
                    email: 'user@example.com',
                    therapyStatus: 'ACTIVE'
                });
            }
        }

        function updateUserProfileDisplay(profile = userProfile) {
            if (!profile) return;
            
            // Update header display
            const userAvatar = document.getElementById('userAvatar');
            const userName = document.getElementById('userName');
            const userInfo = document.getElementById('userInfo');
            const dashboardUserName = document.getElementById('dashboardUserName');
            
            if (userAvatar && profile.username) {
                // Create initials from username
                const initials = profile.username
                    .split(' ')
                    .map(name => name.charAt(0))
                    .join('')
                    .toUpperCase()
                    .slice(0, 2);
                userAvatar.textContent = initials;
            }
            
            if (userName) {
                userName.textContent = profile.username || 'User';
            }
            
            if (userInfo) {
                userInfo.textContent = profile.email || '';
            }
            
            if (dashboardUserName) {
                dashboardUserName.textContent = profile.username || 'User';
            }
        }

        // Initialize user profile loading (called after authentication)
        function initUserProfile() {
            if (window.mainAppInitialized) {
                loadUserProfile();
            }
        }
    </script>

    <!-- Dashboard Module -->
    <script>
        // Dashboard functionality
        let dashboardData = {
            recentMood: null,
            journalCount: 0,
            recentMoodEntries: [],
            recentJournalEntries: []
        };

        async function initDashboard() {
            console.log('Initializing dashboard...');
            await loadDashboardData();
            updateDashboardDisplay();
        }

        async function loadDashboardData() {
            try {
                // Load recent mood entries (last 30 for analysis)
                const moodHistory = await apiClient.getMoodHistory(0, 30);
                dashboardData.recentMoodEntries = moodHistory.content || [];
                if (dashboardData.recentMoodEntries.length > 0) {
                    dashboardData.recentMood = dashboardData.recentMoodEntries[0];
                }

                // Load recent journal entries
                const journalHistory = await apiClient.getJournalEntries(0, 20);
                dashboardData.recentJournalEntries = journalHistory.content || [];
                dashboardData.journalCount = journalHistory.totalElements || 0;

                // Calculate analytics
                dashboardData.analytics = calculateMoodAnalytics(dashboardData.recentMoodEntries);
                dashboardData.streak = calculateActivityStreak(dashboardData.recentMoodEntries, dashboardData.recentJournalEntries);

                console.log('Dashboard data loaded successfully:', dashboardData);
            } catch (error) {
                console.error('Failed to load dashboard data:', error);
                // Use fallback data
                dashboardData = {
                    recentMood: null,
                    journalCount: 0,
                    recentMoodEntries: [],
                    recentJournalEntries: [],
                    analytics: { weeklyAverage: 0, trend: 'neutral', last7Days: [] },
                    streak: 0
                };
            }
        }

        function updateDashboardDisplay() {
            // Update mood score
            const recentMoodScore = document.getElementById('recentMoodScore');
            const recentMoodDate = document.getElementById('recentMoodDate');
            
            if (dashboardData.recentMood) {
                if (recentMoodScore) {
                    const emoji = getMoodEmoji(dashboardData.recentMood.moodScore);
                    recentMoodScore.textContent = `${emoji} ${dashboardData.recentMood.moodScore}`;
                }
                if (recentMoodDate) {
                    const date = new Date(dashboardData.recentMood.createdAt);
                    recentMoodDate.textContent = date.toLocaleDateString();
                }
            } else {
                if (recentMoodScore) recentMoodScore.textContent = '😐 -';
                if (recentMoodDate) recentMoodDate.textContent = 'No entries today';
            }

            // Update 7-day average and trend
            const weeklyMoodAvg = document.getElementById('weeklyMoodAvg');
            const moodTrendIcon = document.getElementById('moodTrendIcon');
            const moodTrendText = document.getElementById('moodTrendText');
            
            if (weeklyMoodAvg && dashboardData.analytics) {
                weeklyMoodAvg.textContent = dashboardData.analytics.weeklyAverage.toFixed(1);
                
                if (moodTrendIcon) {
                    moodTrendIcon.textContent = dashboardData.analytics.trend === 'improving' ? '📈' : 
                                               dashboardData.analytics.trend === 'declining' ? '📉' : '📊';
                }
                
                if (moodTrendText) {
                    moodTrendText.textContent = dashboardData.analytics.trend === 'improving' ? 'Trending up!' :
                                               dashboardData.analytics.trend === 'declining' ? 'Needs attention' : 'Stable';
                }
            }

            // Update journal count
            const journalCount = document.getElementById('journalCount');
            if (journalCount) {
                journalCount.textContent = dashboardData.journalCount;
            }

            // Update streak
            const streakCount = document.getElementById('streakCount');
            const streakText = document.getElementById('streakText');
            if (streakCount) {
                streakCount.textContent = dashboardData.streak;
            }
            if (streakText) {
                streakText.textContent = dashboardData.streak === 1 ? 'Day active' : 'Days active';
            }

            // Update mood chart
            updateMoodChart();
            
            // Update daily insight
            updateDailyInsight();

            // Update recent mood entries
            updateRecentMoodDisplay();

            // Update recent journal entries
            updateRecentJournalDisplay();
        }


        function updateRecentMoodDisplay() {
            const container = document.getElementById('recentMoodEntries');
            if (!container) return;

            if (dashboardData.recentMoodEntries.length === 0) {
                container.innerHTML = '<div style="color: #666; font-style: italic;">No mood entries yet</div>';
                return;
            }

            const entriesHtml = dashboardData.recentMoodEntries.map(entry => {
                const date = new Date(entry.createdAt);
                const moodEmoji = getMoodEmoji(entry.moodScore);
                return `
                    <div style="padding: 8px 0; border-bottom: 1px solid #f0f0f0; display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <span style="font-size: 18px; margin-right: 8px;">${moodEmoji}</span>
                            <span style="font-weight: 500;">${entry.moodScore}/10</span>
                            ${entry.notes ? `<div style="font-size: 12px; color: #666; margin-top: 2px;">${entry.notes}</div>` : ''}
                        </div>
                        <div style="font-size: 12px; color: #999;">
                            ${date.toLocaleDateString()}
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = entriesHtml;
        }

        function updateRecentJournalDisplay() {
            const container = document.getElementById('recentJournalEntries');
            if (!container) return;

            if (dashboardData.recentJournalEntries.length === 0) {
                container.innerHTML = '<div style="color: #666; font-style: italic;">No journal entries yet</div>';
                return;
            }

            const entriesHtml = dashboardData.recentJournalEntries.map(entry => {
                const date = new Date(entry.createdAt);
                const preview = entry.content ? entry.content.substring(0, 100) + '...' : '';
                return `
                    <div style="padding: 8px 0; border-bottom: 1px solid #f0f0f0;">
                        <div style="font-weight: 500; margin-bottom: 4px;">${entry.title || 'Untitled'}</div>
                        <div style="font-size: 12px; color: #666; margin-bottom: 4px;">${preview}</div>
                        <div style="font-size: 12px; color: #999;">
                            ${date.toLocaleDateString()}
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = entriesHtml;
        }

        function getMoodEmoji(score) {
            if (score >= 9) return '😄';
            if (score >= 7) return '😊';
            if (score >= 6) return '🙂';
            if (score >= 5) return '😐';
            if (score >= 3) return '🙁';
            if (score >= 2) return '😞';
            return '😢';
        }

        // Analytics Functions
        function calculateMoodAnalytics(moodEntries) {
            if (!moodEntries || moodEntries.length === 0) {
                return { weeklyAverage: 0, trend: 'neutral', last7Days: [] };
            }

            // Get last 7 days of data
            const now = new Date();
            const last7Days = [];
            
            for (let i = 6; i >= 0; i--) {
                const date = new Date(now);
                date.setDate(date.getDate() - i);
                const dayStart = new Date(date.setHours(0, 0, 0, 0));
                const dayEnd = new Date(date.setHours(23, 59, 59, 999));
                
                const dayEntries = moodEntries.filter(entry => {
                    const entryDate = new Date(entry.createdAt);
                    return entryDate >= dayStart && entryDate <= dayEnd;
                });
                
                const dayAverage = dayEntries.length > 0 
                    ? dayEntries.reduce((sum, entry) => sum + entry.moodScore, 0) / dayEntries.length 
                    : null;
                
                last7Days.push({
                    date: dayStart,
                    average: dayAverage,
                    count: dayEntries.length
                });
            }

            // Calculate weekly average
            const validDays = last7Days.filter(day => day.average !== null);
            const weeklyAverage = validDays.length > 0 
                ? validDays.reduce((sum, day) => sum + day.average, 0) / validDays.length 
                : 0;

            // Determine trend
            let trend = 'neutral';
            if (validDays.length >= 2) {
                const firstHalf = validDays.slice(0, Math.ceil(validDays.length / 2));
                const secondHalf = validDays.slice(Math.floor(validDays.length / 2));
                
                const firstAvg = firstHalf.reduce((sum, day) => sum + day.average, 0) / firstHalf.length;
                const secondAvg = secondHalf.reduce((sum, day) => sum + day.average, 0) / secondHalf.length;
                
                if (secondAvg > firstAvg + 0.5) trend = 'improving';
                else if (secondAvg < firstAvg - 0.5) trend = 'declining';
            }

            return { weeklyAverage, trend, last7Days };
        }

        function calculateActivityStreak(moodEntries, journalEntries) {
            const now = new Date();
            let streak = 0;
            
            for (let i = 0; i < 30; i++) { // Check last 30 days
                const date = new Date(now);
                date.setDate(date.getDate() - i);
                const dayStart = new Date(date.setHours(0, 0, 0, 0));
                const dayEnd = new Date(date.setHours(23, 59, 59, 999));
                
                const hasMoodEntry = moodEntries.some(entry => {
                    const entryDate = new Date(entry.createdAt);
                    return entryDate >= dayStart && entryDate <= dayEnd;
                });
                
                const hasJournalEntry = journalEntries.some(entry => {
                    const entryDate = new Date(entry.createdAt);
                    return entryDate >= dayStart && entryDate <= dayEnd;
                });
                
                if (hasMoodEntry || hasJournalEntry) {
                    streak++;
                } else {
                    break;
                }
            }
            
            return streak;
        }

        function updateMoodChart() {
            const chartContainer = document.getElementById('moodChart');
            if (!chartContainer || !dashboardData.analytics) return;
            
            const last7Days = dashboardData.analytics.last7Days;
            const maxScore = 10;
            const chartHeight = 160;
            const chartWidth = chartContainer.clientWidth - 40;
            
            if (last7Days.every(day => day.average === null)) {
                chartContainer.innerHTML = '<div style="display: flex; justify-content: center; align-items: center; height: 100%; color: #666;">No mood data for the last 7 days</div>';
                return;
            }
            
            // Create SVG chart
            let chartHTML = `
                <svg width="${chartWidth}" height="${chartHeight}" style="overflow: visible;">
                    <!-- Grid lines -->
                    ${[2, 4, 6, 8, 10].map(val => `
                        <line x1="0" y1="${chartHeight - (val / maxScore) * chartHeight}" 
                              x2="${chartWidth}" y2="${chartHeight - (val / maxScore) * chartHeight}" 
                              stroke="#e5e7eb" stroke-width="1" opacity="0.5"/>
                        <text x="-5" y="${chartHeight - (val / maxScore) * chartHeight + 4}" 
                              fill="#9ca3af" font-size="12" text-anchor="end">${val}</text>
                    `).join('')}
                    
                    <!-- Data line -->
                    <polyline fill="none" stroke="#4a90e2" stroke-width="3" points="${
                        last7Days.map((day, index) => {
                            if (day.average === null) return null;
                            const x = (index / (last7Days.length - 1)) * chartWidth;
                            const y = chartHeight - (day.average / maxScore) * chartHeight;
                            return `${x},${y}`;
                        }).filter(point => point !== null).join(' ')
                    }"/>
                    
                    <!-- Data points -->
                    ${last7Days.map((day, index) => {
                        if (day.average === null) return '';
                        const x = (index / (last7Days.length - 1)) * chartWidth;
                        const y = chartHeight - (day.average / maxScore) * chartHeight;
                        return `<circle cx="${x}" cy="${y}" r="4" fill="#4a90e2"/>`;
                    }).join('')}
                </svg>
                
                <!-- Day labels -->
                <div style="display: flex; justify-content: space-between; margin-top: 10px; font-size: 12px; color: #666;">
                    ${last7Days.map(day => {
                        const dayName = day.date.toLocaleDateString('en', { weekday: 'short' });
                        return `<span style="text-align: center;">${dayName}</span>`;
                    }).join('')}
                </div>
            `;
            
            chartContainer.innerHTML = chartHTML;
        }

        function updateDailyInsight() {
            const insightContainer = document.getElementById('dailyInsight');
            const additionalContainer = document.getElementById('additionalInsights');
            if (!insightContainer) return;
            
            const allInsights = generateDataDrivenInsights();
            
            if (allInsights.length > 0) {
                // Show primary insight
                insightContainer.textContent = allInsights[0];
                
                // Show additional insights (up to 2 more)
                if (additionalContainer && allInsights.length > 1) {
                    const additionalInsights = allInsights.slice(1, 3).map(insight => 
                        `• ${insight}`
                    ).join('\n');
                    additionalContainer.textContent = additionalInsights;
                }
            } else {
                insightContainer.textContent = "Track your mood daily to unlock personalized insights about your mental wellness journey.";
                if (additionalContainer) {
                    additionalContainer.textContent = "";
                }
            }
        }

        function generateDailyInsight() {
            // Generate insights based on actual user data
            const insights = generateDataDrivenInsights();
            
            // Return the most relevant insight
            if (insights.length > 0) {
                return insights[0]; // Return the highest priority insight
            }
            
            return "Track your mood daily to unlock personalized insights about your mental wellness journey.";
        }

        function generateDataDrivenInsights() {
            const insights = [];
            
            if (!dashboardData.analytics || dashboardData.recentMoodEntries.length === 0) {
                return insights;
            }
            
            const { trend, weeklyAverage, last7Days } = dashboardData.analytics;
            const moodEntries = dashboardData.recentMoodEntries;
            const journalEntries = dashboardData.recentJournalEntries;
            const streak = dashboardData.streak;
            const todayMood = dashboardData.recentMood;
            
            // 1. Streak-based insights (highest priority)
            if (streak >= 14) {
                insights.push(`🔥 Outstanding! ${streak} days of consistent tracking. You're building powerful mental health habits!`);
            } else if (streak >= 7) {
                insights.push(`🎉 Amazing! You've been active for ${streak} days straight. Your dedication to mental wellness is inspiring!`);
            } else if (streak >= 3) {
                insights.push(`💪 Great momentum! ${streak} days in a row. Consistency is key to mental wellness.`);
            }
            
            // 2. Trend analysis insights
            if (trend === 'improving' && weeklyAverage > 6) {
                insights.push(`📈 Excellent! Your mood is trending upward with a ${weeklyAverage.toFixed(1)} average. You're thriving!`);
            } else if (trend === 'improving') {
                insights.push(`📈 Your mood has been improving this week! Keep up the positive momentum.`);
            } else if (trend === 'declining' && weeklyAverage < 4) {
                insights.push(`💙 Your recent scores suggest you might need extra support. Consider reaching out or practicing self-care.`);
            } else if (trend === 'declining') {
                insights.push(`📉 Your mood has dipped recently. Remember, it's normal to have ups and downs.`);
            }
            
            // 3. Today's mood insights
            if (todayMood) {
                if (todayMood.moodScore >= 9) {
                    insights.push(`✨ You're having an exceptional day! This energy is perfect for tackling goals or helping others.`);
                } else if (todayMood.moodScore >= 8) {
                    insights.push(`🌟 You're feeling great today! Consider journaling about what's working well in your life.`);
                } else if (todayMood.moodScore <= 2) {
                    insights.push(`🤗 Today feels tough. Your feelings are valid, and reaching out for support is a sign of strength.`);
                } else if (todayMood.moodScore <= 3) {
                    insights.push(`💙 Tough days are part of the journey. Small acts of self-care can make a difference.`);
                }
                
                // Notes-based insights
                if (todayMood.notes && todayMood.notes.length > 20) {
                    insights.push(`📝 Great job adding detailed notes today! Self-reflection helps build emotional awareness.`);
                }
            }
            
            // 4. Weekly performance insights
            if (weeklyAverage >= 8) {
                insights.push(`🌟 Your weekly average of ${weeklyAverage.toFixed(1)} shows excellent mental wellness! You're doing great.`);
            } else if (weeklyAverage >= 7) {
                insights.push(`😊 Your ${weeklyAverage.toFixed(1)} weekly average shows you're managing your wellness well. Keep it up!`);
            } else if (weeklyAverage >= 5) {
                insights.push(`📊 Your ${weeklyAverage.toFixed(1)} average shows room for growth. Small daily practices can help.`);
            }
            
            // 5. Journaling insights
            const recentJournals = journalEntries.slice(0, 7); // Last 7 entries
            if (recentJournals.length >= 3) {
                const moodImprovements = recentJournals.filter(entry => 
                    entry.moodAfter && entry.moodBefore && entry.moodAfter > entry.moodBefore
                ).length;
                
                if (moodImprovements >= 2) {
                    insights.push(`📖 Journaling is really helping! ${moodImprovements} of your recent entries show mood improvement.`);
                }
            }
            
            if (journalEntries.length >= 5) {
                insights.push(`🖊️ You've written ${journalEntries.length} journal entries! Writing is a powerful tool for mental clarity.`);
            }
            
            // 6. Consistency insights
            const daysWithEntries = last7Days.filter(day => day.count > 0).length;
            if (daysWithEntries >= 5) {
                insights.push(`🗓️ You've tracked your mood ${daysWithEntries} out of 7 days this week. Excellent consistency!`);
            } else if (daysWithEntries >= 3) {
                insights.push(`📅 You've been active ${daysWithEntries} days this week. Try for daily check-ins to see more patterns.`);
            }
            
            // 7. Pattern recognition insights
            const lowMoodDays = moodEntries.filter(entry => entry.moodScore <= 4).length;
            const highMoodDays = moodEntries.filter(entry => entry.moodScore >= 7).length;
            
            if (highMoodDays > lowMoodDays * 2) {
                insights.push(`🌈 You have more high-mood days than low ones recently. You're building resilience!`);
            }
            
            // 8. Engagement insights
            if (moodEntries.length >= 10) {
                insights.push(`📊 With ${moodEntries.length} mood entries, you're building valuable data for self-understanding.`);
            }
            
            // Sort insights by priority (streak > trend > today > weekly > others)
            return insights;
        }

    </script>

    <!-- Mood Tracking Module -->
    <script>
        // Mood tracking functionality
        let moodHistoryData = [];
        let selectedMoodTags = [];

        function initMoodTracking() {
            console.log('Initializing mood tracking...');
            setupMoodSlider();
            setupMoodTags();
            setupMoodForm();
            loadMoodHistory();
        }

        function setupMoodSlider() {
            const moodSlider = document.getElementById('moodSlider');
            const moodEmoji = document.getElementById('moodEmoji');
            const moodScoreDisplay = document.getElementById('moodScoreDisplay');

            if (moodSlider) {
                moodSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    updateMoodDisplay(value);
                });
            }
        }

        function updateMoodDisplay(score) {
            const moodEmoji = document.getElementById('moodEmoji');
            const moodScoreDisplay = document.getElementById('moodScoreDisplay');

            if (moodEmoji) {
                moodEmoji.textContent = getMoodEmoji(score);
            }
            if (moodScoreDisplay) {
                moodScoreDisplay.textContent = score;
            }
        }

        function setupMoodTags() {
            const moodTags = document.querySelectorAll('.mood-tag');
            moodTags.forEach(tag => {
                tag.addEventListener('click', () => {
                    const tagValue = tag.getAttribute('data-tag');
                    toggleMoodTag(tag, tagValue);
                });
            });
        }

        function toggleMoodTag(tagElement, tagValue) {
            if (tagElement.classList.contains('selected')) {
                tagElement.classList.remove('selected');
                selectedMoodTags = selectedMoodTags.filter(tag => tag !== tagValue);
            } else {
                tagElement.classList.add('selected');
                selectedMoodTags.push(tagValue);
            }
        }

        function setupMoodForm() {
            const moodForm = document.getElementById('moodEntryForm');
            if (moodForm) {
                moodForm.addEventListener('submit', handleMoodSubmit);
            }
        }

        async function handleMoodSubmit(e) {
            e.preventDefault();
            
            const moodSlider = document.getElementById('moodSlider');
            const moodNotes = document.getElementById('moodNotes');
            const saveBtn = document.getElementById('saveMoodBtn');

            if (!moodSlider) return;

            const moodData = {
                moodScore: parseInt(moodSlider.value),
                moodTags: selectedMoodTags,
                notes: moodNotes ? moodNotes.value.trim() : ''
            };

            // Disable button and show loading state
            saveBtn.disabled = true;
            saveBtn.textContent = 'Saving...';

            try {
                await apiClient.createMoodEntry(moodData);
                console.log('Mood entry saved successfully');
                
                // Reset form
                resetMoodForm();
                
                // Reload mood history
                await loadMoodHistory();
                
                // Show success message
                showMoodMessage('Mood entry saved successfully!', 'success');
                
            } catch (error) {
                console.error('Failed to save mood entry:', error);
                showMoodMessage('Failed to save mood entry. Please try again.', 'error');
            } finally {
                // Re-enable button
                saveBtn.disabled = false;
                saveBtn.textContent = 'Save Mood Entry';
            }
        }

        function resetMoodForm() {
            const moodSlider = document.getElementById('moodSlider');
            const moodNotes = document.getElementById('moodNotes');
            const moodTags = document.querySelectorAll('.mood-tag');

            if (moodSlider) {
                moodSlider.value = 5;
                updateMoodDisplay(5);
            }

            if (moodNotes) {
                moodNotes.value = '';
            }

            // Clear selected tags
            moodTags.forEach(tag => tag.classList.remove('selected'));
            selectedMoodTags = [];
        }

        async function loadMoodHistory() {
            const container = document.getElementById('moodHistoryContainer');
            if (!container) return;

            try {
                container.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">Loading mood history...</div>';
                
                const historyData = await apiClient.getMoodHistory(0, 20);
                moodHistoryData = historyData.content || [];
                
                displayMoodHistory();
                
            } catch (error) {
                console.error('Failed to load mood history:', error);
                container.innerHTML = '<div style="text-align: center; color: #ef4444; padding: 20px;">Failed to load mood history</div>';
            }
        }

        function displayMoodHistory() {
            const container = document.getElementById('moodHistoryContainer');
            if (!container) return;

            if (moodHistoryData.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No mood entries yet. Start tracking your mood above!</div>';
                return;
            }

            const historyHtml = moodHistoryData.map(entry => {
                const date = new Date(entry.createdAt);
                const moodEmoji = getMoodEmoji(entry.moodScore);
                const tagsHtml = entry.moodTags && entry.moodTags.length > 0 
                    ? entry.moodTags.map(tag => `<span style="background: #f3f4f6; color: #374151; padding: 2px 8px; border-radius: 12px; font-size: 12px; margin-right: 4px;">${tag}</span>`).join('')
                    : '';

                return `
                    <div style="border: 1px solid #e5e7eb; border-radius: 10px; padding: 20px; margin-bottom: 15px; background: #fafafa;">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                            <div style="display: flex; align-items: center; gap: 12px;">
                                <span style="font-size: 2rem;">${moodEmoji}</span>
                                <div>
                                    <div style="font-size: 1.2rem; font-weight: 600; color: #333;">${entry.moodScore}/10</div>
                                    <div style="font-size: 12px; color: #666;">${date.toLocaleString()}</div>
                                </div>
                            </div>
                        </div>
                        ${tagsHtml ? `<div style="margin-bottom: 10px;">${tagsHtml}</div>` : ''}
                        ${entry.notes ? `<div style="color: #555; font-size: 14px; line-height: 1.5;">${entry.notes}</div>` : ''}
                    </div>
                `;
            }).join('');

            container.innerHTML = historyHtml;
        }

        function showMoodMessage(message, type = 'info') {
            // Create or update message element
            let messageEl = document.getElementById('moodMessage');
            if (!messageEl) {
                messageEl = document.createElement('div');
                messageEl.id = 'moodMessage';
                messageEl.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    padding: 12px 20px;
                    border-radius: 8px;
                    color: white;
                    font-weight: 500;
                    z-index: 1000;
                    opacity: 0;
                    transform: translateY(-20px);
                    transition: all 0.3s ease;
                `;
                document.body.appendChild(messageEl);
            }

            // Set message and style based on type
            messageEl.textContent = message;
            messageEl.style.background = type === 'success' ? '#10b981' : type === 'error' ? '#ef4444' : '#3b82f6';

            // Show message
            setTimeout(() => {
                messageEl.style.opacity = '1';
                messageEl.style.transform = 'translateY(0)';
            }, 10);

            // Hide message after 3 seconds
            setTimeout(() => {
                messageEl.style.opacity = '0';
                messageEl.style.transform = 'translateY(-20px)';
            }, 3000);
        }

        // Note: Mood tracking initialization is now handled by the main navigation system
        // Removed duplicate hash change listener to prevent double API calls
    </script>

    <!-- Journal Management Module -->
    <script>
        // Journal functionality
        let journalData = [];
        let currentEditingEntry = null;

        function initJournalEntry() {
            console.log('Initializing journal entry...');
            setupJournalForm();
            setupJournalSearch();
            loadJournalEntries();
        }

        function setupJournalForm() {
            const journalForm = document.getElementById('journalEntryForm');
            if (journalForm) {
                journalForm.addEventListener('submit', handleJournalSubmit);
            }
        }

        function setupJournalSearch() {
            const searchInput = document.getElementById('journalSearch');
            if (searchInput) {
                searchInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        searchJournalEntries();
                    }
                });
            }
        }

        function showNewJournalForm() {
            currentEditingEntry = null;
            const form = document.getElementById('journalForm');
            const title = document.getElementById('journalFormTitle');
            
            if (form) form.style.display = 'block';
            if (title) title.textContent = 'Create New Journal Entry';
            
            resetJournalForm();
            
            // Scroll to form
            form.scrollIntoView({ behavior: 'smooth' });
        }

        function hideJournalForm() {
            const form = document.getElementById('journalForm');
            if (form) form.style.display = 'none';
            currentEditingEntry = null;
        }

        function editJournalEntry(entry) {
            currentEditingEntry = entry;
            const form = document.getElementById('journalForm');
            const title = document.getElementById('journalFormTitle');
            
            if (form) form.style.display = 'block';
            if (title) title.textContent = 'Edit Journal Entry';
            
            // Fill form with entry data
            document.getElementById('journalEntryCode').value = entry.code || '';
            document.getElementById('journalTitle').value = entry.title || '';
            document.getElementById('journalContent').value = entry.content || '';
            document.getElementById('moodBefore').value = entry.moodBefore || '';
            document.getElementById('moodAfter').value = entry.moodAfter || '';
            document.getElementById('journalTags').value = entry.tags ? entry.tags.join(', ') : '';
            
            // Scroll to form
            form.scrollIntoView({ behavior: 'smooth' });
        }

        function resetJournalForm() {
            document.getElementById('journalEntryCode').value = '';
            document.getElementById('journalTitle').value = '';
            document.getElementById('journalContent').value = '';
            document.getElementById('moodBefore').value = '';
            document.getElementById('moodAfter').value = '';
            document.getElementById('journalTags').value = '';
        }

        async function handleJournalSubmit(e) {
            e.preventDefault();
            
            const saveBtn = document.getElementById('saveJournalBtn');
            const entryCode = document.getElementById('journalEntryCode').value;
            const title = document.getElementById('journalTitle').value.trim();
            const content = document.getElementById('journalContent').value.trim();
            const moodBefore = document.getElementById('moodBefore').value;
            const moodAfter = document.getElementById('moodAfter').value;
            const tagsInput = document.getElementById('journalTags').value.trim();

            if (!content) {
                showJournalMessage('Please enter some content for your journal entry.', 'error');
                return;
            }

            const journalData = {
                title: title || null,
                content: content,
                moodBefore: moodBefore ? parseInt(moodBefore) : null,
                moodAfter: moodAfter ? parseInt(moodAfter) : null,
                tags: tagsInput ? tagsInput.split(',').map(tag => tag.trim()).filter(tag => tag) : []
            };

            // Disable button and show loading state
            saveBtn.disabled = true;
            saveBtn.textContent = currentEditingEntry ? 'Updating...' : 'Saving...';

            try {
                if (currentEditingEntry && entryCode) {
                    // Update existing entry
                    await apiClient.updateJournalEntry(entryCode, journalData);
                    console.log('Journal entry updated successfully');
                    showJournalMessage('Journal entry updated successfully!', 'success');
                } else {
                    // Create new entry
                    await apiClient.createJournalEntry(journalData);
                    console.log('Journal entry created successfully');
                    showJournalMessage('Journal entry saved successfully!', 'success');
                }
                
                // Reset form and hide
                resetJournalForm();
                hideJournalForm();
                
                // Reload journal entries
                await loadJournalEntries();
                
            } catch (error) {
                console.error('Failed to save journal entry:', error);
                showJournalMessage('Failed to save journal entry. Please try again.', 'error');
            } finally {
                // Re-enable button
                saveBtn.disabled = false;
                saveBtn.textContent = 'Save Entry';
            }
        }

        async function loadJournalEntries() {
            const container = document.getElementById('journalHistoryContainer');
            if (!container) return;

            try {
                container.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">Loading journal entries...</div>';
                
                const entriesData = await apiClient.getJournalEntries(0, 50);
                journalData = entriesData.content || [];
                
                displayJournalEntries(journalData);
                
            } catch (error) {
                console.error('Failed to load journal entries:', error);
                container.innerHTML = '<div style="text-align: center; color: #ef4444; padding: 20px;">Failed to load journal entries</div>';
            }
        }

        async function searchJournalEntries() {
            const searchInput = document.getElementById('journalSearch');
            const query = searchInput ? searchInput.value.trim() : '';
            
            if (!query) {
                loadJournalEntries();
                return;
            }

            const container = document.getElementById('journalHistoryContainer');
            if (!container) return;

            try {
                container.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">Searching...</div>';
                
                const searchResults = await apiClient.searchJournalEntries(query);
                
                displayJournalEntries(searchResults);
                
            } catch (error) {
                console.error('Failed to search journal entries:', error);
                container.innerHTML = '<div style="text-align: center; color: #ef4444; padding: 20px;">Search failed</div>';
            }
        }

        function displayJournalEntries(entries) {
            const container = document.getElementById('journalHistoryContainer');
            if (!container) return;

            if (entries.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No journal entries found. Create your first entry above!</div>';
                return;
            }

            const entriesHtml = entries.map(entry => {
                const date = new Date(entry.createdAt);
                const preview = entry.content ? (entry.content.length > 200 ? entry.content.substring(0, 200) + '...' : entry.content) : '';
                const tagsHtml = entry.tags && entry.tags.length > 0 
                    ? entry.tags.map(tag => `<span style="background: #dbeafe; color: #1d4ed8; padding: 2px 8px; border-radius: 12px; font-size: 12px; margin-right: 4px;">${tag}</span>`).join('')
                    : '';

                const moodInfo = [];
                if (entry.moodBefore) moodInfo.push(`Before: ${entry.moodBefore}/10`);
                if (entry.moodAfter) moodInfo.push(`After: ${entry.moodAfter}/10`);
                const moodText = moodInfo.length > 0 ? moodInfo.join(' • ') : '';

                return `
                    <div style="border: 1px solid #e5e7eb; border-radius: 10px; padding: 20px; margin-bottom: 15px; background: #fafafa;">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                            <div style="flex: 1;">
                                <h3 style="margin: 0 0 8px 0; color: #333; font-size: 1.1rem;">${entry.title || 'Untitled'}</h3>
                                <div style="color: #666; font-size: 12px; margin-bottom: 8px;">
                                    ${date.toLocaleString()} ${moodText ? `• ${moodText}` : ''}
                                </div>
                                ${tagsHtml ? `<div style="margin-bottom: 10px;">${tagsHtml}</div>` : ''}
                            </div>
                            <div style="display: flex; gap: 8px; margin-left: 16px;">
                                <button onclick="editJournalEntry(${JSON.stringify(entry).replace(/"/g, '&quot;')})" 
                                        style="padding: 6px 12px; background: #f3f4f6; color: #374151; border: none; border-radius: 6px; cursor: pointer; font-size: 12px;">
                                    Edit
                                </button>
                                <button onclick="deleteJournalEntry('${entry.code}')" 
                                        style="padding: 6px 12px; background: #fee; color: #dc2626; border: none; border-radius: 6px; cursor: pointer; font-size: 12px;">
                                    Delete
                                </button>
                            </div>
                        </div>
                        <div style="color: #555; line-height: 1.6; white-space: pre-wrap;">${preview}</div>
                    </div>
                `;
            }).join('');

            container.innerHTML = entriesHtml;
        }

        async function deleteJournalEntry(entryCode) {
            if (!confirm('Are you sure you want to delete this journal entry? This action cannot be undone.')) {
                return;
            }

            try {
                await apiClient.deleteJournalEntry(entryCode);
                console.log('Journal entry deleted successfully');
                showJournalMessage('Journal entry deleted successfully.', 'success');
                
                // Reload journal entries
                await loadJournalEntries();
                
            } catch (error) {
                console.error('Failed to delete journal entry:', error);
                showJournalMessage('Failed to delete journal entry. Please try again.', 'error');
            }
        }

        function showJournalMessage(message, type = 'info') {
            // Create or update message element
            let messageEl = document.getElementById('journalMessage');
            if (!messageEl) {
                messageEl = document.createElement('div');
                messageEl.id = 'journalMessage';
                messageEl.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    padding: 12px 20px;
                    border-radius: 8px;
                    color: white;
                    font-weight: 500;
                    z-index: 1000;
                    opacity: 0;
                    transform: translateY(-20px);
                    transition: all 0.3s ease;
                `;
                document.body.appendChild(messageEl);
            }

            // Set message and style based on type
            messageEl.textContent = message;
            messageEl.style.background = type === 'success' ? '#10b981' : type === 'error' ? '#ef4444' : '#3b82f6';

            // Show message
            setTimeout(() => {
                messageEl.style.opacity = '1';
                messageEl.style.transform = 'translateY(0)';
            }, 10);

            // Hide message after 3 seconds
            setTimeout(() => {
                messageEl.style.opacity = '0';
                messageEl.style.transform = 'translateY(-20px)';
            }, 3000);
        }
    </script>

    <script>
        // WebSocket connection (authentication variables are in the first script block)
        let stompClient = null;
        let connected = false;
        let connectionAttempts = 0;
        const maxRetries = 5;
        
        // Make connected status globally accessible
        window.getConnectionStatus = function() {
            return connected;
        };
        
        // Session tracking
        let sessionStartTime = Date.now();
        let messageCount = 0;
        let lastMessageTime = null; // Track last message timestamp for gap detection
        
        // Timestamp utilities - optimized for performance
        const TIME_GAP_THRESHOLD = 5 * 60 * 1000; // 5 minutes in milliseconds
        const DAY_MS = 24 * 60 * 60 * 1000; // 1 day in milliseconds
        
        // Cache for formatted timestamps to avoid repeated calculations
        const timestampCache = new Map();
        
        function formatTimestampHeader(timestamp) {
            // Use cache for performance
            const cacheKey = Math.floor(timestamp / 60000); // Cache by minute
            if (timestampCache.has(cacheKey)) {
                return timestampCache.get(cacheKey);
            }
            
            const now = new Date();
            const messageDate = new Date(timestamp);
            const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const yesterdayStart = new Date(todayStart.getTime() - DAY_MS);
            const weekAgo = new Date(todayStart.getTime() - 7 * DAY_MS);
            
            let formatted;
            
            if (messageDate >= todayStart) {
                // Today - just time
                formatted = messageDate.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
            } else if (messageDate >= yesterdayStart) {
                // Yesterday
                formatted = 'Yesterday ' + messageDate.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
            } else if (messageDate >= weekAgo) {
                // This week - day name + time
                formatted = messageDate.toLocaleDateString([], { weekday: 'long' }) + ' ' + 
                           messageDate.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
            } else {
                // Older - date + time
                formatted = messageDate.toLocaleDateString([], { month: 'short', day: 'numeric' }) + ', ' +
                           messageDate.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
            }
            
            // Cache result
            timestampCache.set(cacheKey, formatted);
            
            // Limit cache size for memory efficiency
            if (timestampCache.size > 1000) {
                const firstKey = timestampCache.keys().next().value;
                timestampCache.delete(firstKey);
            }
            
            return formatted;
        }
        
        function shouldShowTimestamp(currentTime, previousTime) {
            if (!previousTime) return true; // First message
            
            const timeDiff = currentTime - previousTime;
            if (timeDiff >= TIME_GAP_THRESHOLD) return true; // 5+ minute gap
            
            // Check if date changed (more precise than simple day comparison)
            const currentDate = new Date(currentTime);
            const previousDate = new Date(previousTime);
            
            return (currentDate.getDate() !== previousDate.getDate() || 
                    currentDate.getMonth() !== previousDate.getMonth() || 
                    currentDate.getFullYear() !== previousDate.getFullYear());
        }
        
        function createTimestampHeader(timestamp) {
            const headerDiv = document.createElement('div');
            headerDiv.className = 'timestamp-header';
            headerDiv.textContent = formatTimestampHeader(timestamp);
            return headerDiv;
        }

        // Note: Keycloak authentication is handled in the first script block above

        // Initialize WebSocket connection with STOMP
        function initWebSocket() {
            try {
                
                stompClient = new StompJs.Client({
                    brokerURL: API_CONFIG.websocketUrl,
                    connectHeaders: getAuthHeaders(),
                    debug: function (str) {
                        console.log('STOMP: ' + str);
                    },
                    reconnectDelay: 5000,
                    heartbeatIncoming: 4000,
                    heartbeatOutgoing: 4000,
                });
                stompClient.onConnect = function (frame) {
                    console.log('STOMP Connected: ' + frame);
                    connected = true;
                    connectionAttempts = 0;
                    
                    // Subscribe to user-specific queue
                    stompClient.subscribe('/user/queue/chat', function (message) {
                        console.log("Raw WebSocket message received:", message.body);
                        try {
                            const chatMessage = JSON.parse(message.body);
                            console.log("Parsed WebSocket message:", chatMessage);
                            handleWebSocketMessage(chatMessage);
                        } catch (error) {
                            console.error('Error parsing WebSocket message:', error);
                            console.error('Raw message body:', message.body);
                            // Try to handle as plain text
                            handleWebSocketMessage({ content: message.body, type: 'chat' });
                        }
                    });
                };

                stompClient.onStompError = function (frame) {
                    console.error('STOMP error: ' + frame.headers['message']);
                    console.error('Details: ' + frame.body);
                    connected = false;
                };

                stompClient.onWebSocketClose = function (event) {
                    console.log('WebSocket connection closed');
                    connected = false;
                    
                    // Attempt to reconnect
                    if (connectionAttempts < maxRetries) {
                        connectionAttempts++;
                        console.log(`Reconnection attempt ${connectionAttempts}/${maxRetries}`);
                        setTimeout(() => {
                            stompClient.activate();
                        }, 2000 * connectionAttempts);
                    }
                };

                stompClient.activate();

            } catch (error) {
                console.error('Failed to create STOMP connection:', error);
            }
        }

        // Removed old sync getAuthHeaders - now using async version below


        function handleWebSocketMessage(message) {
            console.log('Handling WebSocket message:', message);
            
            // Handle incoming WebSocket messages
            if (message.type === 'chat' || message.content) {
                // Display the message content
                const content = message.content || message.message || JSON.stringify(message);
                const messageTime = message.timestamp ? new Date(message.timestamp).getTime() : Date.now();
                addMessage(content, false, messageTime);
            } else {
                // Fallback: treat any message as a chat message
                console.log('Unknown message format, treating as chat:', message);
                const content = message.content || message.message || message.text || JSON.stringify(message);
                addMessage(content, false, Date.now());
            }
        }

        function sendWebSocketMessage(content) {
            if (stompClient && connected) {
                const message = {
                    content: content,
                    timestamp: new Date(),
                    type: 'user'
                };
                
                stompClient.publish({
                    destination: '/app/agent/conversation',
                    body: JSON.stringify(message)
                });
                return true;
            }
            return false;
        }



        function formatMarkdown(text) {
            try {
                // Use the marked library for proper markdown parsing
                if (typeof marked !== 'undefined') {
                    // Configure marked for inline parsing
                    marked.setOptions({
                        breaks: true,
                        gfm: true
                    });
                    return marked.parse(text);
                } else {
                    // Fallback to simple formatting if marked isn't available
                    return simpleMarkdownFormat(text);
                }
            } catch (error) {
                console.error('Error formatting markdown:', error);
                return simpleMarkdownFormat(text);
            }
        }

        function simpleMarkdownFormat(text) {
            // Simple fallback formatting
            let formatted = text;
            
            // Convert **bold**
            formatted = formatted.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            
            // Convert *italic*
            formatted = formatted.replace(/\*([^*\n]+?)\*/g, '<em>$1</em>');
            
            // Convert bullet points
            formatted = formatted.replace(/^\* (.+)$/gm, '• $1');
            
            // Convert line breaks
            formatted = formatted.replace(/\n/g, '<br>');
            
            // Wrap in paragraph if needed
            if (!formatted.includes('<p>') && !formatted.includes('<ul>')) {
                formatted = '<p>' + formatted + '</p>';
            }
            
            return formatted;
        }

        function addMessage(content, isUser = false, messageTime = null) {
            const messagesContainer = document.getElementById('messages');
            if (!messagesContainer) return;
            
            const currentTime = messageTime || Date.now();
            
            // Check if we need to show a timestamp header
            if (shouldShowTimestamp(currentTime, lastMessageTime)) {
                const timestampHeader = createTimestampHeader(currentTime);
                messagesContainer.appendChild(timestampHeader);
            }
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isUser ? 'user' : 'agent'}`;
            messageDiv.setAttribute('data-timestamp', currentTime); // Store for potential future use

            // Format content with markdown support
            const formattedContent = isUser ? content : formatMarkdown(content);

            messageDiv.innerHTML = `
                <div class="message-content">
                    ${formattedContent}
                </div>
            `;

            messagesContainer.appendChild(messageDiv);
            
            // Update last message time for gap detection
            lastMessageTime = currentTime;
            
            // Optimized scroll - use requestAnimationFrame for better performance
            requestAnimationFrame(() => {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            });

            if (isUser) {
                messageCount++;
            }
        }

        function showTypingIndicator() {
            document.getElementById('typingIndicator').classList.add('active');
            const messagesContainer = document.getElementById('messages');
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function hideTypingIndicator() {
            document.getElementById('typingIndicator').classList.remove('active');
        }


        function sendMessage() {
            const input = document.getElementById('messageInput');
            const message = input.value.trim();

            if (!message) return;

            // Add user message with current timestamp
            const userMessageTime = Date.now();
            addMessage(message, true, userMessageTime);
            
            // Clear input and reset to auto height
            input.value = '';
            input.style.height = 'auto';
            updateSendButton(); // Update send button state
            input.focus(); // Keep focus for next message

            // Try to send via WebSocket first
            const sentViaWS = sendWebSocketMessage(message);

            if (!sentViaWS) {
                // Show connection error message instead of automatic response
                const errorMessage = "Connection unavailable. Please check your internet connection or try again later.";
                addMessage(errorMessage, false, userMessageTime + 500);
            }
        }

        // Event listeners (initialized when main app is shown)
        function initializeMessageInput() {
            const messageInput = document.getElementById('messageInput');
            const sendButton = document.getElementById('sendButton');
            const textInputContainer = document.querySelector('.text-input-container');
            
            if (!messageInput || !sendButton) {
                console.log('Message input elements not found, retrying...');
                setTimeout(initializeMessageInput, 500);
                return;
            }
            
            // Remove existing listeners to prevent duplicates
            messageInput.removeEventListener('keydown', handleKeyPress);
            messageInput.removeEventListener('input', handleInputChange);
            sendButton.removeEventListener('click', handleSendClick);
            if (textInputContainer) {
                textInputContainer.removeEventListener('click', handleContainerClick);
            }
            
            // Add event listeners
            messageInput.addEventListener('keydown', handleKeyPress);
            messageInput.addEventListener('input', handleInputChange);
            sendButton.addEventListener('click', handleSendClick);
            if (textInputContainer) {
                textInputContainer.addEventListener('click', handleContainerClick);
            }
            
            // Initialize send button state
            updateSendButton();
            
            console.log('iMessage input initialized successfully');
        }
        
        function handleKeyPress(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                if (document.getElementById('sendButton').classList.contains('active')) {
                    sendMessage();
                }
            }
        }
        
        function handleInputChange(e) {
            autoExpand(e.target);
            updateSendButton();
        }
        
        function handleSendClick() {
            const sendButton = document.getElementById('sendButton');
            if (sendButton.classList.contains('active')) {
                sendMessage();
            }
        }
        
        function handleContainerClick() {
            document.getElementById('messageInput').focus();
        }
        
        function autoExpand(textarea) {
            textarea.style.height = 'auto';
            const scrollHeight = textarea.scrollHeight;
            const maxHeight = 120; // max-height in CSS
            
            if (scrollHeight <= maxHeight) {
                textarea.style.height = scrollHeight + 'px';
            } else {
                textarea.style.height = maxHeight + 'px';
            }
        }
        
        function updateSendButton() {
            const messageInput = document.getElementById('messageInput');
            const sendButton = document.getElementById('sendButton');
            const hasText = messageInput.value.trim().length > 0;
            
            if (hasText) {
                sendButton.classList.add('active');
            } else {
                sendButton.classList.remove('active');
            }
        }

        // Legacy logout function (keeping for compatibility)
        function logout() {
            keycloakLogout();
        }

        // Note: DOMContentLoaded listener is already defined in the Keycloak auth section above
        
        // Reactive token refresh: Only refresh when token actually expires
        async function refreshTokenAfterExpiry() {
            console.log('Access token expired, attempting refresh...');
            
            if (keycloakInstance && keycloakInstance.authenticated) {
                try {
                    // Force refresh using Keycloak
                    const refreshed = await keycloakInstance.updateToken(-1); // Force refresh
                    if (refreshed) {
                        localStorage.setItem('token', keycloakInstance.token);
                        if (keycloakInstance.refreshToken) {
                            localStorage.setItem('refreshToken', keycloakInstance.refreshToken);
                        }
                        console.log('✅ Token refreshed successfully after expiry');
                        return keycloakInstance.token;
                    }
                } catch (error) {
                    console.error('❌ Refresh token also expired or invalid:', error);
                    console.log('Forcing re-login...');
                    keycloakLogout();
                    throw new Error('Refresh failed - user needs to re-login');
                }
            } else {
                // Manual refresh token exchange for non-Keycloak flows
                const refreshToken = localStorage.getItem('refreshToken');
                if (refreshToken) {
                    try {
                        const response = await fetch(`${KEYCLOAK_CONFIG.url}/realms/${KEYCLOAK_CONFIG.realm}/protocol/openid-connect/token`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/x-www-form-urlencoded',
                            },
                            body: new URLSearchParams({
                                'grant_type': 'refresh_token',
                                'client_id': KEYCLOAK_CONFIG.clientId,
                                'refresh_token': refreshToken
                            })
                        });
                        
                        if (response.ok) {
                            const tokenData = await response.json();
                            localStorage.setItem('token', tokenData.access_token);
                            localStorage.setItem('refreshToken', tokenData.refresh_token);
                            console.log('✅ Token refreshed successfully using refresh token');
                            return tokenData.access_token;
                        } else {
                            throw new Error('Refresh token request failed');
                        }
                    } catch (error) {
                        console.error('❌ Refresh token exchange failed:', error);
                        localStorage.removeItem('token');
                        localStorage.removeItem('refreshToken');
                        console.log('Forcing re-login...');
                        window.location.reload(); // Force re-authentication
                        throw error;
                    }
                } else {
                    console.log('No refresh token available, forcing re-login...');
                    window.location.reload();
                    throw new Error('No refresh token available');
                }
            }
        }

        // API call wrapper with automatic token refresh on 401
        async function makeAuthenticatedRequest(url, options = {}) {
            const token = keycloakInstance?.token || localStorage.getItem('token');
            
            // Add auth header
            const headers = {
                ...options.headers,
                'Authorization': `Bearer ${token}`
            };
            
            try {
                const response = await fetch(url, { ...options, headers });
                
                // If token expired (401), try to refresh and retry
                if (response.status === 401) {
                    console.log('Received 401 - token expired, attempting refresh...');
                    const newToken = await refreshTokenAfterExpiry();
                    
                    // Retry the original request with new token
                    const retryHeaders = {
                        ...options.headers,
                        'Authorization': `Bearer ${newToken}`
                    };
                    
                    console.log('Retrying original request with new token...');
                    return fetch(url, { ...options, headers: retryHeaders });
                }
                
                return response;
            } catch (error) {
                console.error('Authenticated request failed:', error);
                throw error;
            }
        }

        // Simple auth headers for WebSocket (no auto-refresh needed for initial connection)
        function getAuthHeaders() {
            const headers = {};
            const currentToken = keycloakInstance?.token || localStorage.getItem('token');
            if (currentToken) {
                headers['Authorization'] = `Bearer ${currentToken}`;
                headers['X-Auth-Token'] = currentToken;
            }
            return headers;
        }

        // Chat history API functions
        async function fetchChatHistory() {
            try {
                console.log('Fetching chat history...');
                const response = await makeAuthenticatedRequest(`${API_CONFIG.backendUrl}/v1/agent/chat/history`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                if (response.ok) {
                    const historyData = await response.json();
                    console.log('Chat history fetched successfully:', historyData);
                    return historyData;
                } else {
                    throw new Error(`Failed to fetch chat history: ${response.status} ${response.statusText}`);
                }
            } catch (error) {
                console.error('Error fetching chat history:', error);
                throw error;
            }
        }

        async function loadChatHistory() {
            try {
                const historyData = await fetchChatHistory();
                
                if (historyData && historyData.length > 0) {
                    displayChatHistory(historyData);
                } else {
                    console.log('No chat history found');
                }
            } catch (error) {
                console.error('Failed to load chat history:', error);
                showHistoryError('Failed to load chat history');
            }
        }

        function displayChatHistory(historyData) {
            const messagesContainer = document.getElementById('messages');
            if (!messagesContainer) return;

            // Clear existing messages and reset timestamp tracking
            messagesContainer.innerHTML = '';
            lastMessageTime = null;

            // Sort history by timestamp for proper ordering
            const sortedHistory = historyData.sort((a, b) => 
                new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
            );

            // Use document fragment for better performance when adding many elements
            const fragment = document.createDocumentFragment();

            // Add history messages with smart timestamps
            sortedHistory.forEach(historyMessage => {
                const isUser = historyMessage.type === 'user';
                const content = historyMessage.content;
                const messageTime = new Date(historyMessage.timestamp).getTime();
                
                // Check if we need a timestamp header
                if (shouldShowTimestamp(messageTime, lastMessageTime)) {
                    const timestampHeader = createTimestampHeader(messageTime);
                    fragment.appendChild(timestampHeader);
                }
                
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${isUser ? 'user' : 'agent'}`;
                messageDiv.setAttribute('data-history', 'true');
                messageDiv.setAttribute('data-timestamp', messageTime);

                // Format content with markdown support for agent messages
                const formattedContent = isUser ? content : formatMarkdown(content);

                messageDiv.innerHTML = `
                    <div class="message-content">
                        ${formattedContent}
                    </div>
                `;

                fragment.appendChild(messageDiv);
                lastMessageTime = messageTime;
            });

            // Add all elements at once for better performance
            messagesContainer.appendChild(fragment);

            // Add a divider between history and new messages
            const divider = document.createElement('div');
            divider.className = 'history-divider';
            divider.innerHTML = `
                <div style="text-align: center; padding: 20px; color: #666; font-size: 14px; border-bottom: 1px solid #e5e7eb; margin: 10px 0;">
                    <span style="background: #fafafa; padding: 0 15px;">Previous conversation loaded</span>
                </div>
            `;
            messagesContainer.appendChild(divider);

            // Optimized scroll
            requestAnimationFrame(() => {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            });

            console.log(`Loaded ${historyData.length} messages from chat history`);
        }

        function showHistoryError(errorMessage) {
            const messagesContainer = document.getElementById('messages');
            if (!messagesContainer) return;

            const errorDiv = document.createElement('div');
            errorDiv.className = 'message system';
            errorDiv.innerHTML = `
                <div class="message-content" style="background: #fee; color: #c33; font-size: 12px; opacity: 0.8;">
                    ⚠️ ${errorMessage}
                </div>
            `;

            if (messagesContainer.children.length > 0) {
                messagesContainer.insertBefore(errorDiv, messagesContainer.children[0]);
            } else {
                messagesContainer.appendChild(errorDiv);
            }
        }
    </script>
</body>
</html>