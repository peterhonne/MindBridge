<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MindBridge AI - Therapeutic Platform</title>
    <link rel="icon" href="favicon.png" type="image/png" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .app-container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 1200px;
            height: 90vh;
            display: none; /* Hide by default until authentication is verified */
            grid-template-columns: 300px 1fr;
            overflow: hidden;
            position: relative;
        }

        .sidebar {
            background: linear-gradient(180deg, #4a90e2 0%, #357abd 100%);
            color: white;
            padding: 30px;
            display: flex;
            flex-direction: column;
            gap: 25px;
        }

        /* Navigation styles */
        .nav-menu {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 20px 0;
        }

        .nav-item {
            padding: 15px 20px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 16px;
            font-weight: 500;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid transparent;
        }

        .nav-item:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateX(5px);
        }

        .nav-item.active {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .nav-icon {
            font-size: 20px;
            width: 24px;
            text-align: center;
        }

        /* View management */
        .view {
            display: none;
            height: 100%;
            overflow: hidden;
        }

        .view.active {
            display: flex;
            flex-direction: column;
        }

        /* Mood tracking styles */
        .mood-tag {
            background: #f3f4f6;
            color: #374151;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid transparent;
            display: inline-block;
        }

        .mood-tag:hover {
            background: #e5e7eb;
            transform: translateY(-1px);
        }

        .mood-tag.selected {
            background: #dbeafe;
            color: #1d4ed8;
            border-color: #3b82f6;
        }

        /* Mood slider customization */
        #moodSlider {
            -webkit-appearance: none;
            appearance: none;
        }

        #moodSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #4a90e2;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        #moodSlider::-moz-range-thumb {
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #4a90e2;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            padding: 20px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .agent-status {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .agent-role {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .role-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #4ade80;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .agent-description {
            font-size: 14px;
            opacity: 0.9;
            line-height: 1.4;
        }

        .session-info {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
        }

        .session-info h3 {
            margin-bottom: 15px;
            font-size: 16px;
        }

        .info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .crisis-monitor {
            background: rgba(34, 197, 94, 0.2);
            border: 2px solid #22c55e;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
        }

        .crisis-monitor.alert {
            background: rgba(239, 68, 68, 0.2);
            border-color: #ef4444;
            animation: alertPulse 1s infinite;
        }

        @keyframes alertPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        .crisis-status {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .main-content {
            display: flex;
            flex-direction: column;
            background: #fafafa;
            border-bottom-right-radius: 20px;
            overflow: hidden;
        }

        .header {
            background: white;
            padding: 20px 30px;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }


        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }

        .messages {
            flex: 1;
            overflow-y: auto;
            padding: 30px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-height: 0;
        }

        .message {
            display: flex;
            animation: messageSlide 0.3s ease-out;
            margin-bottom: 2px;
            justify-content: flex-start;
        }
        
        .message + .message {
            margin-top: 2px;
        }
        
        .message.user + .message.user .message-content {
            border-radius: 18px;
            border-bottom-right-radius: 8px;
        }
        
        .message.agent + .message.agent .message-content {
            border-radius: 18px;
            border-bottom-left-radius: 8px;
        }
        
        .message.user:first-child .message-content,
        .message.user:not(.user) + .message.user .message-content,
        .timestamp-header + .message.user .message-content {
            border-top-right-radius: 18px;
        }
        
        .message.agent:first-child .message-content,
        .message.agent:not(.agent) + .message.agent .message-content,
        .timestamp-header + .message.agent .message-content {
            border-top-left-radius: 18px;
        }
        
        .message.user:last-child .message-content,
        .message.user + .message:not(.user) .message-content {
            border-bottom-right-radius: 8px;
        }
        
        .message.agent:last-child .message-content,
        .message.agent + .message:not(.agent) .message-content {
            border-bottom-left-radius: 8px;
        }
        
        .timestamp-header {
            text-align: center;
            color: #8E8E93;
            font-size: 13px;
            font-weight: 400;
            margin: 20px 0 15px 0;
            pointer-events: none;
            user-select: none;
        }

        @keyframes messageSlide {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.user {
            justify-content: flex-end;
        }


        .message-content {
            max-width: 70%;
            padding: 12px 18px;
            border-radius: 25px;
            line-height: 1.4;
            position: relative;
            font-size: 16px;
            word-wrap: break-word;
            overflow-wrap: break-word;
            overflow: hidden;
        }

        /* Enhanced markdown content styling */
        .message-content ul, .message-content ol {
            margin: 8px 0;
            padding-left: 20px;
            max-width: 100%;
            overflow-wrap: break-word;
        }

        .message-content li {
            margin: 4px 0;
            word-wrap: break-word;
            overflow-wrap: break-word;
            line-height: 1.5;
        }

        .message-content p {
            margin: 8px 0;
            word-wrap: break-word;
            overflow-wrap: break-word;
            line-height: 1.5;
        }

        .message-content p:last-child {
            margin-bottom: 0;
        }

        .message-content p:first-child {
            margin-top: 0;
        }

        .message-content strong, .message-content em {
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .message-content h1, .message-content h2, .message-content h3, .message-content h4, .message-content h5, .message-content h6 {
            margin: 16px 0 8px 0;
            font-weight: 600;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .message-content h1 { font-size: 1.5em; }
        .message-content h2 { font-size: 1.3em; }
        .message-content h3 { font-size: 1.1em; }

        .message-content a {
            color: #007AFF;
            text-decoration: underline;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .message.agent .message-content a {
            color: #007AFF;
        }

        .message.user .message-content a {
            color: #B3D4FF;
        }

        .message-content a:hover {
            opacity: 0.8;
        }

        .message-content ul ul {
            margin-top: 4px;
            margin-bottom: 4px;
        }

        .message-content li:last-child {
            margin-bottom: 0;
        }

        .message.user .message-content {
            background: #007AFF;
            color: white;
            border-bottom-right-radius: 8px;
        }

        .message.agent .message-content {
            background: #E5E5EA;
            color: #000000;
            border-bottom-left-radius: 8px;
        }



        .typing-indicator {
            display: none;
            align-items: center;
            gap: 15px;
            padding: 20px 30px;
        }

        .typing-indicator.active {
            display: flex;
        }

        .typing-dots {
            display: flex;
            gap: 4px;
        }

        .typing-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #9ca3af;
            animation: typing 1.4s infinite;
        }

        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
                opacity: 0.4;
            }
            30% {
                transform: translateY(-10px);
                opacity: 1;
            }
        }

        .input-container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-top: 1px solid rgba(255, 255, 255, 0.3);
            padding: 15px;
            display: flex;
            align-items: flex-end;
            gap: 12px;
            flex-shrink: 0;
            border-bottom-right-radius: 20px;
            min-height: 64px;
        }

        .input-wrapper {
            flex: 1;
            display: flex;
            align-items: flex-end;
            gap: 12px;
            min-height: 44px;
        }

        .text-input-container {
            flex: 1;
            background: #F2F2F7;
            border-radius: 20px;
            padding: 8px 16px;
            min-height: 36px;
            display: flex;
            align-items: center;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .text-input-container:focus-within {
            background: #FFFFFF;
            border-color: #007AFF;
            box-shadow: 0 0 0 3px rgba(0, 122, 255, 0.1);
        }

        .message-input {
            width: 100%;
            border: none;
            outline: none;
            background: transparent;
            font-size: 16px;
            line-height: 20px;
            resize: none;
            min-height: 20px;
            max-height: 120px;
            overflow-y: auto;
            font-family: inherit;
            color: #000;
        }

        .message-input::placeholder {
            color: #8E8E93;
        }

        .send-button {
            width: 32px;
            height: 32px;
            border: none;
            background: #007AFF;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            flex-shrink: 0;
            margin-bottom: 6px;
            opacity: 0.5;
            transform: scale(0.8);
        }

        .send-button.active {
            opacity: 1;
            transform: scale(1);
            background: #007AFF;
        }

        .send-button.active:hover {
            background: #0056CC;
            transform: scale(1.05);
        }

        .send-button svg {
            width: 16px;
            height: 16px;
            fill: white;
            transform: translateX(1px);
        }

        /* Custom scrollbar for textarea */
        .message-input::-webkit-scrollbar {
            width: 4px;
        }

        .message-input::-webkit-scrollbar-track {
            background: transparent;
        }

        .message-input::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 2px;
        }

        .message-input::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.3);
        }

        .crisis-alert {
            background: linear-gradient(45deg, #ef4444, #dc2626);
            color: white;
            padding: 15px 20px;
            margin: 10px 30px;
            border-radius: 10px;
            display: none;
            align-items: center;
            gap: 10px;
            animation: slideDown 0.3s ease-out;
        }

        .crisis-alert.active {
            display: flex;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .crisis-icon {
            font-size: 20px;
        }

        @media (max-width: 768px) {
            .app-container {
                grid-template-columns: 1fr;
                height: 100vh;
                border-radius: 0;
            }

            .sidebar {
                display: none;
            }
            
            .messages {
                padding: 15px;
                max-height: calc(100vh - 200px);
            }
            
            .input-container {
                padding: 15px;
            }
        }
        
        @media (max-width: 1024px) and (min-width: 769px) {
            .app-container {
                grid-template-columns: 250px 1fr;
            }
            
            .sidebar {
                padding: 20px 15px;
            }
            
            .messages {
                padding: 20px;
            }
        }

        /* Loading screen styles */
        .auth-loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            color: white;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            font-size: 18px;
            font-weight: 500;
            margin-bottom: 10px;
        }

        .loading-subtext {
            font-size: 14px;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <!-- Loading screen shown by default -->
    <div class="auth-loading" id="authLoading">
        <div class="loading-spinner"></div>
        <div class="loading-text">MindBridge AI</div>
        <div class="loading-subtext">Initializing secure connection...</div>
    </div>

    <div class="app-container">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="logo">🧠 MindBridge AI</div>

            <!-- Navigation Menu -->
            <nav class="nav-menu">
                <div class="nav-item active" data-view="dashboard">
                    <span class="nav-icon">📊</span>
                    <span>Dashboard</span>
                </div>
                <div class="nav-item" data-view="mood">
                    <span class="nav-icon">😊</span>
                    <span>Mood Tracking</span>
                </div>
                <div class="nav-item" data-view="journal">
                    <span class="nav-icon">📝</span>
                    <span>Journal Entry</span>
                </div>
                <div class="nav-item" data-view="chat">
                    <span class="nav-icon">💬</span>
                    <span>Companion</span>
                </div>
            </nav>

        </div>

        <!-- Main Content -->
        <div class="main-content">
            <!-- Common Header -->
            <div class="header">
                <div class="user-info">
                    <div class="avatar" id="userAvatar">JD</div>
                    <div>
                        <div style="font-weight: 600;" id="userName">Loading...</div>
                        <div style="font-size: 14px; color: #6b7280;" id="userInfo">Loading user info...</div>
                    </div>
                </div>
                <div style="display: flex; align-items: center; gap: 20px;">
                    <button onclick="keycloakLogout()" style="padding: 8px 16px; background: #ef4444; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 14px;">
                        Logout
                    </button>
                </div>
            </div>

            <!-- Dashboard View -->
            <div id="dashboard-view" class="view active">
                <div style="padding: 30px; overflow-y: auto; flex: 1;">
                    <div style="max-width: 1200px; margin: 0 auto;">
                        <h1 style="color: #333; margin-bottom: 30px; font-size: 2rem;">Welcome back, <span id="dashboardUserName">User</span>!</h1>
                        
                        <!-- Enhanced Quick Stats -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; margin-bottom: 30px; min-height: 120px;">
                            <!-- Today's Mood Card -->
                            <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 15px; padding: 20px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); color: white;">
                                <h3 style="color: white; margin-bottom: 15px; display: flex; align-items: center; gap: 8px;">
                                    📊 Today's Mood
                                </h3>
                                <div style="display: flex; align-items: center; justify-content: space-between;">
                                    <div>
                                        <div style="font-size: 2.5rem; font-weight: 600;" id="recentMoodScore">-</div>
                                        <div style="color: rgba(255,255,255,0.8); font-size: 13px;" id="recentMoodDate">No entries yet</div>
                                    </div>
                                    <div style="font-size: 3rem; opacity: 0.7;" id="todayMoodEmoji">😐</div>
                                </div>
                            </div>

                            <!-- Period Average Card -->
                            <div style="background: white; border-radius: 15px; padding: 20px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); border: 2px solid #f0f9ff;">
                                <h3 style="color: #4a90e2; margin-bottom: 15px; display: flex; align-items: center; gap: 8px;">
                                    📈 <span id="periodLabel">7-Day</span> Average
                                </h3>
                                <div style="display: flex; align-items: center; justify-content: space-between;">
                                    <div>
                                        <div style="font-size: 2.5rem; color: #333; font-weight: 600;" id="weeklyMoodAvg">-</div>
                                        <div style="color: #666; font-size: 13px;" id="moodTrendText">Calculating...</div>
                                    </div>
                                    <div style="font-size: 2rem;" id="moodTrendIcon">📊</div>
                                </div>
                            </div>

                            <!-- Mood Range Card -->
                            <div style="background: white; border-radius: 15px; padding: 20px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); border: 2px solid #fef3f2;">
                                <h3 style="color: #dc2626; margin-bottom: 15px; display: flex; align-items: center; gap: 8px;">
                                    📊 Mood Range
                                </h3>
                                <div style="display: flex; align-items: center; justify-content: space-between;">
                                    <div style="flex: 1;">
                                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                            <span style="font-size: 12px; color: #666;">Low</span>
                                            <span style="font-size: 12px; color: #666;">High</span>
                                        </div>
                                        <div style="display: flex; align-items: center; gap: 10px;">
                                            <div style="font-size: 1.8rem; color: #dc2626; font-weight: 600;" id="lowestMoodScore">-</div>
                                            <div style="flex: 1; height: 4px; background: linear-gradient(to right, #dc2626, #10b981); border-radius: 2px;"></div>
                                            <div style="font-size: 1.8rem; color: #10b981; font-weight: 600;" id="highestMoodScore">-</div>
                                        </div>
                                        <div style="color: #666; font-size: 13px; margin-top: 5px;" id="rangeText">Period range</div>
                                    </div>
                                </div>
                            </div>

                            <!-- Active Days Card -->
                            <div style="background: white; border-radius: 15px; padding: 20px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); border: 2px solid #f0fdf4;">
                                <h3 style="color: #16a34a; margin-bottom: 15px; display: flex; align-items: center; gap: 8px;">
                                    📅 Active Days
                                </h3>
                                <div style="display: flex; align-items: center; justify-content: space-between;">
                                    <div>
                                        <div style="display: flex; align-items: baseline; gap: 8px;">
                                            <div style="font-size: 2.5rem; color: #333; font-weight: 600;" id="activeDaysCount">-</div>
                                            <div style="font-size: 1.2rem; color: #666;" id="totalDaysCount">/ -</div>
                                        </div>
                                        <div style="color: #666; font-size: 13px;" id="activeDaysText">days tracked</div>
                                    </div>
                                    <div style="font-size: 2.5rem; color: #16a34a; opacity: 0.7;">📈</div>
                                </div>
                            </div>
                        </div>

                        <!-- Mood Trend Chart -->
                        <div style="background: white; border-radius: 15px; padding: 30px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); margin-bottom: 30px;">
                            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 20px;">
                                <div style="flex: 1;">
                                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                                        <h2 style="color: #333; margin: 0;" id="chartTitle">Mood Trend</h2>
                                        <!-- Period Selector -->
                                        <select id="periodSelector" onchange="onPeriodChange()" 
                                                style="padding: 6px 12px; border: 2px solid #e5e7eb; border-radius: 8px; background: white; color: #374151; font-size: 14px; font-weight: 500; cursor: pointer; outline: none; transition: border-color 0.2s;">
                                            <option value="7">Last 7 days</option>
                                            <option value="14">Last 2 weeks</option>
                                            <option value="30">Last 30 days</option>
                                            <option value="90">Last 3 months</option>
                                        </select>
                                    </div>
                                    <!-- Common mood tags in header -->
                                    <div id="chartMoodTags" style="display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 5px;">
                                        <!-- Tags will be populated here -->
                                    </div>
                                </div>
                                <div style="display: flex; gap: 15px; font-size: 14px; color: #666; margin-top: 5px;">
                                    <div style="display: flex; align-items: center; gap: 5px;">
                                        <div style="width: 12px; height: 12px; background: #4a90e2; border-radius: 50%;"></div>
                                        <span>Mood Score</span>
                                    </div>
                                </div>
                            </div>
                            <div id="moodChart" style="height: 200px; position: relative; background: #f9fafb; border-radius: 10px; padding: 20px;">
                                <div style="display: flex; justify-content: center; align-items: center; height: 100%; color: #666;">
                                    Loading mood trend...
                                </div>
                            </div>
                        </div>

                        <!-- Insights Panel -->
                        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 15px; padding: 30px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); margin-bottom: 30px; color: white;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                                <h2 style="color: white; margin: 0;">🧠 Your Wellness Insights</h2>
                                <button id="generateInsightsBtn" onclick="requestInsights()" 
                                        style="background: rgba(255,255,255,0.2); color: white; border: 2px solid rgba(255,255,255,0.3); border-radius: 8px; padding: 8px 16px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.3s ease;"
                                        onmouseover="this.style.background='rgba(255,255,255,0.3)'; this.style.borderColor='rgba(255,255,255,0.5)'"
                                        onmouseout="this.style.background='rgba(255,255,255,0.2)'; this.style.borderColor='rgba(255,255,255,0.3)'">
                                    Generate Insights
                                </button>
                            </div>
                            <div id="insightsContainer">
                                <div id="dailyInsight" style="font-size: 16px; line-height: 1.6; opacity: 0.9; margin-bottom: 15px;">
                                    <!-- Insights will appear here -->
                                </div>
                                <div id="additionalInsights" style="font-size: 16px; line-height: 1.6; opacity: 0.9;">
                                    <!-- Additional insights will appear here -->
                                </div>
                            </div>
                        </div>

                    </div>
                </div>
            </div>

            <!-- Mood Tracking View -->
            <div id="mood-view" class="view">
                <div style="padding: 30px; overflow-y: auto; flex: 1;">
                    <div style="max-width: 800px; margin: 0 auto;">
                        <h1 style="color: #333; margin-bottom: 30px; font-size: 2rem;">Mood Tracking</h1>
                        
                        <!-- Mood Entry Form -->
                        <div style="background: white; border-radius: 15px; padding: 30px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); margin-bottom: 30px;">
                            <h2 style="color: #4a90e2; margin-bottom: 20px;">How are you feeling today?</h2>
                            
                            <form id="moodEntryForm">
                                <!-- Mood Slider -->
                                <div style="margin-bottom: 25px;">
                                    <label style="display: block; margin-bottom: 10px; font-weight: 600;">Mood Score (1-10)</label>
                                    <div style="position: relative; margin: 20px 0;">
                                        <input type="range" id="moodSlider" min="1" max="10" value="5" 
                                               style="width: 100%; height: 8px; background: linear-gradient(to right, #ef4444, #f59e0b, #10b981); border-radius: 5px; outline: none;">
                                        <div style="display: flex; justify-content: space-between; margin-top: 10px; font-size: 12px; color: #666;">
                                            <span>1 - Very Low</span>
                                            <span>5 - Neutral</span>
                                            <span>10 - Excellent</span>
                                        </div>
                                    </div>
                                    <div style="text-align: center; margin-top: 15px;">
                                        <span style="font-size: 3rem;" id="moodEmoji">😐</span>
                                        <div style="font-size: 1.5rem; font-weight: 600; color: #333;" id="moodScoreDisplay">5</div>
                                    </div>
                                </div>

                                <!-- Mood Tags -->
                                <div style="margin-bottom: 20px;">
                                    <label style="display: block; margin-bottom: 10px; font-weight: 600;">How would you describe your mood?</label>
                                    <div id="moodTags" style="display: flex; flex-wrap: wrap; gap: 10px;">
                                        <span class="mood-tag" data-tag="happy">😊 Happy</span>
                                        <span class="mood-tag" data-tag="anxious">😰 Anxious</span>
                                        <span class="mood-tag" data-tag="sad">😢 Sad</span>
                                        <span class="mood-tag" data-tag="excited">🤩 Excited</span>
                                        <span class="mood-tag" data-tag="tired">😴 Tired</span>
                                        <span class="mood-tag" data-tag="angry">😠 Angry</span>
                                        <span class="mood-tag" data-tag="peaceful">😌 Peaceful</span>
                                        <span class="mood-tag" data-tag="stressed">😤 Stressed</span>
                                        <span class="mood-tag" data-tag="grateful">🙏 Grateful</span>
                                        <span class="mood-tag" data-tag="confused">😕 Confused</span>
                                    </div>
                                </div>

                                <!-- Notes -->
                                <div style="margin-bottom: 20px;">
                                    <label for="moodNotes" style="display: block; margin-bottom: 10px; font-weight: 600;">Notes (optional)</label>
                                    <textarea id="moodNotes" placeholder="What's on your mind? Any specific thoughts or events affecting your mood?"
                                              style="width: 100%; min-height: 80px; padding: 12px; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 14px; resize: vertical; box-sizing: border-box;"></textarea>
                                </div>

                                <button type="submit" id="saveMoodBtn" 
                                        style="width: 100%; padding: 15px; background: linear-gradient(45deg, #4a90e2, #357abd); color: white; border: none; border-radius: 10px; font-size: 16px; font-weight: 600; cursor: pointer;">
                                    Save Mood Entry
                                </button>
                            </form>
                        </div>

                        <!-- Mood History -->
                        <div style="background: white; border-radius: 15px; padding: 30px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); margin-bottom: 30px;">
                            <h3 style="color: #4a90e2; margin-bottom: 20px; font-size: 1.5rem;">Mood History</h3>
                            <div id="moodHistoryContainer">
                                <div style="text-align: center; color: #666; padding: 20px;">Loading mood history...</div>
                            </div>
                        </div>

                    </div>
                </div>
            </div>

            <!-- Journal Entry View -->
            <div id="journal-view" class="view">
                <div style="padding: 30px; overflow-y: auto; flex: 1;">
                    <div style="max-width: 800px; margin: 0 auto;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px;">
                            <h1 style="color: #333; margin: 0; font-size: 2rem;">Journal Entry</h1>
                            <button onclick="showNewJournalForm()" style="padding: 10px 20px; background: linear-gradient(45deg, #4a90e2, #357abd); color: white; border: none; border-radius: 8px; font-size: 14px; font-weight: 600; cursor: pointer;">
                                + New Entry
                            </button>
                        </div>
                        
                        <!-- Journal Entry Form -->
                        <div id="journalForm" style="background: white; border-radius: 15px; padding: 30px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); margin-bottom: 30px; display: none;">
                            <h2 style="color: #4a90e2; margin-bottom: 20px;" id="journalFormTitle">Create New Journal Entry</h2>
                            
                            <form id="journalEntryForm">
                                <input type="hidden" id="journalEntryCode" value="">
                                
                                <!-- Title -->
                                <div style="margin-bottom: 20px;">
                                    <label for="journalTitle" style="display: block; margin-bottom: 8px; font-weight: 600;">Title</label>
                                    <input type="text" id="journalTitle" placeholder="What's on your mind today?"
                                           style="width: 100%; padding: 12px; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 16px; box-sizing: border-box;">
                                </div>

                                <!-- Content -->
                                <div style="margin-bottom: 20px;">
                                    <label for="journalContent" style="display: block; margin-bottom: 8px; font-weight: 600;">Content</label>
                                    <textarea id="journalContent" placeholder="Write about your thoughts, feelings, experiences..."
                                              style="width: 100%; min-height: 200px; padding: 12px; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 14px; resize: vertical; box-sizing: border-box; font-family: inherit;"></textarea>
                                </div>

                                <!-- Mood Before/After -->
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                                    <div>
                                        <label for="moodBefore" style="display: block; margin-bottom: 8px; font-weight: 600;">Mood Before (1-10)</label>
                                        <input type="number" id="moodBefore" min="1" max="10" placeholder="5"
                                               style="width: 100%; padding: 12px; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 14px; box-sizing: border-box;">
                                    </div>
                                    <div>
                                        <label for="moodAfter" style="display: block; margin-bottom: 8px; font-weight: 600;">Mood After (1-10)</label>
                                        <input type="number" id="moodAfter" min="1" max="10" placeholder="5"
                                               style="width: 100%; padding: 12px; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 14px; box-sizing: border-box;">
                                    </div>
                                </div>

                                <!-- Tags -->
                                <div style="margin-bottom: 25px;">
                                    <label for="journalTags" style="display: block; margin-bottom: 8px; font-weight: 600;">Tags (comma-separated)</label>
                                    <input type="text" id="journalTags" placeholder="reflection, growth, challenges, gratitude"
                                           style="width: 100%; padding: 12px; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 14px; box-sizing: border-box;">
                                </div>

                                <div style="display: flex; gap: 10px;">
                                    <button type="submit" id="saveJournalBtn" 
                                            style="flex: 1; padding: 15px; background: linear-gradient(45deg, #4a90e2, #357abd); color: white; border: none; border-radius: 10px; font-size: 16px; font-weight: 600; cursor: pointer;">
                                        Save Entry
                                    </button>
                                    <button type="button" onclick="hideJournalForm()" 
                                            style="padding: 15px 20px; background: #f3f4f6; color: #374151; border: none; border-radius: 10px; font-size: 16px; cursor: pointer;">
                                        Cancel
                                    </button>
                                </div>
                            </form>
                        </div>

                        <!-- Search -->
                        <div style="background: white; border-radius: 15px; padding: 20px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); margin-bottom: 30px;">
                            <div style="display: flex; gap: 10px;">
                                <input type="text" id="journalSearch" placeholder="Search your journal entries..."
                                       style="flex: 1; padding: 12px; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 14px;">
                                <button onclick="searchJournalEntries()" style="padding: 12px 20px; background: #4a90e2; color: white; border: none; border-radius: 8px; cursor: pointer;">
                                    Search
                                </button>
                                <button onclick="loadJournalEntries()" style="padding: 12px 20px; background: #f3f4f6; color: #374151; border: none; border-radius: 8px; cursor: pointer;">
                                    Clear
                                </button>
                            </div>
                        </div>

                        <!-- Journal History -->
                        <div style="background: white; border-radius: 15px; padding: 30px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); margin-bottom: 30px;">
                            <h3 style="color: #4a90e2; margin-bottom: 20px; font-size: 1.5rem;">Journal History</h3>
                            <div id="journalHistoryContainer">
                                <div style="text-align: center; color: #666; padding: 20px;">Loading journal entries...</div>
                            </div>
                        </div>

                    </div>
                </div>
            </div>

            <!-- Chat View (Companion) -->
            <div id="chat-view" class="view">
                <div class="chat-container">
                    <div class="messages" id="messages">
                    </div>

                    <div class="typing-indicator" id="typingIndicator">
                        <div style="max-width: 70%; padding: 12px 18px; border-radius: 25px; background: #E5E5EA; position: relative; border-bottom-left-radius: 8px;">
                            <div class="typing-dots">
                                <div class="typing-dot"></div>
                                <div class="typing-dot"></div>
                                <div class="typing-dot"></div>
                            </div>
                        </div>
                    </div>

                    <div class="input-container">
                        <div class="input-wrapper">
                            <div class="text-input-container">
                                <textarea 
                                    class="message-input" 
                                    id="messageInput" 
                                    rows="1"
                                    maxlength="1000"
                                    placeholder="Message"
                                ></textarea>
                            </div>

                            <button class="send-button" id="sendButton" title="Send message">
                                <svg viewBox="0 0 24 24">
                                    <path d="M2,21L23,12L2,3V10L17,12L2,14V21Z"/>
                                </svg>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- STOMP.js for WebSocket communication -->
    <script src="https://cdn.jsdelivr.net/npm/@stomp/stompjs@7.0.0/bundles/stomp.umd.min.js"></script>
    <script src="https://unpkg.com/markdown-it@14.1.0/dist/markdown-it.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/markdown-it-emoji@3.0.0/dist/markdown-it-emoji-bare.min.js"></script>
    <!-- Keycloak JS -->
    <script src="https://cdn.jsdelivr.net/npm/keycloak-js@23.0.0/dist/keycloak.min.js"></script>

    <!-- Authentication Guard -->
    <script>
        // API Configuration - automatically detects environment
        const API_CONFIG = {
            // Auto-detect if running locally or on cloud
            isLocal: window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1',
            
            // Base URLs that change between environments
            get keycloakUrl() {
                return this.isLocal ? 'http://localhost:8080' : 'https://auth.honne.app';
            },
            
            get backendUrl() {
                return this.isLocal ? 'http://localhost:8082' : 'https://mindbridge.honne.app';
            },

            get websocketUrl() {
                const protocol = this.isLocal ? 'ws' : 'wss';
                const host = this.isLocal ? 'localhost:8082' : 'mindbridge.honne.app';
                return `${protocol}://${host}/v1/agent/mindbridge`;
            }
        };

        // Keycloak configuration using dynamic URL
        const KEYCLOAK_CONFIG = {
            url: API_CONFIG.keycloakUrl,
            realm: 'MindBridge',
            clientId: 'MindBridgeClient'
        };
        
        
        let keycloakInstance = null;
        let authMode = 'checking'; // 'checking', 'keycloak'
        let initializationInProgress = false;
        let initializationCompleted = false;
        let keycloakInitAttempted = false;
        
        // Function to reset initialization state (useful for debugging)
        function resetInitializationState() {
            initializationInProgress = false;
            initializationCompleted = false;
            domContentLoadedHandled = false;
            keycloakInitAttempted = false;
            window.mainAppInitialized = false;
        }
        
        // Expose reset function globally for debugging
        window.resetInitializationState = resetInitializationState;
        
        // Handle OAuth callback from Keycloak
        async function handleOAuthCallback() {
            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('code');
            const state = urlParams.get('state');
            const sessionState = urlParams.get('session_state');
            
            if (code) {
                
                try {
                    // Exchange authorization code for tokens
                    const redirectUri = getRedirectUri();
                    const formData = new URLSearchParams();
                    formData.append('grant_type', 'authorization_code');
                    formData.append('client_id', KEYCLOAK_CONFIG.clientId);
                    formData.append('code', code);
                    formData.append('redirect_uri', redirectUri);
                    
                    const response = await fetch(`${KEYCLOAK_CONFIG.url}/realms/${KEYCLOAK_CONFIG.realm}/protocol/openid-connect/token`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        },
                        body: formData.toString(),
                    });
                    
                    if (response.ok) {
                        const tokenResponse = await response.json();
                        
                        // Store tokens
                        localStorage.setItem('token', tokenResponse.access_token);
                        localStorage.setItem('refreshToken', tokenResponse.refresh_token);
                        
                        // Clean URL
                        window.history.replaceState({}, document.title, window.location.pathname);
                        
                        // Validate token with server before showing app
                        const tokenValid = await validateTokenWithServer(tokenResponse.access_token);
                        if (tokenValid) {
                            showMainApp();
                            return true;
                        } else {
                            // Token invalid, clear and show login
                            localStorage.removeItem('token');
                            localStorage.removeItem('refreshToken');
                            showLoginFallback();
                            return false;
                        }
                    } else {
                        const error = await response.json();
                        console.error('Token exchange failed:', error);
                        throw new Error(error.error_description || 'Token exchange failed');
                    }
                } catch (error) {
                    console.error('OAuth callback error:', error);
                    // Clear URL parameters and show login
                    window.history.replaceState({}, document.title, window.location.pathname);
                    showLoginFallback();
                    return false;
                }
            }
            
            return false;
        }
        
        // Track if initialization has started
        let domContentLoadedHandled = false;
        
        // Prevent back navigation to authenticated pages after logout
        window.addEventListener('pageshow', function(event) {
            // Check if this is a back/forward navigation
            if (event.persisted) {
                // Check if user is actually logged out
                const hasToken = localStorage.getItem('token') || localStorage.getItem('refreshToken');
                if (!hasToken) {
                    window.location.replace(window.location.origin + window.location.pathname + '?logout=true');
                    return;
                }
            }
        });
        
        // Immediately hide the page and check authentication
        document.addEventListener('DOMContentLoaded', async function() {
            if (domContentLoadedHandled || initializationInProgress || initializationCompleted) {
                return;
            }
            domContentLoadedHandled = true;
            
            const appContainer = document.querySelector('.app-container');
            if (appContainer) {
                appContainer.style.display = 'none';
            }
            
            // Check URL parameters for OAuth callback
            const urlParams = new URLSearchParams(window.location.search);
            const hasCode = urlParams.has('code');
            const hasLogoutParam = urlParams.has('logout') || window.location.href.includes('logout');
            
            if (hasCode) {
                // Handle OAuth callback
                const callbackHandled = await handleOAuthCallback();
                if (callbackHandled) {
                    return; // OAuth callback handled successfully
                }
            }
            
            if (hasLogoutParam) {
                // Clear any existing tokens after logout redirect
                localStorage.clear();
                sessionStorage.clear();
                
                // Clear the logout flag from URL
                window.history.replaceState({}, document.title, window.location.pathname);
                
                // Mark initialization as completed to prevent any auth attempts
                initializationCompleted = true;
                domContentLoadedHandled = true;
                
                // Reset logout progress flag
                window.logoutInProgress = false;
                
                // Show login form
                showLoginFallback();
                return;
            }
            
            
            // Check if we already have tokens
            const existingToken = localStorage.getItem('token');
            const existingRefreshToken = localStorage.getItem('refreshToken');
            
            if (existingToken || existingRefreshToken) {
                // Try to validate token first, or refresh if only refresh token exists
                const isValid = await validateExistingToken(existingToken, existingRefreshToken);
                if (isValid) {
                    return; // Token is valid or was refreshed, main app will be shown
                }
                // If both access and refresh tokens are invalid, continue to Keycloak initialization
            }
            
            // Initialize Keycloak with a small delay to prevent race conditions
            setTimeout(() => {
                if (!initializationInProgress && !initializationCompleted) {
                    initKeycloakAuth();
                }
            }, 100);
        });
        
        async function validateExistingToken(token, refreshToken) {
            try {
                // If no access token but have refresh token, try to refresh immediately
                if (!token && refreshToken) {
                    try {
                        const newToken = await refreshWithStoredToken(refreshToken);
                        if (newToken) {
                            // Validate new token with server before showing app
                            const tokenValid = await validateTokenWithServer(newToken);
                            if (tokenValid) {
                                initializationCompleted = true;
                                showMainApp();
                                return true;
                            }
                        }
                    } catch (refreshError) {
                        // Clear invalid refresh token
                        localStorage.removeItem('token');
                        localStorage.removeItem('refreshToken');
                        initializationCompleted = true;
                        showLoginFallback();
                        return false;
                    }
                }
                
                // If we have an access token, validate it with the server
                if (token) {
                    // First check JWT expiry locally to avoid unnecessary server calls
                    const payload = decodeJWT(token);
                    const now = Math.floor(Date.now() / 1000);
                    
                    if (payload.exp && payload.exp > now) {
                        // Token appears valid locally, now verify with server
                        try {
                            const serverValidation = await validateTokenWithServer(token);
                            if (serverValidation) {
                                initializationCompleted = true;
                                showMainApp();
                                return true;
                            }
                        } catch (serverError) {
                            // Server validation failed, continue to refresh logic
                        }
                    }
                    
                    // Token is expired locally OR server validation failed
                    // Try to refresh using refresh token
                    if (refreshToken) {
                        try {
                            const newToken = await refreshWithStoredToken(refreshToken);
                            if (newToken) {
                                // Validate the new token with server before showing app
                                const newTokenValid = await validateTokenWithServer(newToken);
                                if (newTokenValid) {
                                    initializationCompleted = true;
                                    showMainApp();
                                    return true;
                                }
                            }
                        } catch (refreshError) {
                        }
                    }
                    
                    // If refresh fails or no refresh token, clear everything
                    localStorage.removeItem('token');
                    localStorage.removeItem('refreshToken');
                    initializationCompleted = true;
                    showLoginFallback();
                    return false;
                }
                
                // If no tokens at all, return false
                return false;
                
            } catch (error) {
                localStorage.removeItem('token');
                localStorage.removeItem('refreshToken');
                initializationCompleted = true;
                showLoginFallback();
                return false;
            }
        }

        // Helper function to validate token with server
        async function validateTokenWithServer(token) {
            try {
                // Create API instance with the token
                const tempApi = new ApiClient(token);
                
                // Use the existing getUserProfile method which handles 404/create flow
                const profileData = await tempApi.getUserProfile();
                if (profileData) {
                    // Cache the user profile
                    userProfile = profileData;
                    return true;
                }
                return false;
            } catch (error) {
                // Check if it's an authentication error (401/403) vs other errors
                if (error.message.includes('401') || error.message.includes('403')) {
                    return false;
                } else {
                    return false;
                }
            }
        }

        // Helper function to refresh token using stored refresh token
        async function refreshWithStoredToken(refreshToken) {
            try {
                
                const response = await fetch(`${KEYCLOAK_CONFIG.url}/realms/${KEYCLOAK_CONFIG.realm}/protocol/openid-connect/token`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: new URLSearchParams({
                        'grant_type': 'refresh_token',
                        'client_id': KEYCLOAK_CONFIG.clientId,
                        'refresh_token': refreshToken
                    })
                });
                
                if (response.ok) {
                    const tokenData = await response.json();
                    localStorage.setItem('token', tokenData.access_token);
                    localStorage.setItem('refreshToken', tokenData.refresh_token);
                    return tokenData.access_token;
                } else {
                    const errorData = await response.json();
                    console.error('❌ Refresh token response error:', errorData);
                    throw new Error('Refresh token request failed: ' + (errorData.error_description || errorData.error));
                }
            } catch (error) {
                console.error('❌ Refresh token exchange failed:', error);
                throw error;
            }
        }
        
        async function initKeycloakAuth() {
            // Prevent multiple concurrent initializations
            if (initializationInProgress || initializationCompleted || keycloakInitAttempted) {
                return;
            }
            
            initializationInProgress = true;
            keycloakInitAttempted = true;
            
            // Check if Keycloak library is loaded
            if (typeof Keycloak === 'undefined') {
                console.error('Keycloak library not loaded');
                initializationInProgress = false;
                showKeycloakError();
                return;
            }
            
            // First check if Keycloak server is available
            const isKeycloakAvailable = await checkKeycloakAvailability();
            
            if (!isKeycloakAvailable) {
                console.error('❌ Keycloak server not available at:', KEYCLOAK_CONFIG.url);
                console.error('Please check:');
                console.error('1. Keycloak server is running');
                console.error('2. Server is accessible at', KEYCLOAK_CONFIG.url);
                console.error('3. No firewall or proxy blocking the connection');
                
                initializationInProgress = false;
                showKeycloakError();
                return;
            }
            
            
            // Reset keycloak instance
            keycloakInstance = null;
            authMode = 'keycloak';
            
            try {
                
                // Validate configuration before creating instance
                if (!KEYCLOAK_CONFIG.url) {
                    throw new Error('Keycloak URL is missing in configuration');
                }
                if (!KEYCLOAK_CONFIG.realm) {
                    throw new Error('Keycloak realm is missing in configuration');
                }
                if (!KEYCLOAK_CONFIG.clientId) {
                    throw new Error('Keycloak clientId is missing in configuration');
                }
                
                keycloakInstance = new Keycloak(KEYCLOAK_CONFIG);
                
                // Clear any existing Keycloak state that might cause nonce issues
                keycloakInstance.clearToken();
                
                // Clear any Keycloak-related localStorage/sessionStorage
                Object.keys(localStorage).forEach(key => {
                    if (key.includes('keycloak') || key.includes('kc-') || key.includes('auth')) {
                        localStorage.removeItem(key);
                    }
                });
                
                Object.keys(sessionStorage).forEach(key => {
                    if (key.includes('keycloak') || key.includes('kc-') || key.includes('auth')) {
                        sessionStorage.removeItem(key);
                    }
                });
                
                
                // Set a timeout for Keycloak initialization
                const initTimeout = setTimeout(() => {
                    console.error('Keycloak initialization timed out after 10 seconds');
                    initializationInProgress = false;
                    showKeycloakError();
                }, 10000);
                
                keycloakInstance.init({
                    onLoad: undefined, // Don't auto-login or check SSO
                    checkLoginIframe: false,
                    silentCheckSsoRedirectUri: undefined, // Disable silent check
                    enableLogging: true,
                    // Remove PKCE to avoid nonce issues
                    // pkceMethod: 'S256',
                    flow: 'standard', // Use standard flow
                    responseMode: 'query', // Use query mode to avoid fragment issues
                    scope: 'openid profile email'
                }).then(function(authenticated) {
                    clearTimeout(initTimeout);
                    
                    if (authenticated && keycloakInstance.token) {
                        
                        // Store tokens
                        localStorage.setItem('token', keycloakInstance.token);
                        if (keycloakInstance.refreshToken) {
                            localStorage.setItem('refreshToken', keycloakInstance.refreshToken);
                        }
                        
                        // Validate token with server before showing app
                        validateTokenWithServer(keycloakInstance.token).then(tokenValid => {
                            initializationInProgress = false;
                            initializationCompleted = true;
                            if (tokenValid) {
                                showMainApp();
                            } else {
                                // Token invalid, clear and show login
                                localStorage.removeItem('token');
                                localStorage.removeItem('refreshToken');
                                showLoginFallback();
                            }
                        }).catch(error => {
                            initializationInProgress = false;
                            initializationCompleted = true;
                            showLoginFallback();
                        });
                    } else {
                        initializationInProgress = false;
                        initializationCompleted = true;
                        showLoginFallback();
                    }
                }).catch(function(error) {
                    clearTimeout(initTimeout);
                    console.error('Keycloak init promise rejected:', error);
                    console.error('Raw error object:', error);
                    console.error('Error type:', typeof error);
                    console.error('Error constructor:', error?.constructor?.name);
                    
                    // Try to extract any useful information
                    let errorInfo = 'No error information available';
                    if (error) {
                        if (typeof error === 'string') {
                            errorInfo = error;
                        } else if (error.message) {
                            errorInfo = error.message;
                        } else if (error.toString && typeof error.toString === 'function') {
                            try {
                                errorInfo = error.toString();
                            } catch (e) {
                                errorInfo = 'Error in toString()';
                            }
                        }
                    }
                    
                    console.error('Extracted error info:', errorInfo);
                    
                    // Specific handling for nonce/token issues
                    console.error('🔍 This appears to be a nonce/token validation issue.');
                    console.error('Common causes and solutions:');
                    console.error('1. ❌ Invalid/corrupted browser state - Try clearing browser data');
                    console.error('2. ❌ PKCE nonce validation failed - Disabled PKCE in this attempt');
                    console.error('3. ❌ Keycloak client configuration issue');
                    console.error('4. ❌ Browser security policies blocking token validation');
                    console.error('');
                    console.error('🛠️ Troubleshooting steps:');
                    console.error('1. Clear browser cache and cookies');
                    console.error('2. Check Keycloak client settings for "MindBridgeClient"');
                    console.error('3. Ensure client has "Standard Flow" enabled');
                    console.error('4. Check valid redirect URIs in Keycloak client config');
                    
                    // Check if this might be a CORS or network issue
                    if (errorInfo.includes('NetworkError') || errorInfo.includes('CORS') || errorInfo.includes('Failed to fetch')) {
                        console.error('This appears to be a network/CORS issue. Make sure:');
                        console.error('1. Keycloak server is running on', KEYCLOAK_CONFIG.url);
                        console.error('2. CORS is properly configured in Keycloak');
                        console.error('3. The realm "MindBridge" exists');
                        console.error('4. The client "MindBridgeClient" is configured');
                    }
                    
                    initializationInProgress = false;
                    showKeycloakError();
                });
            } catch (error) {
                console.error('Exception during Keycloak instance creation:', error);
                console.error('Raw exception object:', error);
                console.error('Exception type:', typeof error);
                
                // Check if it's a reference error (Keycloak not defined)
                if (error instanceof ReferenceError) {
                    console.error('ReferenceError detected - Keycloak library may not be loaded properly');
                } else if (error instanceof TypeError) {
                    console.error('TypeError detected - Check Keycloak constructor arguments');
                }
                
                initializationInProgress = false;
                showKeycloakError();
            }
        }
        
        async function checkKeycloakAvailability() {
            try {
                const response = await fetch(`${KEYCLOAK_CONFIG.url}/realms/${KEYCLOAK_CONFIG.realm}/.well-known/openid-configuration`, {
                    method: 'GET',
                    mode: 'cors'
                });
                return response.ok;
            } catch (error) {
                return false;
            }
        }
        
        function showMainApp() {
            // Hide loading screen
            const authLoading = document.getElementById('authLoading');
            if (authLoading) {
                authLoading.style.display = 'none';
            }
            
            // Show main app
            const appContainer = document.querySelector('.app-container');
            if (appContainer) {
                appContainer.style.display = 'grid';
            }
            
            // Update user info from Keycloak token

            if (keycloakInstance && keycloakInstance.tokenParsed) {
                updateUserInfoFromKeycloak();
            }
            
            // Initialize user roles and demo mode
            const token = localStorage.getItem('token');
            if (token) {
                userRoles = extractUserRoles(token);
                isDemoMode = isDemoUser();
                
                // Apply demo mode styling if needed
                if (isDemoMode) {
                    addDemoModeIndicator();
                    applyReadOnlyMode();
                }
            }
            
            // Initialize layout and components only once
            if (!window.mainAppInitialized) {
                window.mainAppInitialized = true;
                setTimeout(async () => {
                    // Load user profile FIRST - other APIs depend on it
                    if (typeof loadUserProfile === 'function') {
                        await loadUserProfile();
                    }
                    
                    // Initialize router after user profile is loaded
                    if (typeof initRouter === 'function') {
                        initRouter();
                    }
                    
                    if (typeof initWebSocket === 'function' && !connected) {
                        initWebSocket();
                    }
                    // Chat will be initialized when user navigates to it
                }, 100);
            }
        }
        
        // Layout is now handled by CSS flexbox - no manual adjustments needed
        
        function updateUserInfoFromKeycloak() {
            const userInfo = keycloakInstance.tokenParsed;
            const avatar = document.querySelector('.avatar');
            const userName = document.querySelector('.user-info div:nth-child(2) div:first-child');
            const userId = document.querySelector('.user-info div:nth-child(2) div:last-child');
            
            if (avatar && userName && userId) {
                avatar.textContent = (userInfo.given_name?.[0] || '') + (userInfo.family_name?.[0] || 'U');
                userName.textContent = userInfo.name || userInfo.preferred_username || 'User';
                userId.textContent = `Patient ID: #${userInfo.sub?.slice(-5) || '12345'}`;
            }
        }
        
        function showLoginFallback() {
            // Hide loading screen
            const authLoading = document.getElementById('authLoading');
            if (authLoading) {
                authLoading.style.display = 'none';
            }
            
            const appContainer = document.querySelector('.app-container');
            appContainer.innerHTML = `
                <div style="grid-column: 1 / -1; display: flex; align-items: center; justify-content: center; background: white; border-radius: 20px; padding: 40px;">
                    <div style="width: 100%; max-width: 400px; text-align: center;">
                        <h1 style="color: #4a90e2; margin-bottom: 10px; font-size: 2.5rem;">🧠 MindBridge</h1>
                        
                        
                        <div id="loginError" style="display: none; background: #fee; color: #c33; padding: 10px; border-radius: 5px; margin-bottom: 20px;"></div>
                        
                        <form id="loginForm" style="margin-bottom: 30px;">
                            <input type="text" id="username" placeholder="Username" required 
                                   style="width: 100%; padding: 15px; margin-bottom: 15px; border: 2px solid #e5e7eb; border-radius: 10px; font-size: 16px; box-sizing: border-box;" />
                            <input type="password" id="password" placeholder="Password" required 
                                   style="width: 100%; padding: 15px; margin-bottom: 20px; border: 2px solid #e5e7eb; border-radius: 10px; font-size: 16px; box-sizing: border-box;" />
                            <button type="submit" id="loginBtn" 
                                    style="width: 100%; padding: 15px; background: linear-gradient(45deg, #4a90e2, #357abd); color: white; border: none; border-radius: 10px; font-size: 16px; font-weight: 600; cursor: pointer; margin-bottom: 20px;">
                                Sign In
                            </button>
                        </form>
                        
                        <div style="border-top: 1px solid #e5e7eb; padding-top: 20px; margin-bottom: 20px;">
                            <p style="color: #666; margin-bottom: 15px; font-size: 14px;">OR</p>
                        </div>
                        
                        <button onclick="loginWithGoogle()" 
                                style="width: 100%; padding: 12px; background: #4285f4; color: white; border: none; border-radius: 10px; font-size: 14px; cursor: pointer; margin-bottom: 10px; display: flex; align-items: center; justify-content: center; gap: 10px; font-weight: 500;">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none">
                                <path d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z" fill="white"/>
                                <path d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z" fill="white"/>
                                <path d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z" fill="white"/>
                                <path d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z" fill="white"/>
                            </svg>
                            Continue with Google
                        </button>
                        
                        <button onclick="loginWithGitHub()" 
                                style="width: 100%; padding: 12px; background: #24292e; color: white; border: none; border-radius: 10px; font-size: 14px; cursor: pointer; margin-bottom: 10px; display: flex; align-items: center; justify-content: center; gap: 10px; font-weight: 500;">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599-.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492 .997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                            </svg>
                            Continue with GitHub
                        </button>
                        
                        <div style="border-top: 1px solid #e5e7eb; padding-top: 20px; margin-top: 20px;">
                            <button onclick="loginWithDemo()" 
                                    style="width: 100%; padding: 12px; background: linear-gradient(45deg, #667eea, #764ba2); color: white; border: none; border-radius: 10px; font-size: 14px; cursor: pointer; margin-bottom: 10px; display: flex; align-items: center; justify-content: center; gap: 10px; font-weight: 500;">
                                <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor">
                                    <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                                </svg>
                                Try Demo (Read-Only)
                            </button>
                            <p style="color: #666; font-size: 12px; text-align: center; margin: 0;">
                                Demo mode provides read-only access to explore the platform
                            </p>
                        </div>

                    </div>
                </div>
            `;
            appContainer.style.display = 'flex';
            appContainer.style.alignItems = 'center';
            appContainer.style.justifyContent = 'center';
            
            
            // Add login handlers
            document.getElementById('loginForm').addEventListener('submit', handleDirectLogin);
        }
        
        async function handleDirectLogin(e) {
            e.preventDefault();
            
            const username = document.getElementById('username').value;
            const password = document.getElementById('password').value;
            const loginBtn = document.getElementById('loginBtn');
            const loginError = document.getElementById('loginError');
            
            loginBtn.textContent = 'Signing in...';
            loginBtn.disabled = true;
            loginError.style.display = 'none';
            
            try {
                // Keycloak direct login using Resource Owner Password Credentials Grant
                const formData = new URLSearchParams();
                formData.append('grant_type', 'password');
                formData.append('client_id', KEYCLOAK_CONFIG.clientId);
                formData.append('username', username);
                formData.append('password', password);
                
                const response = await fetch(`${KEYCLOAK_CONFIG.url}/realms/${KEYCLOAK_CONFIG.realm}/protocol/openid-connect/token`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: formData.toString(),
                });
                
                if (response.ok) {
                    const tokenResponse = await response.json();
                    
                    localStorage.setItem('token', tokenResponse.access_token);
                    localStorage.setItem('refreshToken', tokenResponse.refresh_token);
                    
                    location.reload();
                } else {
                    const error = await response.json();
                    throw new Error(error.error_description || error.error || 'Login failed');
                }
            } catch (error) {
                loginError.textContent = error.message || 'Login failed';
                loginError.style.display = 'block';
                loginBtn.textContent = 'Sign In';
                loginBtn.disabled = false;
            }
        }
        
        function showKeycloakError() {
            // Hide loading screen
            const authLoading = document.getElementById('authLoading');
            if (authLoading) {
                authLoading.style.display = 'none';
            }
            
            const appContainer = document.querySelector('.app-container');
            appContainer.innerHTML = `
                <div style="grid-column: 1 / -1; display: flex; align-items: center; justify-content: center; background: white; border-radius: 20px; padding: 40px;">
                    <div style="width: 100%; max-width: 400px; text-align: center;">
                        <h1 style="color: #ef4444; margin-bottom: 10px; font-size: 2.5rem;">🚫 Authentication Error</h1>
                        <p style="color: #666; margin-bottom: 30px; font-size: 1.1rem;">Cannot connect to Keycloak server</p>
                        
                        <div style="background: #fee; color: #c33; padding: 15px; border-radius: 5px; margin-bottom: 20px; text-align: left;">
                            <strong>Keycloak server not found:</strong><br>
                            ${KEYCLOAK_CONFIG.url}<br><br>
                            Please ensure:
                            <ul style="margin: 10px 0; padding-left: 20px;">
                                <li>Keycloak is running</li>
                                <li>Realm '${KEYCLOAK_CONFIG.realm}' exists</li>
                                <li>Client '${KEYCLOAK_CONFIG.clientId}' is configured</li>
                            </ul>
                        </div>
                        
                        
                        <button onclick="location.reload()" 
                                style="width: 100%; padding: 12px; background: #fff3cd; color: #856404; border: 2px solid #ffeaa7; border-radius: 10px; font-size: 14px; cursor: pointer;">
                            🔄 Retry Connection
                        </button>
                    </div>
                </div>
            `;
            appContainer.style.display = 'flex';
        }
        
        
        function getRedirectUri() {
            // Handle different environments (IDE server, local server, etc.)
            const currentUrl = window.location.href;
            if (currentUrl.includes('localhost:63342')) {
                // IntelliJ/WebStorm IDE server - use the actual file URL
                return currentUrl.split('?')[0]; // Remove query parameters
            }
            // For other local servers or direct file access
            return window.location.origin + window.location.pathname;
        }
        
        function loginWithGoogle() {
            const redirectUri = getRedirectUri();
            const googleLoginUrl = `${KEYCLOAK_CONFIG.url}/realms/${KEYCLOAK_CONFIG.realm}/protocol/openid-connect/auth?client_id=${KEYCLOAK_CONFIG.clientId}&redirect_uri=${encodeURIComponent(redirectUri)}&response_type=code&scope=openid email profile&kc_idp_hint=google`;
            window.location.href = googleLoginUrl;
        }
        
        function loginWithGitHub() {
            const redirectUri = getRedirectUri();
            const githubLoginUrl = `${KEYCLOAK_CONFIG.url}/realms/${KEYCLOAK_CONFIG.realm}/protocol/openid-connect/auth?client_id=${KEYCLOAK_CONFIG.clientId}&redirect_uri=${encodeURIComponent(redirectUri)}&response_type=code&scope=openid email profile&kc_idp_hint=github`;
            window.location.href = githubLoginUrl;
        }
        
        async function loginWithDemo() {
            const demoBtn = document.querySelector('button[onclick="loginWithDemo()"]');
            if (demoBtn) {
                demoBtn.textContent = 'Logging in...';
                demoBtn.disabled = true;
            }
            
            try {
                // Use demo credentials
                const formData = new URLSearchParams();
                formData.append('grant_type', 'password');
                formData.append('client_id', KEYCLOAK_CONFIG.clientId);
                formData.append('username', 'demo');
                formData.append('password', 'demo123');
                
                const response = await fetch(`${KEYCLOAK_CONFIG.url}/realms/${KEYCLOAK_CONFIG.realm}/protocol/openid-connect/token`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: formData.toString(),
                });
                
                if (response.ok) {
                    const tokenResponse = await response.json();
                    
                    localStorage.setItem('token', tokenResponse.access_token);
                    localStorage.setItem('refreshToken', tokenResponse.refresh_token);
                    
                    // Extract and set user roles
                    userRoles = extractUserRoles(tokenResponse.access_token);
                    isDemoMode = isDemoUser();
                    
                    location.reload();
                } else {
                    const errorData = await response.json();
                    throw new Error(errorData.error_description || 'Demo login failed');
                }
            } catch (error) {
                console.error('Demo login error:', error);
                if (demoBtn) {
                    demoBtn.textContent = 'Try Demo (Read-Only)';
                    demoBtn.disabled = false;
                }
                
                const loginError = document.getElementById('loginError');
                if (loginError) {
                    loginError.textContent = 'Demo login failed. Please try again.';
                    loginError.style.display = 'block';
                }
            }
        }
        
        function decodeJWT(token) {
            try {
                const base64Url = token.split('.')[1];
                const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
                const jsonPayload = decodeURIComponent(
                    atob(base64)
                        .split('')
                        .map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2))
                        .join('')
                );
                return JSON.parse(jsonPayload);
            } catch (error) {
                console.error('Failed to decode JWT:', error);
                return {};
            }
        }
        
        // Global variables for user roles and demo mode
        let userRoles = [];
        let isDemoMode = false;
        
        // Extract user roles from JWT token
        function extractUserRoles(token) {
            try {
                const payload = decodeJWT(token);
                const resourceAccess = payload.resource_access;
                
                if (!resourceAccess || !resourceAccess.MindBridgeClient) {
                    return [];
                }
                
                const clientRoles = resourceAccess.MindBridgeClient.roles;
                return clientRoles || [];
            } catch (error) {
                console.error('Failed to extract user roles:', error);
                return [];
            }
        }
        
        // Check if current user is a demo user
        function isDemoUser() {
            return userRoles.includes('demo_user');
        }
        
        // Check if current user is in read-only mode
        function isReadOnlyMode() {
            return isDemoUser();
        }
        
        // Add demo mode indicator banner
        function addDemoModeIndicator() {
            // Check if already added
            if (document.getElementById('demoModeIndicator')) {
                return;
            }
            
            const banner = document.createElement('div');
            banner.id = 'demoModeIndicator';
            banner.innerHTML = `
                <div style="background: linear-gradient(90deg, #667eea, #764ba2); color: white; padding: 10px; text-align: center; position: fixed; top: 0; left: 0; right: 0; z-index: 10000; font-size: 14px; font-weight: 500; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                    🎮 Demo Mode - Read-Only Access | Explore the platform without making changes
                </div>
            `;
            
            document.body.appendChild(banner);
            
            // Add padding to body to account for fixed banner
            document.body.style.paddingTop = '50px';
        }
        
        // Apply read-only mode styling and disable interactions
        function applyReadOnlyMode() {
            // Add global CSS for read-only mode
            const style = document.createElement('style');
            style.id = 'readOnlyModeStyles';
            style.textContent = `
                .read-only-disabled {
                    opacity: 0.6 !important;
                    cursor: not-allowed !important;
                    pointer-events: none !important;
                }
                
                .read-only-input {
                    background-color: #f5f5f5 !important;
                    cursor: not-allowed !important;
                    pointer-events: none !important;
                }
                
                .demo-tooltip {
                    position: relative;
                }
                
                .demo-tooltip::after {
                    content: "Demo mode - Read only";
                    position: absolute;
                    bottom: -25px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: #333;
                    color: white;
                    padding: 5px 10px;
                    border-radius: 4px;
                    font-size: 12px;
                    white-space: nowrap;
                    opacity: 0;
                    pointer-events: none;
                    transition: opacity 0.3s;
                    z-index: 1000;
                }
                
                .demo-tooltip:hover::after {
                    opacity: 1;
                }
            `;
            document.head.appendChild(style);
            
            // Apply read-only mode to specific elements after a short delay
            setTimeout(() => {
                disableReadOnlyElements();
            }, 1000);
        }
        
        // Disable specific elements for read-only mode
        function disableReadOnlyElements() {
            if (!isReadOnlyMode()) return;
            
            // Disable "Save Mood Entry" button
            const saveMoodBtn = document.getElementById('saveMoodBtn');
            if (saveMoodBtn) {
                saveMoodBtn.classList.add('read-only-disabled', 'demo-tooltip');
                saveMoodBtn.disabled = true;
            }
            
            // Disable mood tracking submit button (fallback)
            const moodSubmitBtn = document.getElementById('submitMoodBtn');
            if (moodSubmitBtn) {
                moodSubmitBtn.classList.add('read-only-disabled', 'demo-tooltip');
                moodSubmitBtn.disabled = true;
            }
            
            // Disable "New Entry" button for journal
            const newEntryBtn = document.querySelector('button[onclick="showNewJournalForm()"]');
            if (newEntryBtn) {
                newEntryBtn.classList.add('read-only-disabled', 'demo-tooltip');
                newEntryBtn.disabled = true;
            }
            
            // Disable journal form elements
            const journalForm = document.getElementById('journalForm');
            if (journalForm) {
                const inputs = journalForm.querySelectorAll('input, textarea, button[type="submit"]');
                inputs.forEach(input => {
                    input.classList.add('read-only-input');
                    input.disabled = true;
                });
            }
            
            // Disable journal "Edit" and "Delete" buttons
            const journalButtons = document.querySelectorAll('button[onclick*="editJournal"], button[onclick*="deleteJournal"]');
            journalButtons.forEach(btn => {
                btn.classList.add('read-only-disabled', 'demo-tooltip');
                btn.disabled = true;
            });
            
            // Disable chat "Send" button
            const sendButton = document.getElementById('sendButton');
            if (sendButton) {
                sendButton.classList.add('read-only-disabled', 'demo-tooltip');
                sendButton.disabled = true;
            }
            
            // Disable chat input field
            const chatInput = document.getElementById('chatInput');
            if (chatInput) {
                chatInput.classList.add('read-only-input');
                chatInput.disabled = true;
                chatInput.placeholder = 'Demo mode - Chat is read-only';
            }
            
            // Alternative chat input (messageInput)
            const messageInput = document.getElementById('messageInput');
            if (messageInput) {
                messageInput.classList.add('read-only-input');
                messageInput.disabled = true;
                messageInput.placeholder = 'Demo mode - Chat is read-only';
            }
            
            // Disable mood sliders
            const moodSlider = document.getElementById('moodSlider');
            if (moodSlider) {
                moodSlider.classList.add('read-only-input');
                moodSlider.disabled = true;
            }
        }
        
        // Show demo mode alert
        function showDemoModeAlert(message) {
            const alertDiv = document.createElement('div');
            alertDiv.innerHTML = `
                <div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 10001; background: white; padding: 20px; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 400px; text-align: center;">
                    <div style="color: #667eea; font-size: 24px; margin-bottom: 10px;">🎮</div>
                    <h3 style="color: #333; margin-bottom: 10px;">Demo Mode</h3>
                    <p style="color: #666; margin-bottom: 20px;">${message}</p>
                    <button onclick="this.parentElement.parentElement.remove()" style="background: linear-gradient(45deg, #667eea, #764ba2); color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: 500;">
                        OK
                    </button>
                </div>
                <div style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10000;" onclick="this.parentElement.remove()"></div>
            `;
            document.body.appendChild(alertDiv);
            
            // Auto-remove after 3 seconds
            setTimeout(() => {
                if (alertDiv.parentNode) {
                    alertDiv.remove();
                }
            }, 3000);
        }
        
        // Re-apply read-only mode after navigation (call this when switching views)
        function refreshReadOnlyMode() {
            if (isReadOnlyMode()) {
                setTimeout(() => {
                    disableReadOnlyElements();
                }, 500);
            }
        }
        
        // Global logout function for the logout button
        async function keycloakLogout() {
            
            // Prevent multiple logout attempts
            if (window.logoutInProgress) {
                return;
            }
            window.logoutInProgress = true;
            
            // 1. Disconnect WebSocket if connected
            if (typeof stompClient !== 'undefined' && stompClient && stompClient.connected) {
                try {
                    stompClient.deactivate();
                } catch (error) {
                    console.warn('⚠️ Error disconnecting WebSocket:', error);
                }
            }
            
            // 2. Get current token and refresh token before clearing storage
            const currentToken = keycloakInstance?.token || localStorage.getItem('token');
            const currentRefreshToken = keycloakInstance?.refreshToken || localStorage.getItem('refreshToken');
            
            // 3. Handle Keycloak server logout to actually end the session
            if (currentToken) {
                
                try {
                    // First, call the logout endpoint to end the server session
                    const logoutEndpoint = `${KEYCLOAK_CONFIG.url}/realms/${KEYCLOAK_CONFIG.realm}/protocol/openid-connect/logout`;
                    
                    const formData = new URLSearchParams();
                    formData.append('client_id', KEYCLOAK_CONFIG.clientId);
                    if (currentRefreshToken) {
                        formData.append('refresh_token', currentRefreshToken);
                    }
                    
                    const response = await fetch(logoutEndpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                            'Authorization': `Bearer ${currentToken}`
                        },
                        body: formData.toString()
                    });
                    
                    if (response.ok) {
                    } else {
                        console.warn('⚠️ Keycloak logout returned status:', response.status);
                    }
                    
                } catch (fetchError) {
                    console.warn('⚠️ Error calling Keycloak logout endpoint:', fetchError);
                }
            }
            
            // 4. Clear all local data
            localStorage.clear();
            sessionStorage.clear();
            
            // 5. Clear Keycloak instance if it exists
            if (keycloakInstance) {
                try {
                    if (keycloakInstance.clearToken) {
                        keycloakInstance.clearToken();
                    }
                    keycloakInstance.authenticated = false;
                    keycloakInstance.token = null;
                    keycloakInstance.refreshToken = null;
                } catch (error) {
                    console.warn('Error clearing Keycloak instance:', error);
                }
            }
            
            // 6. Reset application state
            if (typeof currentUser !== 'undefined') {
                currentUser = null;
            }
            resetInitializationState();
            
            // 7. Navigate to clean URL with logout flag and clear history
            const cleanUrl = window.location.origin + window.location.pathname + '?logout=true';
            
            // Clear browser history to prevent back navigation to authenticated pages
            // This replaces the current history entry rather than adding a new one
            window.history.replaceState(null, null, cleanUrl);
            
            // Force page reload to show login page
            window.location.reload();
        }
    </script>

    <!-- Router and Navigation System -->
    <script>
        // Router System for View Management
        class AppRouter {
            constructor() {
                this.currentView = 'dashboard';
                this.views = ['dashboard', 'mood', 'journal', 'chat'];
                this.init();
            }

            init() {
                // Handle initial hash or default to dashboard
                this.handleHashChange();
                
                // Listen for hash changes
                window.addEventListener('hashchange', () => this.handleHashChange());
                
                // Add click listeners to navigation items
                this.initNavigation();
            }

            handleHashChange() {
                const hash = window.location.hash.slice(1); // Remove #
                const view = this.views.includes(hash) ? hash : 'dashboard';
                this.navigateToView(view);
            }

            navigateToView(viewName) {
                if (!this.views.includes(viewName)) return;
                
                // Update current view
                this.currentView = viewName;
                
                // Update URL hash
                if (window.location.hash.slice(1) !== viewName) {
                    window.location.hash = viewName;
                }
                
                // Refresh dashboard data when returning to dashboard (user might have added data)
                if (viewName === 'dashboard' && typeof loadDashboardData === 'function') {
                    loadDashboardData().then(() => {
                        updateDashboardDisplay();
                    }).catch(error => {
                        console.error('Failed to refresh dashboard data:', error);
                    });
                }
                
                // Update active navigation item
                this.updateNavigation(viewName);
                
                // Show/hide views
                this.updateViews(viewName);
                
                // Update sidebar components visibility
                this.updateSidebarComponents(viewName);
                
                // Refresh read-only mode for demo users
                if (typeof refreshReadOnlyMode === 'function') {
                    refreshReadOnlyMode();
                }
                
                // Initialize view-specific functionality
                this.initializeViewContent(viewName);
            }

            updateNavigation(activeView) {
                // Remove active class from all nav items
                document.querySelectorAll('.nav-item').forEach(item => {
                    item.classList.remove('active');
                });
                
                // Add active class to current view
                const activeNavItem = document.querySelector(`[data-view="${activeView}"]`);
                if (activeNavItem) {
                    activeNavItem.classList.add('active');
                }
            }

            updateViews(activeView) {
                // Hide all views
                document.querySelectorAll('.view').forEach(view => {
                    view.classList.remove('active');
                });
                
                // Show active view
                const activeViewElement = document.getElementById(`${activeView}-view`);
                if (activeViewElement) {
                    activeViewElement.classList.add('active');
                }
            }

            updateSidebarComponents(activeView) {
                // Future: Add any view-specific sidebar component logic here
            }

            initNavigation() {
                document.querySelectorAll('.nav-item').forEach(item => {
                    // Skip if already has event listener to prevent duplicates
                    if (item.hasNavListener) {
                        return;
                    }
                    
                    const handleClick = (e) => {
                        const viewName = item.getAttribute('data-view');
                        if (viewName) {
                            this.navigateToView(viewName);
                        }
                    };
                    
                    item.addEventListener('click', handleClick);
                    item.hasNavListener = true;
                });
            }

            initializeViewContent(viewName) {
                // Track initialized views to prevent duplicate API calls
                if (!this.initializedViews) {
                    this.initializedViews = new Set();
                }
                
                // Initialize view-specific content and functionality
                switch (viewName) {
                    case 'dashboard':
                        if (typeof initDashboard === 'function' && !this.initializedViews.has('dashboard')) {
                            this.initializedViews.add('dashboard');
                            initDashboard();
                        }
                        break;
                    case 'mood':
                        if (typeof initMoodTracking === 'function' && !this.initializedViews.has('mood')) {
                            this.initializedViews.add('mood');
                            initMoodTracking();
                        }
                        break;
                    case 'journal':
                        if (typeof initJournalEntry === 'function' && !this.initializedViews.has('journal')) {
                            this.initializedViews.add('journal');
                            initJournalEntry();
                        }
                        break;
                    case 'chat':
                        if (typeof initChatView === 'function' && !this.initializedViews.has('chat')) {
                            this.initializedViews.add('chat');
                            initChatView();
                        }
                        break;
                }
            }

            getCurrentView() {
                return this.currentView;
            }
            
            // Method to reset initialized views if needed (e.g., on logout/login)
            resetInitializedViews() {
                this.initializedViews = new Set();
            }
        }

        // Initialize router when DOM is ready
        let appRouter;
        
        // Function to initialize the router (called after authentication)
        function initRouter() {
            if (!appRouter) {
                appRouter = new AppRouter();
            }
        }

        // Make router globally accessible
        window.navigateTo = function(viewName) {
            if (appRouter) {
                appRouter.navigateToView(viewName);
            }
        };
        
        // Global showView function for onboarding buttons
        window.showView = function(viewName) {
            if (appRouter) {
                appRouter.navigateToView(viewName);
            }
        };
    </script>

    <!-- User Profile and API Client -->
    <script>
        // API Client for User Profile and other endpoints
        class ApiClient {
            constructor() {
                this.baseUrl = API_CONFIG.backendUrl + '/v1/agent';
            }

            async makeRequest(endpoint, options = {}) {
                const url = `${this.baseUrl}${endpoint}`;
                const token = keycloakInstance?.token || localStorage.getItem('token');
                
                const headers = {
                    'Content-Type': 'application/json',
                    ...options.headers
                };
                
                if (token) {
                    headers['Authorization'] = `Bearer ${token}`;
                }
                
                try {
                    const response = await fetch(url, {
                        ...options,
                        headers
                    });
                    
                    // Handle 401 (token expired)
                    if (response.status === 401) {
                        const newToken = await this.refreshTokenIfNeeded();
                        if (newToken) {
                            headers['Authorization'] = `Bearer ${newToken}`;
                            return fetch(url, { ...options, headers });
                        } else {
                            throw new Error('Authentication failed');
                        }
                    }
                    
                    return response;
                } catch (error) {
                    console.error('API request failed:', error);
                    throw error;
                }
            }

            async refreshTokenIfNeeded() {
                if (typeof refreshTokenAfterExpiry === 'function') {
                    try {
                        return await refreshTokenAfterExpiry();
                    } catch (error) {
                        console.error('Token refresh failed:', error);
                        return null;
                    }
                }
                return null;
            }

            // User Profile endpoints
            async getUserProfile() {
                const response = await this.makeRequest('/user/profile');
                if (response.ok) {
                    return await response.json();
                } else if (response.status === 404) {
                    // Profile doesn't exist, create it
                    return await this.createUserProfile();
                } else {
                    throw new Error(`Failed to fetch user profile: ${response.status}`);
                }
            }

            async createUserProfile() {
                const response = await this.makeRequest('/user/profile', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                if (response.ok) {
                    return await response.json();
                } else {
                    throw new Error(`Failed to create user profile: ${response.status}`);
                }
            }

            // Mood endpoints
            async getMoodHistory(page = 0, size = 20) {
                const response = await this.makeRequest(`/mood/history?page=${page}&size=${size}`);
                if (response.ok) {
                    return await response.json();
                } else {
                    throw new Error(`Failed to fetch mood history: ${response.status}`);
                }
            }

            async getMoodTrends(startDate, endDate) {
                let url = '/mood/trends';
                const params = new URLSearchParams();
                if (startDate) params.append('startDate', startDate);
                if (endDate) params.append('endDate', endDate);
                if (params.toString()) url += '?' + params.toString();
                
                const response = await this.makeRequest(url);
                if (response.ok) {
                    return await response.json();
                } else {
                    throw new Error(`Failed to fetch mood trends: ${response.status}`);
                }
            }

            async getDashboardMoodTrends(startDate, endDate) {
                let url = '/dashboard/mood/trends';
                const params = new URLSearchParams();
                if (startDate) params.append('startDate', startDate);
                if (endDate) params.append('endDate', endDate);
                if (params.toString()) url += '?' + params.toString();
                
                const response = await this.makeRequest(url);
                if (response.ok) {
                    return await response.json();
                } else {
                    throw new Error(`Failed to fetch dashboard mood trends: ${response.status}`);
                }
            }

            async getDashboardMoodInsight(startDate, endDate) {
                let url = '/dashboard/mood/insight';
                const params = new URLSearchParams();
                if (startDate) params.append('startDate', startDate);
                if (endDate) params.append('endDate', endDate);
                if (params.toString()) url += '?' + params.toString();
                
                const response = await this.makeRequest(url);
                if (response.ok) {
                    return await response.json();
                } else {
                    throw new Error(`Failed to fetch dashboard mood insight: ${response.status}`);
                }
            }

            async createMoodEntry(moodData) {
                const response = await this.makeRequest('/mood', {
                    method: 'POST',
                    body: JSON.stringify(moodData)
                });
                if (response.ok) {
                    return await response.json();
                } else {
                    throw new Error(`Failed to create mood entry: ${response.status}`);
                }
            }

            // Journal endpoints
            async getJournalEntries(page = 0, size = 20) {
                const response = await this.makeRequest(`/journal?page=${page}&size=${size}`);
                if (response.ok) {
                    return await response.json();
                } else {
                    throw new Error(`Failed to fetch journal entries: ${response.status}`);
                }
            }

            async createJournalEntry(journalData) {
                const response = await this.makeRequest('/journal', {
                    method: 'POST',
                    body: JSON.stringify(journalData)
                });
                if (response.ok) {
                    return await response.json();
                } else {
                    throw new Error(`Failed to create journal entry: ${response.status}`);
                }
            }

            async updateJournalEntry(code, journalData) {
                const response = await this.makeRequest(`/journal/${code}`, {
                    method: 'PUT',
                    body: JSON.stringify(journalData)
                });
                if (response.ok) {
                    return await response.json();
                } else {
                    throw new Error(`Failed to update journal entry: ${response.status}`);
                }
            }

            async deleteJournalEntry(code) {
                const response = await this.makeRequest(`/journal/${code}`, {
                    method: 'DELETE'
                });
                if (!response.ok) {
                    throw new Error(`Failed to delete journal entry: ${response.status}`);
                }
            }

            async searchJournalEntries(query) {
                const response = await this.makeRequest(`/journal/search?query=${encodeURIComponent(query)}`);
                if (response.ok) {
                    return await response.json();
                } else {
                    throw new Error(`Failed to search journal entries: ${response.status}`);
                }
            }
        }

        // Global API client instance
        const apiClient = new ApiClient();


        // User Profile Management
        let userProfile = null;

        async function loadUserProfile() {
            try {
                // Use cached profile if available from token validation
                if (!userProfile) {
                    userProfile = await apiClient.getUserProfile();
                }
                updateUserProfileDisplay();
            } catch (error) {
                console.error('Failed to load user profile:', error);
                // Show fallback if profile loading fails
                updateUserProfileDisplay({
                    username: 'User',
                    email: 'user@example.com',
                    therapyStatus: 'ACTIVE'
                });
            }
        }

        function updateUserProfileDisplay(profile = userProfile) {
            if (!profile) return;
            
            // Update header display
            const userAvatar = document.getElementById('userAvatar');
            const userName = document.getElementById('userName');
            const userInfo = document.getElementById('userInfo');
            const dashboardUserName = document.getElementById('dashboardUserName');
            
            if (userAvatar && profile.username) {
                // Create initials from username
                const initials = profile.username
                    .split(' ')
                    .map(name => name.charAt(0))
                    .join('')
                    .toUpperCase()
                    .slice(0, 2);
                userAvatar.textContent = initials;
            }
            
            if (userName) {
                userName.textContent = profile.username || 'User';
            }
            
            if (userInfo) {
                userInfo.textContent = profile.email || '';
            }
            
            if (dashboardUserName) {
                dashboardUserName.textContent = profile.username || 'User';
            }
        }

        // Initialize user profile loading (called after authentication)
        function initUserProfile() {
            if (window.mainAppInitialized) {
                loadUserProfile();
            }
        }
    </script>

    <!-- Dashboard Module -->
    <script>
        // Dashboard functionality
        let dashboardData = {
            recentMood: null,
            journalCount: 0,
            recentMoodEntries: [],
            recentJournalEntries: []
        };

        // Dashboard state management
        let dashboardState = {
            selectedPeriod: 7, // Default to 7 days
            startDate: null,
            endDate: null
        };

        // Calculate date range based on selected period
        function calculateDateRange(days) {
            const endDate = new Date();
            const startDate = new Date();
            startDate.setDate(endDate.getDate() - days);
            
            const result = {
                startDate: startDate.toISOString().split('T')[0],
                endDate: endDate.toISOString().split('T')[0]
            };
            
            
            return result;
        }

        // Period change handler
        function onPeriodChange() {
            const selector = document.getElementById('periodSelector');
            if (!selector) return;
            
            dashboardState.selectedPeriod = parseInt(selector.value);
            const dateRange = calculateDateRange(dashboardState.selectedPeriod);
            dashboardState.startDate = dateRange.startDate;
            dashboardState.endDate = dateRange.endDate;
            
            // Show loading state
            const chartContainer = document.getElementById('moodChart');
            if (chartContainer) {
                chartContainer.innerHTML = '<div style="display: flex; justify-content: center; align-items: center; height: 100%; color: #666;">Loading mood trend...</div>';
            }
            
            // Reload dashboard data with new period
            loadDashboardData().then(() => {
                updateDashboardDisplay();
            }).catch(error => {
                console.error('Failed to reload dashboard data:', error);
                // Clear loading state on error
                const chartContainer = document.getElementById('moodChart');
                if (chartContainer) {
                    chartContainer.innerHTML = '<div style="display: flex; justify-content: center; align-items: center; height: 100%; color: #666;">Failed to load mood data</div>';
                }
            });
        }

        async function initDashboard() {
            // Initialize date range for default period
            const dateRange = calculateDateRange(dashboardState.selectedPeriod);
            dashboardState.startDate = dateRange.startDate;
            dashboardState.endDate = dateRange.endDate;
            
            await loadDashboardData();
            updateDashboardDisplay();
            
            // Initialize insights panel empty state
            initializeInsightsPanel();
        }

        // Helper function to check if a date is today
        function isToday(date) {
            const today = new Date();
            const checkDate = new Date(date);
            return checkDate.getDate() === today.getDate() &&
                   checkDate.getMonth() === today.getMonth() &&
                   checkDate.getFullYear() === today.getFullYear();
        }

        async function loadDashboardData() {
            try {
                // Start all API calls in parallel for better performance
                const [moodHistory, journalHistory, dashboardTrends] = await Promise.all([
                    apiClient.getMoodHistory(0, 30),
                    apiClient.getJournalEntries(0, 20),
                    apiClient.getDashboardMoodTrends(dashboardState.startDate, dashboardState.endDate)
                ]);

                // Process mood history data
                dashboardData.recentMoodEntries = moodHistory.content || [];
                
                // Find today's mood entry specifically
                dashboardData.recentMood = null;
                if (dashboardData.recentMoodEntries.length > 0) {
                    const todaysMood = dashboardData.recentMoodEntries.find(entry => isToday(entry.createdAt));
                    if (todaysMood) {
                        dashboardData.recentMood = todaysMood;
                    }
                }

                // Process journal data
                dashboardData.recentJournalEntries = journalHistory.content || [];
                dashboardData.journalCount = journalHistory.totalElements || 0;

                // Check if user is new (no mood or journal data)
                const hasMoodData = dashboardData.recentMoodEntries.length > 0;
                const hasJournalData = dashboardData.journalCount > 0;
                dashboardData.isNewUser = !hasMoodData && !hasJournalData;
                

                // Use server-side trend data instead of client-side calculation
                dashboardData.serverTrends = dashboardTrends;
                
                dashboardData.analytics = {
                    weeklyAverage: dashboardTrends.averageMoodScore || 0,
                    highestScore: dashboardTrends.highestMoodScore || 0,
                    lowestScore: dashboardTrends.lowestMoodScore || 0,
                    commonTags: dashboardTrends.commonMoodTags || [],
                    moodTrendData: dashboardTrends.moodTrendData || {},
                    // Use client-side selected period instead of server period
                    period: dashboardState.selectedPeriod ? `${dashboardState.selectedPeriod} days` : '7 days',
                    // Keep some client-side calculations for fallback
                    last7Days: calculateMoodAnalytics(dashboardData.recentMoodEntries).last7Days || []
                };
                

            } catch (error) {
                console.error('Failed to load dashboard data:', error);
                // Use fallback data with client-side analytics
                const fallbackAnalytics = calculateMoodAnalytics(dashboardData.recentMoodEntries || []);
                dashboardData = {
                    recentMood: null,
                    journalCount: 0,
                    recentMoodEntries: [],
                    recentJournalEntries: [],
                    serverTrends: null,
                    analytics: fallbackAnalytics || { 
                        weeklyAverage: 0, 
                        trend: 'neutral', 
                        last7Days: [],
                        highestScore: 0,
                        lowestScore: 0,
                        commonTags: [],
                        moodTrendData: {},
                        period: dashboardState.selectedPeriod ? `${dashboardState.selectedPeriod} days` : '7 days'
                    }
                };
                
                // Ensure display gets updated even on error
                if (typeof updateDashboardDisplay === 'function') {
                    updateDashboardDisplay();
                }
            }
        }

        // Show onboarding guidance for new users
        function showOnboardingGuidance() {
            // Hide insights section completely - find by the heading text
            const insightsHeading = [...document.querySelectorAll('h2')].find(h => h.textContent.includes('Your Wellness Insights'));
            
            if (insightsHeading) {
                const insightsSection = insightsHeading.closest('div[style*="linear-gradient"]');
                if (insightsSection) {
                    insightsSection.style.display = 'none';
                } else {
                }
            } else {
            }
            
            // Hide mood trend chart section for new users
            const moodTrendHeading = [...document.querySelectorAll('h2')].find(h => h.textContent.includes('Mood Trend'));
            if (moodTrendHeading) {
                const moodTrendSection = moodTrendHeading.closest('div[style*="background: white"]');
                if (moodTrendSection) {
                    moodTrendSection.style.display = 'none';
                    
                    // Only create onboarding card if it doesn't exist
                    if (!document.getElementById('onboarding-card')) {
                        // Insert onboarding card after the hidden mood trend section
                        const onboardingCard = document.createElement('div');
                        onboardingCard.id = 'onboarding-card';
                        onboardingCard.style.cssText = 'background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 15px; padding: 40px; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); margin-bottom: 30px; text-align: center; color: white;';
                        onboardingCard.innerHTML = `
                            <div style="font-size: 48px; margin-bottom: 20px;">🎯</div>
                            <h2 style="color: white; margin-bottom: 15px; font-size: 24px;">Welcome to MindBridge!</h2>
                            <p style="margin-bottom: 30px; font-size: 16px; line-height: 1.5; color: rgba(255,255,255,0.9);">
                                Start your wellness journey by tracking your first mood and creating a journal entry.
                            </p>
                            <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                                <button onclick="showView('mood')" 
                                        style="background: rgba(255,255,255,0.2); color: white; border: 2px solid rgba(255,255,255,0.3); border-radius: 12px; padding: 15px 25px; font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; gap: 8px;"
                                        onmouseover="this.style.background='rgba(255,255,255,0.3)'; this.style.transform='translateY(-2px)'"
                                        onmouseout="this.style.background='rgba(255,255,255,0.2)'; this.style.transform='translateY(0px)'">
                                    <span>😊</span> Track Your First Mood
                                </button>
                                <button onclick="showView('journal')" 
                                        style="background: rgba(255,255,255,0.2); color: white; border: 2px solid rgba(255,255,255,0.3); border-radius: 12px; padding: 15px 25px; font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; gap: 8px;"
                                        onmouseover="this.style.background='rgba(255,255,255,0.3)'; this.style.transform='translateY(-2px)'"
                                        onmouseout="this.style.background='rgba(255,255,255,0.2)'; this.style.transform='translateY(0px)'">
                                    <span>📝</span> Write Your First Journal
                                </button>
                            </div>
                            <p style="margin-top: 25px; font-size: 14px; color: rgba(255,255,255,0.7);">
                                Once you've added some data, you'll see beautiful insights and trends here!
                            </p>
                        `;
                        moodTrendSection.parentNode.insertBefore(onboardingCard, moodTrendSection);
                    }
                } else {
                }
            } else {
            }
            
            // Update mood card with onboarding message
            const recentMoodScore = document.getElementById('recentMoodScore');
            const recentMoodDate = document.getElementById('recentMoodDate');
            const todayMoodEmoji = document.getElementById('todayMoodEmoji');
            
            if (recentMoodScore) recentMoodScore.textContent = '?';
            if (todayMoodEmoji) todayMoodEmoji.textContent = '🌟';
            if (recentMoodDate) recentMoodDate.textContent = 'Start your journey!';
            
            // Update analytics with onboarding message
            const weeklyMoodAvg = document.getElementById('weeklyMoodAvg');
            const moodTrendIcon = document.getElementById('moodTrendIcon');
            const moodTrendText = document.getElementById('moodTrendText');
            const periodLabel = document.getElementById('periodLabel');
            
            if (weeklyMoodAvg) weeklyMoodAvg.textContent = '-';
            if (moodTrendIcon) moodTrendIcon.textContent = '📈';
            if (moodTrendText) moodTrendText.textContent = 'Start tracking to see trends';
            if (periodLabel) periodLabel.textContent = 'Welcome';
        }

        // Create tabbed interface for insights
        function createInsightTabs(emotionalContent, trendContent) {
            const container = document.getElementById('dailyInsight');
            if (!container) return;
            
            container.innerHTML = `
                <div class="insight-tabs">
                    <div class="tab-buttons" style="display: flex; margin-bottom: 15px; border-bottom: 1px solid rgba(255,255,255,0.2);">
                        <button class="tab-btn active" onclick="showInsightTab('emotional')" 
                                style="background: none; border: none; color: white; padding: 10px 20px; cursor: pointer; border-bottom: 2px solid rgba(255,255,255,0.8); font-weight: 600;">
                            🧠 Emotional Analysis
                        </button>
                        <button class="tab-btn" onclick="showInsightTab('trend')" 
                                style="background: none; border: none; color: rgba(255,255,255,0.6); padding: 10px 20px; cursor: pointer; border-bottom: 2px solid transparent; font-weight: 600;">
                            📈 Trend Analysis
                        </button>
                    </div>
                    <div class="tab-content">
                        <div id="emotional-tab" class="tab-pane active" style="font-size: 16px; line-height: 1.6; opacity: 0.9;">
                            ${emotionalContent}
                        </div>
                        <div id="trend-tab" class="tab-pane" style="font-size: 16px; line-height: 1.6; opacity: 0.9; display: none;">
                            ${trendContent}
                        </div>
                    </div>
                </div>
            `;
        }
        
        // Switch between insight tabs
        function showInsightTab(tabName) {
            // Update button states
            const buttons = document.querySelectorAll('.tab-btn');
            buttons.forEach(btn => {
                btn.style.color = 'rgba(255,255,255,0.6)';
                btn.style.borderBottomColor = 'transparent';
                btn.classList.remove('active');
            });
            
            // Update content visibility
            const panes = document.querySelectorAll('.tab-pane');
            panes.forEach(pane => {
                pane.style.display = 'none';
                pane.classList.remove('active');
            });
            
            // Show selected tab
            const selectedBtn = event.target;
            const selectedPane = document.getElementById(`${tabName}-tab`);
            
            if (selectedBtn && selectedPane) {
                selectedBtn.style.color = 'white';
                selectedBtn.style.borderBottomColor = 'rgba(255,255,255,0.8)';
                selectedBtn.classList.add('active');
                selectedPane.style.display = 'block';
                selectedPane.classList.add('active');
            }
        }

        // Manual insight request function
        async function requestInsights() {
            const insightContainer = document.getElementById('dailyInsight');
            const additionalContainer = document.getElementById('additionalInsights');
            const generateBtn = document.getElementById('generateInsightsBtn');
            
            // Check if user has enough data for insights
            const hasMoodData = dashboardData.recentMoodEntries && dashboardData.recentMoodEntries.length > 0;
            const hasServerData = dashboardData.analytics && dashboardData.analytics.moodTrendData && 
                                  Object.keys(dashboardData.analytics.moodTrendData).length > 0;
            
            if (!hasMoodData && !hasServerData) {
                // Show empty state message
                if (insightContainer) {
                    insightContainer.innerHTML = '📊 Start tracking your mood to unlock personalized insights and AI-powered wellness analysis.';
                }
                if (additionalContainer) {
                    additionalContainer.innerHTML = '';
                }
                return;
            }
            
            try {
                // Update button and show loading state
                if (generateBtn) {
                    generateBtn.textContent = 'Generating...';
                    generateBtn.disabled = true;
                    generateBtn.style.opacity = '0.6';
                    generateBtn.style.cursor = 'not-allowed';
                }
                
                if (insightContainer) {
                    insightContainer.innerHTML = '🧠 Analyzing your mood patterns...';
                }
                
                if (additionalContainer) {
                    additionalContainer.innerHTML = '';
                }
                
                // Load server insights (can take a few seconds)
                const insightData = await apiClient.getDashboardMoodInsight(dashboardState.startDate, dashboardState.endDate);
                
                if (insightData && (insightData.emotionalState || insightData.trendAnalysis)) {
                    // Parse markdown content with modern renderer
                    const parsedEmotional = insightData.emotionalState ? formatMarkdown(insightData.emotionalState) : null;
                    const parsedTrend = insightData.trendAnalysis ? formatMarkdown(insightData.trendAnalysis) : null;
                    
                    
                    // If both insights are available, create tabs
                    if (parsedTrend && parsedEmotional && insightContainer) {
                        createInsightTabs(parsedEmotional, parsedTrend);
                    } else if (parsedTrend && insightContainer) {
                        // Only trend analysis available
                        insightContainer.innerHTML = parsedTrend;
                        if (additionalContainer) {
                            additionalContainer.innerHTML = '';
                        }
                    } else if (parsedEmotional && insightContainer) {
                        // Only emotional state available
                        insightContainer.innerHTML = parsedEmotional;
                        if (additionalContainer) {
                            additionalContainer.innerHTML = '';
                        }
                    }
                    
                    // Update button to show refresh option
                    if (generateBtn) {
                        generateBtn.textContent = 'Refresh Insights';
                        generateBtn.disabled = false;
                        generateBtn.style.opacity = '1';
                        generateBtn.style.cursor = 'pointer';
                    }
                } else {
                    // Fallback to client-side insights
                    loadClientSideInsights();
                }
                
            } catch (error) {
                console.warn('Failed to load server insights, using client-side fallback:', error);
                
                // Show error and fallback to client-side insights
                if (insightContainer) {
                    insightContainer.innerHTML = '⚠️ Unable to generate AI insights. Here are some basic observations:';
                }
                
                loadClientSideInsights();
                
                // Reset button
                if (generateBtn) {
                    generateBtn.textContent = 'Try Again';
                    generateBtn.disabled = false;
                    generateBtn.style.opacity = '1';
                    generateBtn.style.cursor = 'pointer';
                }
            }
        }

        // Initialize insights panel on dashboard load
        function initializeInsightsPanel() {
            const insightContainer = document.getElementById('dailyInsight');
            const additionalContainer = document.getElementById('additionalInsights');
            
            // Check if user has any mood data
            const hasMoodData = dashboardData.recentMoodEntries && dashboardData.recentMoodEntries.length > 0;
            const hasServerData = dashboardData.analytics && dashboardData.analytics.moodTrendData && 
                                  Object.keys(dashboardData.analytics.moodTrendData).length > 0;
            
            if (!hasMoodData && !hasServerData) {
                if (insightContainer) {
                    insightContainer.innerHTML = '💭 Your personalized insights will appear here once you start tracking your mood.';
                }
            } else {
                if (insightContainer) {
                    insightContainer.innerHTML = '🔍 Ready to analyze your mood patterns for meaningful insights.';
                }
            }
            
            if (additionalContainer) {
                additionalContainer.innerHTML = '';
            }
        }

        // Load client-side insights as fallback
        function loadClientSideInsights() {
            const insightContainer = document.getElementById('dailyInsight');
            const additionalContainer = document.getElementById('additionalInsights');
            
            const allInsights = generateDataDrivenInsights();
            
            if (allInsights.length > 0) {
                // Show the first insight as main insight
                if (insightContainer && allInsights.length > 0) {
                    insightContainer.innerHTML = allInsights[0];
                }
                
                // Show additional insights
                if (additionalContainer && allInsights.length > 1) {
                    const insightsHtml = allInsights.slice(1, 4).map(insight => 
                        `• ${insight}`
                    ).join('<br>');
                    additionalContainer.innerHTML = insightsHtml;
                }
            } else {
                // No insights available
                if (insightContainer) {
                    insightContainer.innerHTML = '📈 Track your mood for a few days to see personalized insights and patterns.';
                }
                if (additionalContainer) {
                    additionalContainer.innerHTML = '';
                }
            }
        }

        function updateDashboardDisplay() {
            
            // Check if user is new and show onboarding guidance
            if (dashboardData.isNewUser) {
                showOnboardingGuidance();
                return;
            }
            
            
            // Show insights section when user has data
            const insightsHeading = [...document.querySelectorAll('h2')].find(h => h.textContent.includes('Your Wellness Insights'));
            if (insightsHeading) {
                const insightsSection = insightsHeading.closest('div[style*="linear-gradient"]');
                if (insightsSection) {
                    insightsSection.style.display = 'block';
                }
            }
            
            // Show mood trend section when user has data
            const moodTrendHeading = [...document.querySelectorAll('h2')].find(h => h.textContent.includes('Mood Trend'));
            if (moodTrendHeading) {
                const moodTrendSection = moodTrendHeading.closest('div[style*="background: white"]');
                if (moodTrendSection) {
                    moodTrendSection.style.display = 'block';
                }
            }
            
            // Remove onboarding card if it exists
            const onboardingCard = document.getElementById('onboarding-card');
            if (onboardingCard) {
                onboardingCard.remove();
            }
            
            // Update today's mood card
            const recentMoodScore = document.getElementById('recentMoodScore');
            const recentMoodDate = document.getElementById('recentMoodDate');
            const todayMoodEmoji = document.getElementById('todayMoodEmoji');
            
            if (dashboardData.recentMood) {
                if (recentMoodScore) {
                    recentMoodScore.textContent = dashboardData.recentMood.moodScore;
                }
                if (todayMoodEmoji) {
                    todayMoodEmoji.textContent = getMoodEmoji(dashboardData.recentMood.moodScore);
                }
                if (recentMoodDate) {
                    const date = new Date(dashboardData.recentMood.createdAt);
                    recentMoodDate.textContent = date.toLocaleDateString();
                }
            } else {
                if (recentMoodScore) recentMoodScore.textContent = '-';
                if (todayMoodEmoji) todayMoodEmoji.textContent = '😐';
                if (recentMoodDate) recentMoodDate.textContent = 'No entries today';
            }

            // Update period average and trend
            const weeklyMoodAvg = document.getElementById('weeklyMoodAvg');
            const moodTrendIcon = document.getElementById('moodTrendIcon');
            const moodTrendText = document.getElementById('moodTrendText');
            const periodLabel = document.getElementById('periodLabel');
            
            if (dashboardData.analytics) {
                if (weeklyMoodAvg) {
                    weeklyMoodAvg.textContent = dashboardData.analytics.weeklyAverage.toFixed(1);
                }
                
                if (periodLabel) {
                    // Use selected period for consistency
                    let formattedPeriod = 'Period';
                    
                    if (dashboardState.selectedPeriod) {
                        const days = dashboardState.selectedPeriod;
                        if (days === 7) {
                            formattedPeriod = '7-Day';
                        } else if (days === 14) {
                            formattedPeriod = '2-Week';
                        } else if (days === 30) {
                            formattedPeriod = '30-Day';
                        } else if (days === 90) {
                            formattedPeriod = '3-Month';
                        } else {
                            formattedPeriod = `${days}-Day`;
                        }
                    }
                    
                    periodLabel.textContent = formattedPeriod;
                }
                
                if (moodTrendIcon) {
                    moodTrendIcon.textContent = dashboardData.analytics.trend === 'improving' ? '📈' : 
                                               dashboardData.analytics.trend === 'declining' ? '📉' : '📊';
                }
                
                if (moodTrendText) {
                    moodTrendText.textContent = dashboardData.analytics.trend === 'improving' ? 'Trending up!' :
                                               dashboardData.analytics.trend === 'declining' ? 'Needs attention' : 'Stable';
                }
            }

            // Update mood range card
            const lowestMoodScore = document.getElementById('lowestMoodScore');
            const highestMoodScore = document.getElementById('highestMoodScore');
            const rangeText = document.getElementById('rangeText');
            
            if (dashboardData.analytics) {
                if (lowestMoodScore) {
                    lowestMoodScore.textContent = dashboardData.analytics.lowestScore || '-';
                }
                if (highestMoodScore) {
                    highestMoodScore.textContent = dashboardData.analytics.highestScore || '-';
                }
                if (rangeText) {
                    // Use selected period for consistency
                    let formattedPeriod = 'period';
                    
                    if (dashboardState.selectedPeriod) {
                        const days = dashboardState.selectedPeriod;
                        if (days === 7) {
                            formattedPeriod = '7-day';
                        } else if (days === 14) {
                            formattedPeriod = '2-week';
                        } else if (days === 30) {
                            formattedPeriod = '30-day';
                        } else if (days === 90) {
                            formattedPeriod = '3-month';
                        } else {
                            formattedPeriod = `${days}-day`;
                        }
                    }
                    
                    rangeText.textContent = `${formattedPeriod} range`;
                }
            }

            // Update active days count
            const activeDaysCount = document.getElementById('activeDaysCount');
            const totalDaysCount = document.getElementById('totalDaysCount');
            const activeDaysText = document.getElementById('activeDaysText');
            
            if (activeDaysCount && totalDaysCount && activeDaysText) {
                const totalDays = dashboardState.selectedPeriod || 7;
                let activeDays = 0;
                
                // Calculate active days from moodTrendData or recent entries
                if (dashboardData.analytics && dashboardData.analytics.moodTrendData) {
                    // Count days with mood data from server, filtered by selected period
                    const cutoffDate = new Date();
                    cutoffDate.setDate(cutoffDate.getDate() - totalDays);
                    
                    const moodDates = Object.keys(dashboardData.analytics.moodTrendData);
                    activeDays = moodDates.filter(date => {
                        const score = dashboardData.analytics.moodTrendData[date];
                        const entryDate = new Date(date);
                        return (score !== null && score !== undefined) && entryDate >= cutoffDate;
                    }).length;
                } else if (dashboardData.recentMoodEntries) {
                    // Fallback: count unique days from mood entries
                    const uniqueDays = new Set();
                    const cutoffDate = new Date();
                    cutoffDate.setDate(cutoffDate.getDate() - totalDays);
                    
                    dashboardData.recentMoodEntries.forEach(entry => {
                        const entryDate = new Date(entry.createdAt);
                        if (entryDate >= cutoffDate) {
                            const dateStr = entryDate.toISOString().split('T')[0];
                            uniqueDays.add(dateStr);
                        }
                    });
                    activeDays = uniqueDays.size;
                }
                
                activeDaysCount.textContent = activeDays;
                totalDaysCount.textContent = `/ ${totalDays}`;
                
                // Update the description based on consistency
                const percentage = totalDays > 0 ? Math.round((activeDays / totalDays) * 100) : 0;
                if (percentage >= 90) {
                    activeDaysText.textContent = 'excellent consistency!';
                    activeDaysText.style.color = '#16a34a';
                } else if (percentage >= 70) {
                    activeDaysText.textContent = 'great tracking';
                    activeDaysText.style.color = '#ca8a04';
                } else if (percentage >= 50) {
                    activeDaysText.textContent = 'good progress';
                    activeDaysText.style.color = '#ea580c';
                } else {
                    activeDaysText.textContent = 'room to improve';
                    activeDaysText.style.color = '#666';
                }
            }

            // Update chart title and mood tags
            const chartTitle = document.getElementById('chartTitle');
            const chartMoodTags = document.getElementById('chartMoodTags');
            
            if (chartTitle) {
                // Use selected period for title
                let formattedPeriod = 'Mood Trend';
                
                if (dashboardState.selectedPeriod) {
                    const days = dashboardState.selectedPeriod;
                    if (days === 7) {
                        formattedPeriod = '7-Day';
                    } else if (days === 14) {
                        formattedPeriod = '2-Week';
                    } else if (days === 30) {
                        formattedPeriod = '30-Day';
                    } else if (days === 90) {
                        formattedPeriod = '3-Month';
                    } else {
                        formattedPeriod = `${days}-Day`;
                    }
                }
                
                chartTitle.textContent = `${formattedPeriod} Mood Trend`;
            }
            
            // Update mood tags in chart header
            if (chartMoodTags && dashboardData.analytics && dashboardData.analytics.commonTags && dashboardData.analytics.commonTags.length > 0) {
                chartMoodTags.innerHTML = dashboardData.analytics.commonTags.slice(0, 6).map(tag => `
                    <span style="background: #f0f9ff; color: #0369a1; padding: 3px 8px; border-radius: 10px; font-size: 11px; font-weight: 500; border: 1px solid #e0f2fe;">
                        ${tag}
                    </span>
                `).join('');
            } else if (chartMoodTags) {
                chartMoodTags.innerHTML = '';
            }

            // Update mood chart
            updateMoodChart();
            
            // Update recent mood entries
            updateRecentMoodDisplay();

            // Update recent journal entries
            updateRecentJournalDisplay();
        }


        function updateRecentMoodDisplay() {
            const container = document.getElementById('recentMoodEntries');
            if (!container) return;

            if (dashboardData.recentMoodEntries.length === 0) {
                container.innerHTML = '<div style="color: #666; font-style: italic;">No mood entries yet</div>';
                return;
            }

            const entriesHtml = dashboardData.recentMoodEntries.map(entry => {
                const date = new Date(entry.createdAt);
                const moodEmoji = getMoodEmoji(entry.moodScore);
                return `
                    <div style="padding: 8px 0; border-bottom: 1px solid #f0f0f0; display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <span style="font-size: 18px; margin-right: 8px;">${moodEmoji}</span>
                            <span style="font-weight: 500;">${entry.moodScore}/10</span>
                            ${entry.notes ? `<div style="font-size: 12px; color: #666; margin-top: 2px;">${entry.notes}</div>` : ''}
                        </div>
                        <div style="font-size: 12px; color: #999;">
                            ${date.toLocaleDateString()}
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = entriesHtml;
        }

        function updateRecentJournalDisplay() {
            const container = document.getElementById('recentJournalEntries');
            if (!container) return;

            if (dashboardData.recentJournalEntries.length === 0) {
                container.innerHTML = '<div style="color: #666; font-style: italic;">No journal entries yet</div>';
                return;
            }

            const entriesHtml = dashboardData.recentJournalEntries.map(entry => {
                const date = new Date(entry.createdAt);
                const preview = entry.content ? entry.content.substring(0, 100) + '...' : '';
                return `
                    <div style="padding: 8px 0; border-bottom: 1px solid #f0f0f0;">
                        <div style="font-weight: 500; margin-bottom: 4px;">${entry.title || 'Untitled'}</div>
                        <div style="font-size: 12px; color: #666; margin-bottom: 4px;">${preview}</div>
                        <div style="font-size: 12px; color: #999;">
                            ${date.toLocaleDateString()}
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = entriesHtml;
        }

        function getMoodEmoji(score) {
            if (score >= 9) return '😄';
            if (score >= 7) return '😊';
            if (score >= 6) return '🙂';
            if (score >= 5) return '😐';
            if (score >= 3) return '🙁';
            if (score >= 2) return '😞';
            return '😢';
        }

        // Analytics Functions
        function calculateMoodAnalytics(moodEntries) {
            if (!moodEntries || moodEntries.length === 0) {
                return { weeklyAverage: 0, trend: 'neutral', last7Days: [] };
            }

            // Get last 7 days of data
            const now = new Date();
            const last7Days = [];
            
            for (let i = 6; i >= 0; i--) {
                const date = new Date(now);
                date.setDate(date.getDate() - i);
                const dayStart = new Date(date.setHours(0, 0, 0, 0));
                const dayEnd = new Date(date.setHours(23, 59, 59, 999));
                
                const dayEntries = moodEntries.filter(entry => {
                    const entryDate = new Date(entry.createdAt);
                    return entryDate >= dayStart && entryDate <= dayEnd;
                });
                
                const dayAverage = dayEntries.length > 0 
                    ? dayEntries.reduce((sum, entry) => sum + entry.moodScore, 0) / dayEntries.length 
                    : null;
                
                last7Days.push({
                    date: dayStart,
                    average: dayAverage,
                    count: dayEntries.length
                });
            }

            // Calculate weekly average
            const validDays = last7Days.filter(day => day.average !== null);
            const weeklyAverage = validDays.length > 0 
                ? validDays.reduce((sum, day) => sum + day.average, 0) / validDays.length 
                : 0;

            // Determine trend
            let trend = 'neutral';
            if (validDays.length >= 2) {
                const firstHalf = validDays.slice(0, Math.ceil(validDays.length / 2));
                const secondHalf = validDays.slice(Math.floor(validDays.length / 2));
                
                const firstAvg = firstHalf.reduce((sum, day) => sum + day.average, 0) / firstHalf.length;
                const secondAvg = secondHalf.reduce((sum, day) => sum + day.average, 0) / secondHalf.length;
                
                if (secondAvg > firstAvg + 0.5) trend = 'improving';
                else if (secondAvg < firstAvg - 0.5) trend = 'declining';
            }

            return { weeklyAverage, trend, last7Days };
        }


        // Global chart instance
        let moodChart = null;

        function updateMoodChart() {
            const chartContainer = document.getElementById('moodChart');
            if (!chartContainer) {
                console.error('Chart container not found');
                return;
            }
            
            if (!dashboardData.analytics) {
                console.warn('No analytics data available');
                chartContainer.innerHTML = '<div style="display: flex; justify-content: center; align-items: center; height: 200px; color: #666;">No analytics data available</div>';
                return;
            }
            
            // Use server-side moodTrendData if available, otherwise fallback to client-side data
            const moodTrendData = dashboardData.analytics.moodTrendData || {};
            const last7Days = dashboardData.analytics.last7Days || [];
            
            // Prepare data for Chart.js
            const chartData = prepareChartData(moodTrendData, last7Days);
            
            if (chartData.length === 0) {
                chartContainer.innerHTML = '<div style="display: flex; justify-content: center; align-items: center; height: 200px; color: #666;">No mood data available for selected period</div>';
                return;
            }
            
            // Destroy existing chart
            if (moodChart) {
                moodChart.destroy();
                moodChart = null;
            }
            
            // Create canvas element
            chartContainer.innerHTML = '<canvas id="moodChartCanvas" style="height: 200px;"></canvas>';
            const ctx = document.getElementById('moodChartCanvas').getContext('2d');
            
            // Create Chart.js chart
            moodChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Mood Score',
                        data: chartData,
                        borderColor: '#667eea',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        pointBackgroundColor: '#667eea',
                        pointBorderColor: '#ffffff',
                        pointBorderWidth: 2,
                        pointRadius: 6,
                        pointHoverRadius: 8,
                        fill: true,
                        tension: 0.4,
                        spanGaps: false // Don't connect across missing data
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    const date = new Date(context[0].parsed.x);
                                    return date.toLocaleDateString('en-US', { 
                                        weekday: 'short', 
                                        month: 'short', 
                                        day: 'numeric' 
                                    });
                                },
                                label: function(context) {
                                    const value = context.parsed.y;
                                    if (value === null) return 'No mood data';
                                    const emoji = getMoodEmoji(value);
                                    return `${emoji} Mood: ${value}/10`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'day',
                                displayFormats: {
                                    day: 'MMM dd'
                                }
                            },
                            ticks: {
                                maxTicksLimit: 10,
                                color: '#666',
                                font: {
                                    size: 12
                                }
                            },
                            grid: {
                                display: false
                            }
                        },
                        y: {
                            min: 0,
                            max: 10,
                            ticks: {
                                stepSize: 2,
                                color: '#666',
                                font: {
                                    size: 12
                                }
                            },
                            grid: {
                                color: '#e5e7eb'
                            }
                        }
                    }
                }
            });
        }

        function prepareChartData(moodTrendData, last7Days) {
            let chartData = [];
            
            if (Object.keys(moodTrendData).length > 0) {
                // Use server data
                const dateRange = calculateDateRange(dashboardState.selectedPeriod || 7);
                const startDate = new Date(dateRange.startDate);
                const endDate = new Date(dateRange.endDate);
                
                for (let d = new Date(startDate); d <= endDate; d.setDate(d.getDate() + 1)) {
                    const dateStr = d.toISOString().split('T')[0];
                    const score = moodTrendData[dateStr];
                    
                    chartData.push({
                        x: new Date(d),
                        y: (score !== null && score !== undefined) ? score : null
                    });
                }
            } else if (last7Days.length > 0) {
                // Fallback to client data
                chartData = last7Days.map(day => ({
                    x: new Date(day.date),
                    y: (day.average !== null && day.average !== undefined) ? day.average : null
                }));
            }
            
            return chartData;
        }


        function updateDailyInsight() {
            const insightContainer = document.getElementById('dailyInsight');
            const additionalContainer = document.getElementById('additionalInsights');
            if (!insightContainer) return;
            
            const allInsights = generateDataDrivenInsights();
            
            if (allInsights.length > 0) {
                // Show primary insight
                insightContainer.textContent = allInsights[0];
                
                // Show additional insights (up to 2 more)
                if (additionalContainer && allInsights.length > 1) {
                    const additionalInsights = allInsights.slice(1, 3).map(insight => 
                        `• ${insight}`
                    ).join('\n');
                    additionalContainer.textContent = additionalInsights;
                }
            } else {
                insightContainer.textContent = "Track your mood daily to unlock personalized insights about your mental wellness journey.";
                if (additionalContainer) {
                    additionalContainer.textContent = "";
                }
            }
        }

        function generateDailyInsight() {
            // Generate insights based on actual user data
            const insights = generateDataDrivenInsights();
            
            // Return the most relevant insight
            if (insights.length > 0) {
                return insights[0]; // Return the highest priority insight
            }
            
            return "Track your mood daily to unlock personalized insights about your mental wellness journey.";
        }

        function generateDataDrivenInsights() {
            const insights = [];
            
            if (!dashboardData.analytics || dashboardData.recentMoodEntries.length === 0) {
                return insights;
            }
            
            const { trend, weeklyAverage, last7Days } = dashboardData.analytics;
            const moodEntries = dashboardData.recentMoodEntries;
            const journalEntries = dashboardData.recentJournalEntries;
            const todayMood = dashboardData.recentMood;
            
            // 1. Trend analysis insights
            if (trend === 'improving' && weeklyAverage > 6) {
                insights.push(`📈 Excellent! Your mood is trending upward with a ${weeklyAverage.toFixed(1)} average. You're thriving!`);
            } else if (trend === 'improving') {
                insights.push(`📈 Your mood has been improving this week! Keep up the positive momentum.`);
            } else if (trend === 'declining' && weeklyAverage < 4) {
                insights.push(`💙 Your recent scores suggest you might need extra support. Consider reaching out or practicing self-care.`);
            } else if (trend === 'declining') {
                insights.push(`📉 Your mood has dipped recently. Remember, it's normal to have ups and downs.`);
            }
            
            // 2. Today's mood insights
            if (todayMood) {
                if (todayMood.moodScore >= 9) {
                    insights.push(`✨ You're having an exceptional day! This energy is perfect for tackling goals or helping others.`);
                } else if (todayMood.moodScore >= 8) {
                    insights.push(`🌟 You're feeling great today! Consider journaling about what's working well in your life.`);
                } else if (todayMood.moodScore <= 2) {
                    insights.push(`🤗 Today feels tough. Your feelings are valid, and reaching out for support is a sign of strength.`);
                } else if (todayMood.moodScore <= 3) {
                    insights.push(`💙 Tough days are part of the journey. Small acts of self-care can make a difference.`);
                }
                
                // Notes-based insights
                if (todayMood.notes && todayMood.notes.length > 20) {
                    insights.push(`📝 Great job adding detailed notes today! Self-reflection helps build emotional awareness.`);
                }
            }
            
            // 3. Weekly performance insights
            if (weeklyAverage >= 8) {
                insights.push(`🌟 Your weekly average of ${weeklyAverage.toFixed(1)} shows excellent mental wellness! You're doing great.`);
            } else if (weeklyAverage >= 7) {
                insights.push(`😊 Your ${weeklyAverage.toFixed(1)} weekly average shows you're managing your wellness well. Keep it up!`);
            } else if (weeklyAverage >= 5) {
                insights.push(`📊 Your ${weeklyAverage.toFixed(1)} average shows room for growth. Small daily practices can help.`);
            }
            
            // 4. Journaling insights
            const recentJournals = journalEntries.slice(0, 7); // Last 7 entries
            if (recentJournals.length >= 3) {
                const moodImprovements = recentJournals.filter(entry => 
                    entry.moodAfter && entry.moodBefore && entry.moodAfter > entry.moodBefore
                ).length;
                
                if (moodImprovements >= 2) {
                    insights.push(`📖 Journaling is really helping! ${moodImprovements} of your recent entries show mood improvement.`);
                }
            }
            
            if (journalEntries.length >= 5) {
                insights.push(`🖊️ You've written ${journalEntries.length} journal entries! Writing is a powerful tool for mental clarity.`);
            }
            
            // 5. Consistency insights
            const daysWithEntries = last7Days.filter(day => day.count > 0).length;
            if (daysWithEntries >= 5) {
                insights.push(`🗓️ You've tracked your mood ${daysWithEntries} out of 7 days this week. Excellent consistency!`);
            } else if (daysWithEntries >= 3) {
                insights.push(`📅 You've been active ${daysWithEntries} days this week. Try for daily check-ins to see more patterns.`);
            }
            
            // 6. Pattern recognition insights
            const lowMoodDays = moodEntries.filter(entry => entry.moodScore <= 4).length;
            const highMoodDays = moodEntries.filter(entry => entry.moodScore >= 7).length;
            
            if (highMoodDays > lowMoodDays * 2) {
                insights.push(`🌈 You have more high-mood days than low ones recently. You're building resilience!`);
            }
            
            // 7. Engagement insights
            if (moodEntries.length >= 10) {
                insights.push(`📊 With ${moodEntries.length} mood entries, you're building valuable data for self-understanding.`);
            }
            
            // Sort insights by priority (trend > today > weekly > others)
            return insights;
        }

    </script>

    <!-- Mood Tracking Module -->
    <script>
        // Mood tracking functionality
        let moodHistoryData = [];
        let selectedMoodTags = [];

        function initMoodTracking() {
            setupMoodSlider();
            setupMoodTags();
            setupMoodForm();
            loadMoodHistory();
        }

        function setupMoodSlider() {
            const moodSlider = document.getElementById('moodSlider');
            const moodEmoji = document.getElementById('moodEmoji');
            const moodScoreDisplay = document.getElementById('moodScoreDisplay');

            if (moodSlider) {
                moodSlider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    updateMoodDisplay(value);
                });
            }
        }

        function updateMoodDisplay(score) {
            const moodEmoji = document.getElementById('moodEmoji');
            const moodScoreDisplay = document.getElementById('moodScoreDisplay');

            if (moodEmoji) {
                moodEmoji.textContent = getMoodEmoji(score);
            }
            if (moodScoreDisplay) {
                moodScoreDisplay.textContent = score;
            }
        }

        function setupMoodTags() {
            const moodTags = document.querySelectorAll('.mood-tag');
            moodTags.forEach(tag => {
                tag.addEventListener('click', () => {
                    const tagValue = tag.getAttribute('data-tag');
                    toggleMoodTag(tag, tagValue);
                });
            });
        }

        function toggleMoodTag(tagElement, tagValue) {
            if (tagElement.classList.contains('selected')) {
                tagElement.classList.remove('selected');
                selectedMoodTags = selectedMoodTags.filter(tag => tag !== tagValue);
            } else {
                tagElement.classList.add('selected');
                selectedMoodTags.push(tagValue);
            }
        }

        function setupMoodForm() {
            const moodForm = document.getElementById('moodEntryForm');
            if (moodForm) {
                moodForm.addEventListener('submit', handleMoodSubmit);
            }
        }

        async function handleMoodSubmit(e) {
            e.preventDefault();
            
            // Prevent mood submission in demo mode
            if (isReadOnlyMode()) {
                showDemoModeAlert('Mood tracking is disabled in demo mode');
                return;
            }
            
            const moodSlider = document.getElementById('moodSlider');
            const moodNotes = document.getElementById('moodNotes');
            const saveBtn = document.getElementById('saveMoodBtn');

            if (!moodSlider) return;

            const moodData = {
                moodScore: parseInt(moodSlider.value),
                moodTags: selectedMoodTags,
                notes: moodNotes ? moodNotes.value.trim() : ''
            };

            // Disable button and show loading state
            saveBtn.disabled = true;
            saveBtn.textContent = 'Saving...';

            try {
                await apiClient.createMoodEntry(moodData);
                
                // Reset form
                resetMoodForm();
                
                // Reload mood history
                await loadMoodHistory();
                
                // Show success message
                showMoodMessage('Mood entry saved successfully!', 'success');
                
            } catch (error) {
                console.error('Failed to save mood entry:', error);
                showMoodMessage('Failed to save mood entry. Please try again.', 'error');
            } finally {
                // Re-enable button
                saveBtn.disabled = false;
                saveBtn.textContent = 'Save Mood Entry';
            }
        }

        function resetMoodForm() {
            const moodSlider = document.getElementById('moodSlider');
            const moodNotes = document.getElementById('moodNotes');
            const moodTags = document.querySelectorAll('.mood-tag');

            if (moodSlider) {
                moodSlider.value = 5;
                updateMoodDisplay(5);
            }

            if (moodNotes) {
                moodNotes.value = '';
            }

            // Clear selected tags
            moodTags.forEach(tag => tag.classList.remove('selected'));
            selectedMoodTags = [];
        }

        async function loadMoodHistory() {
            const container = document.getElementById('moodHistoryContainer');
            if (!container) return;

            try {
                container.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">Loading mood history...</div>';
                
                const historyData = await apiClient.getMoodHistory(0, 20);
                moodHistoryData = historyData.content || [];
                
                displayMoodHistory();
                
            } catch (error) {
                console.error('Failed to load mood history:', error);
                container.innerHTML = '<div style="text-align: center; color: #ef4444; padding: 20px;">Failed to load mood history</div>';
            }
        }

        function displayMoodHistory() {
            const container = document.getElementById('moodHistoryContainer');
            if (!container) return;

            if (moodHistoryData.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No mood entries yet. Start tracking your mood above!</div>';
                return;
            }

            const historyHtml = moodHistoryData.map(entry => {
                const date = new Date(entry.createdAt);
                const moodEmoji = getMoodEmoji(entry.moodScore);
                const tagsHtml = entry.moodTags && entry.moodTags.length > 0 
                    ? entry.moodTags.map(tag => `<span style="background: #f3f4f6; color: #374151; padding: 2px 8px; border-radius: 12px; font-size: 12px; margin-right: 4px;">${tag}</span>`).join('')
                    : '';

                return `
                    <div style="border: 1px solid #e5e7eb; border-radius: 10px; padding: 20px; margin-bottom: 15px; background: #fafafa;">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                            <div style="display: flex; align-items: center; gap: 12px;">
                                <span style="font-size: 2rem;">${moodEmoji}</span>
                                <div>
                                    <div style="font-size: 1.2rem; font-weight: 600; color: #333;">${entry.moodScore}/10</div>
                                    <div style="font-size: 12px; color: #666;">${date.toLocaleString()}</div>
                                </div>
                            </div>
                        </div>
                        ${tagsHtml ? `<div style="margin-bottom: 10px;">${tagsHtml}</div>` : ''}
                        ${entry.notes ? `<div style="color: #555; font-size: 14px; line-height: 1.5;">${entry.notes}</div>` : ''}
                    </div>
                `;
            }).join('');

            container.innerHTML = historyHtml;
        }

        function showMoodMessage(message, type = 'info') {
            // Create or update message element
            let messageEl = document.getElementById('moodMessage');
            if (!messageEl) {
                messageEl = document.createElement('div');
                messageEl.id = 'moodMessage';
                messageEl.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    padding: 12px 20px;
                    border-radius: 8px;
                    color: white;
                    font-weight: 500;
                    z-index: 1000;
                    opacity: 0;
                    transform: translateY(-20px);
                    transition: all 0.3s ease;
                `;
                document.body.appendChild(messageEl);
            }

            // Set message and style based on type
            messageEl.textContent = message;
            messageEl.style.background = type === 'success' ? '#10b981' : type === 'error' ? '#ef4444' : '#3b82f6';

            // Show message
            setTimeout(() => {
                messageEl.style.opacity = '1';
                messageEl.style.transform = 'translateY(0)';
            }, 10);

            // Hide message after 3 seconds
            setTimeout(() => {
                messageEl.style.opacity = '0';
                messageEl.style.transform = 'translateY(-20px)';
            }, 3000);
        }

        // Note: Mood tracking initialization is now handled by the main navigation system
        // Removed duplicate hash change listener to prevent double API calls
    </script>

    <!-- Journal Management Module -->
    <script>
        // Journal functionality
        let journalData = [];
        let currentEditingEntry = null;

        function initJournalEntry() {
            setupJournalForm();
            setupJournalSearch();
            loadJournalEntries();
        }

        function setupJournalForm() {
            const journalForm = document.getElementById('journalEntryForm');
            if (journalForm) {
                journalForm.addEventListener('submit', handleJournalSubmit);
            }
        }

        function setupJournalSearch() {
            const searchInput = document.getElementById('journalSearch');
            if (searchInput) {
                searchInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        searchJournalEntries();
                    }
                });
            }
        }

        function showNewJournalForm() {
            // Prevent new journal form in demo mode
            if (isReadOnlyMode()) {
                showDemoModeAlert('Creating new journal entries is disabled in demo mode');
                return;
            }
            
            currentEditingEntry = null;
            const form = document.getElementById('journalForm');
            const title = document.getElementById('journalFormTitle');
            
            if (form) form.style.display = 'block';
            if (title) title.textContent = 'Create New Journal Entry';
            
            resetJournalForm();
            
            // Scroll to form
            form.scrollIntoView({ behavior: 'smooth' });
        }

        function hideJournalForm() {
            const form = document.getElementById('journalForm');
            if (form) form.style.display = 'none';
            currentEditingEntry = null;
        }

        function editJournalEntry(entry) {
            // Prevent editing journal entries in demo mode
            if (isReadOnlyMode()) {
                showDemoModeAlert('Editing journal entries is disabled in demo mode');
                return;
            }
            
            currentEditingEntry = entry;
            const form = document.getElementById('journalForm');
            const title = document.getElementById('journalFormTitle');
            
            if (form) form.style.display = 'block';
            if (title) title.textContent = 'Edit Journal Entry';
            
            // Fill form with entry data
            document.getElementById('journalEntryCode').value = entry.code || '';
            document.getElementById('journalTitle').value = entry.title || '';
            document.getElementById('journalContent').value = entry.content || '';
            document.getElementById('moodBefore').value = entry.moodBefore || '';
            document.getElementById('moodAfter').value = entry.moodAfter || '';
            document.getElementById('journalTags').value = entry.tags ? entry.tags.join(', ') : '';
            
            // Scroll to form
            form.scrollIntoView({ behavior: 'smooth' });
        }

        function resetJournalForm() {
            document.getElementById('journalEntryCode').value = '';
            document.getElementById('journalTitle').value = '';
            document.getElementById('journalContent').value = '';
            document.getElementById('moodBefore').value = '';
            document.getElementById('moodAfter').value = '';
            document.getElementById('journalTags').value = '';
        }

        async function handleJournalSubmit(e) {
            e.preventDefault();
            
            // Prevent journal submission in demo mode
            if (isReadOnlyMode()) {
                showDemoModeAlert('Journal editing is disabled in demo mode');
                return;
            }
            
            const saveBtn = document.getElementById('saveJournalBtn');
            const entryCode = document.getElementById('journalEntryCode').value;
            const title = document.getElementById('journalTitle').value.trim();
            const content = document.getElementById('journalContent').value.trim();
            const moodBefore = document.getElementById('moodBefore').value;
            const moodAfter = document.getElementById('moodAfter').value;
            const tagsInput = document.getElementById('journalTags').value.trim();

            if (!content) {
                showJournalMessage('Please enter some content for your journal entry.', 'error');
                return;
            }

            const journalData = {
                title: title || null,
                content: content,
                moodBefore: moodBefore ? parseInt(moodBefore) : null,
                moodAfter: moodAfter ? parseInt(moodAfter) : null,
                tags: tagsInput ? tagsInput.split(',').map(tag => tag.trim()).filter(tag => tag) : []
            };

            // Disable button and show loading state
            saveBtn.disabled = true;
            saveBtn.textContent = currentEditingEntry ? 'Updating...' : 'Saving...';

            try {
                if (currentEditingEntry && entryCode) {
                    // Update existing entry
                    await apiClient.updateJournalEntry(entryCode, journalData);
                    showJournalMessage('Journal entry updated successfully!', 'success');
                } else {
                    // Create new entry
                    await apiClient.createJournalEntry(journalData);
                    showJournalMessage('Journal entry saved successfully!', 'success');
                }
                
                // Reset form and hide
                resetJournalForm();
                hideJournalForm();
                
                // Reload journal entries
                await loadJournalEntries();
                
            } catch (error) {
                console.error('Failed to save journal entry:', error);
                showJournalMessage('Failed to save journal entry. Please try again.', 'error');
            } finally {
                // Re-enable button
                saveBtn.disabled = false;
                saveBtn.textContent = 'Save Entry';
            }
        }

        async function loadJournalEntries() {
            const container = document.getElementById('journalHistoryContainer');
            if (!container) return;

            try {
                container.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">Loading journal entries...</div>';
                
                const entriesData = await apiClient.getJournalEntries(0, 50);
                journalData = entriesData.content || [];
                
                displayJournalEntries(journalData);
                
            } catch (error) {
                console.error('Failed to load journal entries:', error);
                container.innerHTML = '<div style="text-align: center; color: #ef4444; padding: 20px;">Failed to load journal entries</div>';
            }
        }

        async function searchJournalEntries() {
            const searchInput = document.getElementById('journalSearch');
            const query = searchInput ? searchInput.value.trim() : '';
            
            if (!query) {
                loadJournalEntries();
                return;
            }

            const container = document.getElementById('journalHistoryContainer');
            if (!container) return;

            try {
                container.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">Searching...</div>';
                
                const searchResults = await apiClient.searchJournalEntries(query);
                
                displayJournalEntries(searchResults);
                
            } catch (error) {
                console.error('Failed to search journal entries:', error);
                container.innerHTML = '<div style="text-align: center; color: #ef4444; padding: 20px;">Search failed</div>';
            }
        }

        function displayJournalEntries(entries) {
            const container = document.getElementById('journalHistoryContainer');
            if (!container) return;

            if (entries.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #666; padding: 20px;">No journal entries found. Create your first entry above!</div>';
                return;
            }

            const entriesHtml = entries.map(entry => {
                const date = new Date(entry.createdAt);
                const preview = entry.content ? (entry.content.length > 200 ? entry.content.substring(0, 200) + '...' : entry.content) : '';
                const tagsHtml = entry.tags && entry.tags.length > 0 
                    ? entry.tags.map(tag => `<span style="background: #dbeafe; color: #1d4ed8; padding: 2px 8px; border-radius: 12px; font-size: 12px; margin-right: 4px;">${tag}</span>`).join('')
                    : '';

                const moodInfo = [];
                if (entry.moodBefore) moodInfo.push(`Before: ${entry.moodBefore}/10`);
                if (entry.moodAfter) moodInfo.push(`After: ${entry.moodAfter}/10`);
                const moodText = moodInfo.length > 0 ? moodInfo.join(' • ') : '';

                return `
                    <div style="border: 1px solid #e5e7eb; border-radius: 10px; padding: 20px; margin-bottom: 15px; background: #fafafa;">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                            <div style="flex: 1;">
                                <h3 style="margin: 0 0 8px 0; color: #333; font-size: 1.1rem;">${entry.title || 'Untitled'}</h3>
                                <div style="color: #666; font-size: 12px; margin-bottom: 8px;">
                                    ${date.toLocaleString()} ${moodText ? `• ${moodText}` : ''}
                                </div>
                                ${tagsHtml ? `<div style="margin-bottom: 10px;">${tagsHtml}</div>` : ''}
                            </div>
                            <div style="display: flex; gap: 8px; margin-left: 16px;">
                                <button onclick="editJournalEntry(${JSON.stringify(entry).replace(/"/g, '&quot;')})" 
                                        style="padding: 6px 12px; background: #f3f4f6; color: #374151; border: none; border-radius: 6px; cursor: pointer; font-size: 12px;">
                                    Edit
                                </button>
                                <button onclick="deleteJournalEntry('${entry.code}')" 
                                        style="padding: 6px 12px; background: #fee; color: #dc2626; border: none; border-radius: 6px; cursor: pointer; font-size: 12px;">
                                    Delete
                                </button>
                            </div>
                        </div>
                        <div style="color: #555; line-height: 1.6; white-space: pre-wrap;">${preview}</div>
                    </div>
                `;
            }).join('');

            container.innerHTML = entriesHtml;
        }

        async function deleteJournalEntry(entryCode) {
            // Prevent deletion in demo mode
            if (isReadOnlyMode()) {
                showDemoModeAlert('Journal deletion is disabled in demo mode');
                return;
            }
            
            if (!confirm('Are you sure you want to delete this journal entry? This action cannot be undone.')) {
                return;
            }

            try {
                await apiClient.deleteJournalEntry(entryCode);
                showJournalMessage('Journal entry deleted successfully.', 'success');
                
                // Reload journal entries
                await loadJournalEntries();
                
            } catch (error) {
                console.error('Failed to delete journal entry:', error);
                showJournalMessage('Failed to delete journal entry. Please try again.', 'error');
            }
        }

        function showJournalMessage(message, type = 'info') {
            // Create or update message element
            let messageEl = document.getElementById('journalMessage');
            if (!messageEl) {
                messageEl = document.createElement('div');
                messageEl.id = 'journalMessage';
                messageEl.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    padding: 12px 20px;
                    border-radius: 8px;
                    color: white;
                    font-weight: 500;
                    z-index: 1000;
                    opacity: 0;
                    transform: translateY(-20px);
                    transition: all 0.3s ease;
                `;
                document.body.appendChild(messageEl);
            }

            // Set message and style based on type
            messageEl.textContent = message;
            messageEl.style.background = type === 'success' ? '#10b981' : type === 'error' ? '#ef4444' : '#3b82f6';

            // Show message
            setTimeout(() => {
                messageEl.style.opacity = '1';
                messageEl.style.transform = 'translateY(0)';
            }, 10);

            // Hide message after 3 seconds
            setTimeout(() => {
                messageEl.style.opacity = '0';
                messageEl.style.transform = 'translateY(-20px)';
            }, 3000);
        }
    </script>

    <script>
        // WebSocket connection (authentication variables are in the first script block)
        let stompClient = null;
        let connected = false;
        let connectionAttempts = 0;
        const maxRetries = 5;
        
        // Make connected status globally accessible
        window.getConnectionStatus = function() {
            return connected;
        };
        
        // Session tracking
        let sessionStartTime = Date.now();
        let messageCount = 0;
        let lastMessageTime = null; // Track last message timestamp for gap detection
        
        // Timestamp utilities - optimized for performance
        const TIME_GAP_THRESHOLD = 5 * 60 * 1000; // 5 minutes in milliseconds
        const DAY_MS = 24 * 60 * 60 * 1000; // 1 day in milliseconds
        
        // Cache for formatted timestamps to avoid repeated calculations
        const timestampCache = new Map();
        
        function formatTimestampHeader(timestamp) {
            // Use cache for performance
            const cacheKey = Math.floor(timestamp / 60000); // Cache by minute
            if (timestampCache.has(cacheKey)) {
                return timestampCache.get(cacheKey);
            }
            
            const now = new Date();
            const messageDate = new Date(timestamp);
            const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const yesterdayStart = new Date(todayStart.getTime() - DAY_MS);
            const weekAgo = new Date(todayStart.getTime() - 7 * DAY_MS);
            
            let formatted;
            
            if (messageDate >= todayStart) {
                // Today - just time
                formatted = messageDate.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
            } else if (messageDate >= yesterdayStart) {
                // Yesterday
                formatted = 'Yesterday ' + messageDate.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
            } else if (messageDate >= weekAgo) {
                // This week - day name + time
                formatted = messageDate.toLocaleDateString([], { weekday: 'long' }) + ' ' + 
                           messageDate.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
            } else {
                // Older - date + time
                formatted = messageDate.toLocaleDateString([], { month: 'short', day: 'numeric' }) + ', ' +
                           messageDate.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
            }
            
            // Cache result
            timestampCache.set(cacheKey, formatted);
            
            // Limit cache size for memory efficiency
            if (timestampCache.size > 1000) {
                const firstKey = timestampCache.keys().next().value;
                timestampCache.delete(firstKey);
            }
            
            return formatted;
        }
        
        function shouldShowTimestamp(currentTime, previousTime) {
            if (!previousTime) return true; // First message
            
            const timeDiff = currentTime - previousTime;
            if (timeDiff >= TIME_GAP_THRESHOLD) return true; // 5+ minute gap
            
            // Check if date changed (more precise than simple day comparison)
            const currentDate = new Date(currentTime);
            const previousDate = new Date(previousTime);
            
            return (currentDate.getDate() !== previousDate.getDate() || 
                    currentDate.getMonth() !== previousDate.getMonth() || 
                    currentDate.getFullYear() !== previousDate.getFullYear());
        }
        
        function createTimestampHeader(timestamp) {
            const headerDiv = document.createElement('div');
            headerDiv.className = 'timestamp-header';
            headerDiv.textContent = formatTimestampHeader(timestamp);
            return headerDiv;
        }

        // Note: Keycloak authentication is handled in the first script block above

        // Initialize WebSocket connection with STOMP
        function initWebSocket() {
            try {
                
                stompClient = new StompJs.Client({
                    brokerURL: API_CONFIG.websocketUrl,
                    connectHeaders: getAuthHeaders(),
                    debug: function (str) {
                    },
                    reconnectDelay: 5000,
                    heartbeatIncoming: 4000,
                    heartbeatOutgoing: 4000,
                });
                stompClient.onConnect = function (frame) {
                    connected = true;
                    connectionAttempts = 0;
                    
                    // Subscribe to user-specific queue
                    stompClient.subscribe('/user/queue/chat', function (message) {
                        try {
                            const chatMessage = JSON.parse(message.body);
                            handleWebSocketMessage(chatMessage);
                        } catch (error) {
                            console.error('Error parsing WebSocket message:', error);
                            console.error('Raw message body:', message.body);
                            // Try to handle as plain text
                            handleWebSocketMessage({ content: message.body, type: 'chat' });
                        }
                    });
                };

                stompClient.onStompError = function (frame) {
                    console.error('STOMP error: ' + frame.headers['message']);
                    console.error('Details: ' + frame.body);
                    connected = false;
                };

                stompClient.onWebSocketClose = function (event) {
                    connected = false;
                    
                    // Attempt to reconnect
                    if (connectionAttempts < maxRetries) {
                        connectionAttempts++;
                        setTimeout(() => {
                            stompClient.activate();
                        }, 2000 * connectionAttempts);
                    }
                };

                stompClient.activate();

            } catch (error) {
                console.error('Failed to create STOMP connection:', error);
            }
        }

        // Removed old sync getAuthHeaders - now using async version below


        function handleWebSocketMessage(message) {
            
            // Handle incoming WebSocket messages
            if (message.type === 'chat' || message.content) {
                // Display the message content
                const content = message.content || message.message || JSON.stringify(message);
                const messageTime = message.timestamp ? new Date(message.timestamp).getTime() : Date.now();
                addMessage(content, false, messageTime);
            } else {
                // Fallback: treat any message as a chat message
                const content = message.content || message.message || message.text || JSON.stringify(message);
                addMessage(content, false, Date.now());
            }
        }

        function sendWebSocketMessage(content) {
            if (stompClient && connected) {
                const message = {
                    content: content,
                    timestamp: new Date(),
                    type: 'user'
                };
                
                stompClient.publish({
                    destination: '/app/agent/conversation',
                    body: JSON.stringify(message)
                });
                return true;
            }
            return false;
        }



        // Initialize markdown-it with plugins
        let markdownRenderer = null;
        
        function initMarkdownRenderer() {
            if (typeof markdownit !== 'undefined' && !markdownRenderer) {
                markdownRenderer = markdownit({
                    html: true,        // Enable HTML tags in source
                    breaks: false,     // Don't auto-convert line breaks - let proper markdown handle it
                    linkify: true,     // Autoconvert URL-like text to links
                    typographer: false // Disable to avoid interference with formatting
                })
                .use(markdownitEmoji); // Add emoji support
            }
        }

        function formatMarkdown(text) {
            if (!text || typeof text !== 'string') return '';
            
            try {
                // Preprocess the text to fix AI formatting issues
                let cleanedText = text
                    .replace(/\\n/g, '\n')
                    .replace(/\\\"/g, '"')
                    // Fix the specific AI list format: "*   **Title:**" -> "- **Title:**"
                    .replace(/^\*\s+/gm, '- ')
                    // Ensure proper spacing around headers
                    .replace(/^(\*\*[^*]+\*\*):?\s*$/gm, '\n$1\n')
                    // Remove undefined artifacts
                    .replace(/\bundefined\b/g, '')
                    // Clean up excessive newlines
                    .replace(/\n{3,}/g, '\n\n')
                    .trim();
                
                // Initialize markdown renderer if not done
                initMarkdownRenderer();
                
                // Use markdown-it with proper configuration
                if (markdownRenderer) {
                    const rendered = markdownRenderer.render(cleanedText);
                    // Post-process to remove any remaining undefined artifacts
                    return rendered.replace(/undefined/g, '');
                }
                
                // Simple fallback: just handle line breaks and basic formatting
                return cleanedText
                    .replace(/\n/g, '<br>')
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*(.*?)\*/g, '<em>$1</em>');
                    
            } catch (error) {
                console.error('Error formatting markdown:', error);
                // Return plain text with line breaks as last resort
                return text.replace(/\n/g, '<br>').replace(/undefined/g, '');
            }
        }

        function enhancedMarkdownFormat(text) {
            // Enhanced markdown formatting with better support
            let formatted = text;
            
            // Convert headers (# ## ###)
            formatted = formatted.replace(/^### (.+)$/gm, '<h3>$1</h3>');
            formatted = formatted.replace(/^## (.+)$/gm, '<h2>$1</h2>');
            formatted = formatted.replace(/^# (.+)$/gm, '<h1>$1</h1>');
            
            // Convert **bold**
            formatted = formatted.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            
            // Convert *italic*
            formatted = formatted.replace(/\*([^*\n]+?)\*/g, '<em>$1</em>');
            
            // Convert links [text](url)
            formatted = formatted.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
            
            // Convert bullet points and nested lists
            const lines = formatted.split('\n');
            let inList = false;
            let listLevel = 0;
            let result = [];
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const bulletMatch = line.match(/^(\s*)\* (.+)$/);
                
                if (bulletMatch) {
                    const indent = bulletMatch[1].length;
                    const content = bulletMatch[2];
                    
                    if (!inList) {
                        result.push('<ul>');
                        inList = true;
                        listLevel = indent;
                    } else if (indent > listLevel) {
                        result.push('<ul>');
                        listLevel = indent;
                    } else if (indent < listLevel) {
                        result.push('</ul>');
                        listLevel = indent;
                    }
                    
                    result.push(`<li>${content}</li>`);
                } else {
                    if (inList) {
                        result.push('</ul>');
                        inList = false;
                        listLevel = 0;
                    }
                    
                    // Handle paragraphs
                    if (line.trim() === '') {
                        result.push('<br>');
                    } else {
                        result.push(line);
                    }
                }
            }
            
            // Close any remaining list
            if (inList) {
                result.push('</ul>');
            }
            
            formatted = result.join('\n');
            
            // Convert line breaks to proper HTML
            formatted = formatted.replace(/\n/g, '<br>');
            
            // Remove extra breaks around block elements
            formatted = formatted.replace(/<br><ul>/g, '<ul>');
            formatted = formatted.replace(/<\/ul><br>/g, '</ul>');
            formatted = formatted.replace(/<br><h([1-6])>/g, '<h$1>');
            formatted = formatted.replace(/<\/h([1-6])><br>/g, '</h$1>');
            
            return formatted;
        }

        // Debug function to test markdown rendering
        function testMarkdown() {
            const testContent = `# Test Markdown

This is a test of **bold text** and *italic text*.

## List Example
* First item
* Second item with **bold**
* Third item with [link](https://example.com)

### Nested List
* Main item
  * Sub item 1
  * Sub item 2
* Another main item

Visit [Google](https://google.com) for more info.`;
            
            
            // Add test message
            addMessage(testContent, false, Date.now());
        }

        // Test with CBT content (the problematic content)
        function testCBTContent() {
            const cbtContent = "Okay, here are some articles about Cognitive Behavioral Therapy (CBT), categorized for easier browsing. I've included a mix of introductory pieces, articles focusing on specific applications, and some from reputable sources.\\n\\nI. Introductory & Overview Articles:\\n\\n* American Psychological Association (APA): Cognitive Behavioral Therapy:\\n * Link: https://www.apa.org/ptsd-guideline/patients-and-families/cognitive-behavioral\\n * Summary: A good overview of CBT, its principles, and how it works. Explains the focus on thoughts, feelings, and behaviors, and how CBT helps individuals identify and change negative patterns.\\n\\n* Mayo Clinic: Cognitive behavioral therapy (CBT):\\n * Link: https://www.mayoclinic.org/tests-procedures/cognitive-behavioral-therapy/about/pac-20384610\\n * Summary: Provides a clear and concise explanation of CBT, including what to expect during therapy sessions, and conditions it can treat.";
            
            
            // Add test message
            addMessage(cbtContent, false, Date.now());
        }

        function addMessage(content, isUser = false, messageTime = null) {
            const messagesContainer = document.getElementById('messages');
            if (!messagesContainer) return;
            
            const currentTime = messageTime || Date.now();
            
            // Check if we need to show a timestamp header
            if (shouldShowTimestamp(currentTime, lastMessageTime)) {
                const timestampHeader = createTimestampHeader(currentTime);
                messagesContainer.appendChild(timestampHeader);
            }
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isUser ? 'user' : 'agent'}`;
            messageDiv.setAttribute('data-timestamp', currentTime); // Store for potential future use

            // Format content with markdown support
            const formattedContent = isUser ? content : formatMarkdown(content);

            messageDiv.innerHTML = `
                <div class="message-content">
                    ${formattedContent}
                </div>
            `;

            messagesContainer.appendChild(messageDiv);
            
            // Update last message time for gap detection
            lastMessageTime = currentTime;
            
            // Optimized scroll - use requestAnimationFrame for better performance
            requestAnimationFrame(() => {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            });

            if (isUser) {
                messageCount++;
            }
        }

        function showTypingIndicator() {
            document.getElementById('typingIndicator').classList.add('active');
            const messagesContainer = document.getElementById('messages');
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function hideTypingIndicator() {
            document.getElementById('typingIndicator').classList.remove('active');
        }


        function sendMessage() {
            // Prevent sending messages in demo mode
            if (isReadOnlyMode()) {
                showDemoModeAlert('Chat is disabled in demo mode');
                return;
            }
            
            const input = document.getElementById('messageInput');
            const message = input.value.trim();

            if (!message) return;

            // Add user message with current timestamp
            const userMessageTime = Date.now();
            addMessage(message, true, userMessageTime);
            
            // Clear input and reset to auto height
            input.value = '';
            input.style.height = 'auto';
            updateSendButton(); // Update send button state
            input.focus(); // Keep focus for next message

            // Try to send via WebSocket first
            const sentViaWS = sendWebSocketMessage(message);

            if (!sentViaWS) {
                // Show connection error message instead of automatic response
                const errorMessage = "Connection unavailable. Please check your internet connection or try again later.";
                addMessage(errorMessage, false, userMessageTime + 500);
            }
        }

        // Event listeners (initialized when main app is shown)
        function initializeMessageInput() {
            const messageInput = document.getElementById('messageInput');
            const sendButton = document.getElementById('sendButton');
            const textInputContainer = document.querySelector('.text-input-container');
            
            if (!messageInput || !sendButton) {
                setTimeout(initializeMessageInput, 500);
                return;
            }
            
            // Remove existing listeners to prevent duplicates
            messageInput.removeEventListener('keydown', handleKeyPress);
            messageInput.removeEventListener('input', handleInputChange);
            sendButton.removeEventListener('click', handleSendClick);
            if (textInputContainer) {
                textInputContainer.removeEventListener('click', handleContainerClick);
            }
            
            // Add event listeners
            messageInput.addEventListener('keydown', handleKeyPress);
            messageInput.addEventListener('input', handleInputChange);
            sendButton.addEventListener('click', handleSendClick);
            if (textInputContainer) {
                textInputContainer.addEventListener('click', handleContainerClick);
            }
            
            // Initialize send button state
            updateSendButton();
            
        }
        
        function handleKeyPress(e) {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                if (document.getElementById('sendButton').classList.contains('active')) {
                    sendMessage();
                }
            }
        }
        
        function handleInputChange(e) {
            autoExpand(e.target);
            updateSendButton();
        }
        
        function handleSendClick() {
            const sendButton = document.getElementById('sendButton');
            if (sendButton.classList.contains('active')) {
                sendMessage();
            }
        }
        
        function handleContainerClick() {
            document.getElementById('messageInput').focus();
        }
        
        function autoExpand(textarea) {
            textarea.style.height = 'auto';
            const scrollHeight = textarea.scrollHeight;
            const maxHeight = 120; // max-height in CSS
            
            if (scrollHeight <= maxHeight) {
                textarea.style.height = scrollHeight + 'px';
            } else {
                textarea.style.height = maxHeight + 'px';
            }
        }
        
        function updateSendButton() {
            const messageInput = document.getElementById('messageInput');
            const sendButton = document.getElementById('sendButton');
            const hasText = messageInput.value.trim().length > 0;
            
            if (hasText) {
                sendButton.classList.add('active');
            } else {
                sendButton.classList.remove('active');
            }
        }

        // Legacy logout function (keeping for compatibility)
        function logout() {
            keycloakLogout();
        }

        // Note: DOMContentLoaded listener is already defined in the Keycloak auth section above
        
        // Reactive token refresh: Only refresh when token actually expires
        async function refreshTokenAfterExpiry() {
            
            if (keycloakInstance && keycloakInstance.authenticated) {
                try {
                    // Force refresh using Keycloak
                    const refreshed = await keycloakInstance.updateToken(-1); // Force refresh
                    if (refreshed) {
                        localStorage.setItem('token', keycloakInstance.token);
                        if (keycloakInstance.refreshToken) {
                            localStorage.setItem('refreshToken', keycloakInstance.refreshToken);
                        }
                        return keycloakInstance.token;
                    }
                } catch (error) {
                    console.error('❌ Refresh token also expired or invalid:', error);
                    keycloakLogout();
                    throw new Error('Refresh failed - user needs to re-login');
                }
            } else {
                // Manual refresh token exchange for non-Keycloak flows
                const refreshToken = localStorage.getItem('refreshToken');
                if (refreshToken) {
                    try {
                        const response = await fetch(`${KEYCLOAK_CONFIG.url}/realms/${KEYCLOAK_CONFIG.realm}/protocol/openid-connect/token`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/x-www-form-urlencoded',
                            },
                            body: new URLSearchParams({
                                'grant_type': 'refresh_token',
                                'client_id': KEYCLOAK_CONFIG.clientId,
                                'refresh_token': refreshToken
                            })
                        });
                        
                        if (response.ok) {
                            const tokenData = await response.json();
                            localStorage.setItem('token', tokenData.access_token);
                            localStorage.setItem('refreshToken', tokenData.refresh_token);
                            return tokenData.access_token;
                        } else {
                            throw new Error('Refresh token request failed');
                        }
                    } catch (error) {
                        console.error('❌ Refresh token exchange failed:', error);
                        localStorage.removeItem('token');
                        localStorage.removeItem('refreshToken');
                            window.location.reload(); // Force re-authentication
                        throw error;
                    }
                } else {
                    window.location.reload();
                    throw new Error('No refresh token available');
                }
            }
        }

        // API call wrapper with automatic token refresh on 401
        async function makeAuthenticatedRequest(url, options = {}) {
            const token = keycloakInstance?.token || localStorage.getItem('token');
            
            // Add auth header
            const headers = {
                ...options.headers,
                'Authorization': `Bearer ${token}`
            };
            
            try {
                const response = await fetch(url, { ...options, headers });
                
                // If token expired (401), try to refresh and retry
                if (response.status === 401) {
                    const newToken = await refreshTokenAfterExpiry();
                    
                    // Retry the original request with new token
                    const retryHeaders = {
                        ...options.headers,
                        'Authorization': `Bearer ${newToken}`
                    };
                    
                    return fetch(url, { ...options, headers: retryHeaders });
                }
                
                return response;
            } catch (error) {
                console.error('Authenticated request failed:', error);
                throw error;
            }
        }

        // Simple auth headers for WebSocket (no auto-refresh needed for initial connection)
        function getAuthHeaders() {
            const headers = {};
            const currentToken = keycloakInstance?.token || localStorage.getItem('token');
            if (currentToken) {
                headers['Authorization'] = `Bearer ${currentToken}`;
                headers['X-Auth-Token'] = currentToken;
            }
            return headers;
        }

        // Chat history API functions
        async function fetchChatHistory() {
            try {
                const response = await makeAuthenticatedRequest(`${API_CONFIG.backendUrl}/v1/agent/chat/history`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                if (response.ok) {
                    const historyData = await response.json();
                    return historyData;
                } else {
                    throw new Error(`Failed to fetch chat history: ${response.status} ${response.statusText}`);
                }
            } catch (error) {
                console.error('Error fetching chat history:', error);
                throw error;
            }
        }

        async function loadChatHistory() {
            try {
                const historyData = await fetchChatHistory();
                
                if (historyData && historyData.length > 0) {
                    displayChatHistory(historyData);
                } else {
                }
            } catch (error) {
                console.error('Failed to load chat history:', error);
                showHistoryError('Failed to load chat history');
            }
        }

        function initChatView() {
            if (typeof initializeMessageInput === 'function') {
                initializeMessageInput();
            }
            if (typeof loadChatHistory === 'function') {
                loadChatHistory();
            }
        }

        function displayChatHistory(historyData) {
            const messagesContainer = document.getElementById('messages');
            if (!messagesContainer) return;

            // Clear existing messages and reset timestamp tracking
            messagesContainer.innerHTML = '';
            lastMessageTime = null;

            // Sort history by timestamp for proper ordering
            const sortedHistory = historyData.sort((a, b) => 
                new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
            );

            // Use document fragment for better performance when adding many elements
            const fragment = document.createDocumentFragment();

            // Add history messages with smart timestamps
            sortedHistory.forEach(historyMessage => {
                const isUser = historyMessage.type === 'user';
                const content = historyMessage.content;
                const messageTime = new Date(historyMessage.timestamp).getTime();
                
                // Check if we need a timestamp header
                if (shouldShowTimestamp(messageTime, lastMessageTime)) {
                    const timestampHeader = createTimestampHeader(messageTime);
                    fragment.appendChild(timestampHeader);
                }
                
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${isUser ? 'user' : 'agent'}`;
                messageDiv.setAttribute('data-history', 'true');
                messageDiv.setAttribute('data-timestamp', messageTime);

                // Format content with markdown support for agent messages
                const formattedContent = isUser ? content : formatMarkdown(content);

                messageDiv.innerHTML = `
                    <div class="message-content">
                        ${formattedContent}
                    </div>
                `;

                fragment.appendChild(messageDiv);
                lastMessageTime = messageTime;
            });

            // Add all elements at once for better performance
            messagesContainer.appendChild(fragment);

            // Add a divider between history and new messages
            const divider = document.createElement('div');
            divider.className = 'history-divider';
            divider.innerHTML = `
                <div style="text-align: center; padding: 20px; color: #666; font-size: 14px; border-bottom: 1px solid #e5e7eb; margin: 10px 0;">
                    <span style="background: #fafafa; padding: 0 15px;">Previous conversation loaded</span>
                </div>
            `;
            messagesContainer.appendChild(divider);

            // Optimized scroll
            requestAnimationFrame(() => {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            });

        }

        function showHistoryError(errorMessage) {
            const messagesContainer = document.getElementById('messages');
            if (!messagesContainer) return;

            const errorDiv = document.createElement('div');
            errorDiv.className = 'message system';
            errorDiv.innerHTML = `
                <div class="message-content" style="background: #fee; color: #c33; font-size: 12px; opacity: 0.8;">
                    ⚠️ ${errorMessage}
                </div>
            `;

            if (messagesContainer.children.length > 0) {
                messagesContainer.insertBefore(errorDiv, messagesContainer.children[0]);
            } else {
                messagesContainer.appendChild(errorDiv);
            }
        }
    </script>
</body>
</html>